From a9a9e0a6d829ea9f8acb37b7d76ff2edc00b1d0d Mon Sep 17 00:00:00 2001
From: Maxime Letemple <39882025+maxletemple@users.noreply.github.com>
Date: Wed, 9 Aug 2023 16:12:28 +0200
Subject: [UNIKRAFT/LWIP] update for scamper

---
 src/api/api_msg.c      |    2 +-
 src/api/sockets.c      | 6730 +++++++++++++++++++++-------------------
 src/core/ipv4/etharp.c |    2 -
 src/core/ipv4/ip4.c    | 1485 ++++-----
 src/core/pbuf.c        |    3 +-
 src/include/lwip/opt.h |   10 +-
 src/netif/ethernet.c   |    2 -
 7 files changed, 4413 insertions(+), 3821 deletions(-)

diff --git a/src/api/api_msg.c b/src/api/api_msg.c
index 3f08e03..c69ec5c 100644
--- a/src/api/api_msg.c
+++ b/src/api/api_msg.c
@@ -1535,7 +1535,6 @@ void
 lwip_netconn_do_send(void *m)
 {
   struct api_msg *msg = (struct api_msg *)m;
-
   err_t err = netconn_err(msg->conn);
   if (err == ERR_OK) {
     if (msg->conn->pcb.tcp != NULL) {
@@ -1545,6 +1544,7 @@ lwip_netconn_do_send(void *m)
           if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
             err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
           } else {
+            
             err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
           }
           break;
diff --git a/src/api/sockets.c b/src/api/sockets.c
index 5eb8362..3ddc9cb 100644
--- a/src/api/sockets.c
+++ b/src/api/sockets.c
@@ -40,7 +40,6 @@
 #define _BSD_SOURCE
 
 #include <sys/time.h>
-
 #include "lwip/opt.h"
 
 #if LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
@@ -86,107 +85,156 @@
 #define LWIP_NETCONN 0
 #endif
 
-#define API_SELECT_CB_VAR_REF(name)               API_VAR_REF(name)
-#define API_SELECT_CB_VAR_DECLARE(name)           API_VAR_DECLARE(struct lwip_select_cb, name)
-#define API_SELECT_CB_VAR_ALLOC(name, retblock)   API_VAR_ALLOC_EXT(struct lwip_select_cb, MEMP_SELECT_CB, name, retblock)
-#define API_SELECT_CB_VAR_FREE(name)              API_VAR_FREE(MEMP_SELECT_CB, name)
+#define API_SELECT_CB_VAR_REF(name) API_VAR_REF(name)
+#define API_SELECT_CB_VAR_DECLARE(name) API_VAR_DECLARE(struct lwip_select_cb, name)
+#define API_SELECT_CB_VAR_ALLOC(name, retblock) API_VAR_ALLOC_EXT(struct lwip_select_cb, MEMP_SELECT_CB, name, retblock)
+#define API_SELECT_CB_VAR_FREE(name) API_VAR_FREE(MEMP_SELECT_CB, name)
 
 #if LWIP_IPV4
 #define SIN_ZERO_LEN 8
-#define IP4ADDR_PORT_TO_SOCKADDR(sin, ipaddr, port) do { \
-      (sin)->sin_family = AF_INET; \
-      (sin)->sin_port = lwip_htons((port)); \
-      inet_addr_from_ip4addr(&(sin)->sin_addr, ipaddr); \
-      memset((sin)->sin_zero, 0, SIN_ZERO_LEN); }while(0)
-#define SOCKADDR4_TO_IP4ADDR_PORT(sin, ipaddr, port) do { \
-    inet_addr_to_ip4addr(ip_2_ip4(ipaddr), &((sin)->sin_addr)); \
-    (port) = lwip_ntohs((sin)->sin_port); }while(0)
+#define IP4ADDR_PORT_TO_SOCKADDR(sin, ipaddr, port)       \
+	do                                                    \
+	{                                                     \
+		(sin)->sin_family = AF_INET;                      \
+		(sin)->sin_port = lwip_htons((port));             \
+		inet_addr_from_ip4addr(&(sin)->sin_addr, ipaddr); \
+		memset((sin)->sin_zero, 0, SIN_ZERO_LEN);         \
+	} while (0)
+#define SOCKADDR4_TO_IP4ADDR_PORT(sin, ipaddr, port)                \
+	do                                                              \
+	{                                                               \
+		inet_addr_to_ip4addr(ip_2_ip4(ipaddr), &((sin)->sin_addr)); \
+		(port) = lwip_ntohs((sin)->sin_port);                       \
+	} while (0)
 #endif /* LWIP_IPV4 */
 
 #if LWIP_IPV6
-#define IP6ADDR_PORT_TO_SOCKADDR(sin6, ipaddr, port) do { \
-      (sin6)->sin6_family = AF_INET6; \
-      (sin6)->sin6_port = lwip_htons((port)); \
-      (sin6)->sin6_flowinfo = 0; \
-      inet6_addr_from_ip6addr(&(sin6)->sin6_addr, ipaddr); \
-      (sin6)->sin6_scope_id = ip6_addr_zone(ipaddr); }while(0)
-#define SOCKADDR6_TO_IP6ADDR_PORT(sin6, ipaddr, port) do { \
-    inet6_addr_to_ip6addr(ip_2_ip6(ipaddr), &((sin6)->sin6_addr)); \
-    if (ip6_addr_has_scope(ip_2_ip6(ipaddr), IP6_UNKNOWN)) { \
-      ip6_addr_set_zone(ip_2_ip6(ipaddr), (u8_t)((sin6)->sin6_scope_id)); \
-    } \
-    (port) = lwip_ntohs((sin6)->sin6_port); }while(0)
+#define IP6ADDR_PORT_TO_SOCKADDR(sin6, ipaddr, port)         \
+	do                                                       \
+	{                                                        \
+		(sin6)->sin6_family = AF_INET6;                      \
+		(sin6)->sin6_port = lwip_htons((port));              \
+		(sin6)->sin6_flowinfo = 0;                           \
+		inet6_addr_from_ip6addr(&(sin6)->sin6_addr, ipaddr); \
+		(sin6)->sin6_scope_id = ip6_addr_zone(ipaddr);       \
+	} while (0)
+#define SOCKADDR6_TO_IP6ADDR_PORT(sin6, ipaddr, port)                           \
+	do                                                                          \
+	{                                                                           \
+		inet6_addr_to_ip6addr(ip_2_ip6(ipaddr), &((sin6)->sin6_addr));          \
+		if (ip6_addr_has_scope(ip_2_ip6(ipaddr), IP6_UNKNOWN))                  \
+		{                                                                       \
+			ip6_addr_set_zone(ip_2_ip6(ipaddr), (u8_t)((sin6)->sin6_scope_id)); \
+		}                                                                       \
+		(port) = lwip_ntohs((sin6)->sin6_port);                                 \
+	} while (0)
 #endif /* LWIP_IPV6 */
 
 #if LWIP_IPV4 && LWIP_IPV6
 static void sockaddr_to_ipaddr_port(const struct sockaddr *sockaddr, ip_addr_t *ipaddr, u16_t *port);
 
-#define IS_SOCK_ADDR_LEN_VALID(namelen)  (((namelen) == sizeof(struct sockaddr_in)) || \
-                                         ((namelen) == sizeof(struct sockaddr_in6)))
-#define IS_SOCK_ADDR_TYPE_VALID(name)    (((name)->sa_family == AF_INET) || \
-                                         ((name)->sa_family == AF_INET6))
-#define SOCK_ADDR_TYPE_MATCH(name, sock) \
-       ((((name)->sa_family == AF_INET) && !(NETCONNTYPE_ISIPV6((sock)->conn->type))) || \
-       (((name)->sa_family == AF_INET6) && (NETCONNTYPE_ISIPV6((sock)->conn->type))))
-#define IPADDR_PORT_TO_SOCKADDR(sockaddr, ipaddr, port) do { \
-    if (IP_IS_ANY_TYPE_VAL(*ipaddr) || IP_IS_V6_VAL(*ipaddr)) { \
-      IP6ADDR_PORT_TO_SOCKADDR((struct sockaddr_in6*)(void*)(sockaddr), ip_2_ip6(ipaddr), port); \
-    } else { \
-      IP4ADDR_PORT_TO_SOCKADDR((struct sockaddr_in*)(void*)(sockaddr), ip_2_ip4(ipaddr), port); \
-    } } while(0)
+#define IS_SOCK_ADDR_LEN_VALID(namelen) (((namelen) == sizeof(struct sockaddr_in)) || \
+										 ((namelen) == sizeof(struct sockaddr_in6)))
+#define IS_SOCK_ADDR_TYPE_VALID(name) (((name)->sa_family == AF_INET) || \
+									   ((name)->sa_family == AF_INET6))
+#define SOCK_ADDR_TYPE_MATCH(name, sock)                                              \
+	((((name)->sa_family == AF_INET) && !(NETCONNTYPE_ISIPV6((sock)->conn->type))) || \
+	 (((name)->sa_family == AF_INET6) && (NETCONNTYPE_ISIPV6((sock)->conn->type))))
+#define IPADDR_PORT_TO_SOCKADDR(sockaddr, ipaddr, port)                                                  \
+	do                                                                                                   \
+	{                                                                                                    \
+		if (IP_IS_ANY_TYPE_VAL(*ipaddr) || IP_IS_V6_VAL(*ipaddr))                                        \
+		{                                                                                                \
+			IP6ADDR_PORT_TO_SOCKADDR((struct sockaddr_in6 *)(void *)(sockaddr), ip_2_ip6(ipaddr), port); \
+		}                                                                                                \
+		else                                                                                             \
+		{                                                                                                \
+			IP4ADDR_PORT_TO_SOCKADDR((struct sockaddr_in *)(void *)(sockaddr), ip_2_ip4(ipaddr), port);  \
+		}                                                                                                \
+	} while (0)
 #define SOCKADDR_TO_IPADDR_PORT(sockaddr, ipaddr, port) sockaddr_to_ipaddr_port(sockaddr, ipaddr, &(port))
-#define DOMAIN_TO_NETCONN_TYPE(domain, type) (((domain) == AF_INET) ? \
-  (type) : (enum netconn_type)((type) | NETCONN_TYPE_IPV6))
+#define DOMAIN_TO_NETCONN_TYPE(domain, type) (((domain) == AF_INET) ? (type) : (enum netconn_type)((type) | NETCONN_TYPE_IPV6))
 #elif LWIP_IPV6 /* LWIP_IPV4 && LWIP_IPV6 */
-#define IS_SOCK_ADDR_LEN_VALID(namelen)  ((namelen) == sizeof(struct sockaddr_in6))
-#define IS_SOCK_ADDR_TYPE_VALID(name)    ((name)->sa_family == AF_INET6)
+#define IS_SOCK_ADDR_LEN_VALID(namelen) ((namelen) == sizeof(struct sockaddr_in6))
+#define IS_SOCK_ADDR_TYPE_VALID(name) ((name)->sa_family == AF_INET6)
 #define SOCK_ADDR_TYPE_MATCH(name, sock) 1
 #define IPADDR_PORT_TO_SOCKADDR(sockaddr, ipaddr, port) \
-        IP6ADDR_PORT_TO_SOCKADDR((struct sockaddr_in6*)(void*)(sockaddr), ip_2_ip6(ipaddr), port)
+	IP6ADDR_PORT_TO_SOCKADDR((struct sockaddr_in6 *)(void *)(sockaddr), ip_2_ip6(ipaddr), port)
 #define SOCKADDR_TO_IPADDR_PORT(sockaddr, ipaddr, port) \
-        SOCKADDR6_TO_IP6ADDR_PORT((const struct sockaddr_in6*)(const void*)(sockaddr), ipaddr, port)
+	SOCKADDR6_TO_IP6ADDR_PORT((const struct sockaddr_in6 *)(const void *)(sockaddr), ipaddr, port)
 #define DOMAIN_TO_NETCONN_TYPE(domain, netconn_type) (netconn_type)
 #else /*-> LWIP_IPV4: LWIP_IPV4 && LWIP_IPV6 */
-#define IS_SOCK_ADDR_LEN_VALID(namelen)  ((namelen) == sizeof(struct sockaddr_in))
-#define IS_SOCK_ADDR_TYPE_VALID(name)    ((name)->sa_family == AF_INET)
+#define IS_SOCK_ADDR_LEN_VALID(namelen) ((namelen) == sizeof(struct sockaddr_in))
+#define IS_SOCK_ADDR_TYPE_VALID(name) ((name)->sa_family == AF_INET)
 #define SOCK_ADDR_TYPE_MATCH(name, sock) 1
 #define IPADDR_PORT_TO_SOCKADDR(sockaddr, ipaddr, port) \
-        IP4ADDR_PORT_TO_SOCKADDR((struct sockaddr_in*)(void*)(sockaddr), ip_2_ip4(ipaddr), port)
+	IP4ADDR_PORT_TO_SOCKADDR((struct sockaddr_in *)(void *)(sockaddr), ip_2_ip4(ipaddr), port)
 #define SOCKADDR_TO_IPADDR_PORT(sockaddr, ipaddr, port) \
-        SOCKADDR4_TO_IP4ADDR_PORT((const struct sockaddr_in*)(const void*)(sockaddr), ipaddr, port)
+	SOCKADDR4_TO_IP4ADDR_PORT((const struct sockaddr_in *)(const void *)(sockaddr), ipaddr, port)
 #define DOMAIN_TO_NETCONN_TYPE(domain, netconn_type) (netconn_type)
 #endif /* LWIP_IPV6 */
 
-#define IS_SOCK_ADDR_TYPE_VALID_OR_UNSPEC(name)    (((name)->sa_family == AF_UNSPEC) || \
-                                                    IS_SOCK_ADDR_TYPE_VALID(name))
+#define IS_SOCK_ADDR_TYPE_VALID_OR_UNSPEC(name) (((name)->sa_family == AF_UNSPEC) || \
+												 IS_SOCK_ADDR_TYPE_VALID(name))
 #define SOCK_ADDR_TYPE_MATCH_OR_UNSPEC(name, sock) (((name)->sa_family == AF_UNSPEC) || \
-                                                    SOCK_ADDR_TYPE_MATCH(name, sock))
-#define IS_SOCK_ADDR_ALIGNED(name)      ((((mem_ptr_t)(name)) % 4) == 0)
-
-
-#define LWIP_SOCKOPT_CHECK_OPTLEN(sock, optlen, opttype) do { if ((optlen) < sizeof(opttype)) { done_socket(sock); return EINVAL; }}while(0)
-#define LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, opttype) do { \
-  LWIP_SOCKOPT_CHECK_OPTLEN(sock, optlen, opttype); \
-  if ((sock)->conn == NULL) { done_socket(sock); return EINVAL; } }while(0)
-#define LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, opttype) do { \
-  LWIP_SOCKOPT_CHECK_OPTLEN(sock, optlen, opttype); \
-  if (((sock)->conn == NULL) || ((sock)->conn->pcb.tcp == NULL)) { done_socket(sock); return EINVAL; } }while(0)
-#define LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, opttype, netconntype) do { \
-  LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, opttype); \
-  if (NETCONNTYPE_GROUP(netconn_type((sock)->conn)) != netconntype) { done_socket(sock); return ENOPROTOOPT; } }while(0)
-
-
-#define LWIP_SETGETSOCKOPT_DATA_VAR_REF(name)     API_VAR_REF(name)
+													SOCK_ADDR_TYPE_MATCH(name, sock))
+#define IS_SOCK_ADDR_ALIGNED(name) ((((mem_ptr_t)(name)) % 4) == 0)
+
+#define LWIP_SOCKOPT_CHECK_OPTLEN(sock, optlen, opttype) \
+	do                                                   \
+	{                                                    \
+		if ((optlen) < sizeof(opttype))                  \
+		{                                                \
+			done_socket(sock);                           \
+			return EINVAL;                               \
+		}                                                \
+	} while (0)
+#define LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, opttype) \
+	do                                                        \
+	{                                                         \
+		LWIP_SOCKOPT_CHECK_OPTLEN(sock, optlen, opttype);     \
+		if ((sock)->conn == NULL)                             \
+		{                                                     \
+			done_socket(sock);                                \
+			return EINVAL;                                    \
+		}                                                     \
+	} while (0)
+#define LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, opttype)      \
+	do                                                                 \
+	{                                                                  \
+		LWIP_SOCKOPT_CHECK_OPTLEN(sock, optlen, opttype);              \
+		if (((sock)->conn == NULL) || ((sock)->conn->pcb.tcp == NULL)) \
+		{                                                              \
+			done_socket(sock);                                         \
+			return EINVAL;                                             \
+		}                                                              \
+	} while (0)
+#define LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, opttype, netconntype) \
+	do                                                                              \
+	{                                                                               \
+		LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, opttype);                  \
+		if (NETCONNTYPE_GROUP(netconn_type((sock)->conn)) != netconntype)           \
+		{                                                                           \
+			done_socket(sock);                                                      \
+			return ENOPROTOOPT;                                                     \
+		}                                                                           \
+	} while (0)
+
+#define LWIP_SETGETSOCKOPT_DATA_VAR_REF(name) API_VAR_REF(name)
 #define LWIP_SETGETSOCKOPT_DATA_VAR_DECLARE(name) API_VAR_DECLARE(struct lwip_setgetsockopt_data, name)
-#define LWIP_SETGETSOCKOPT_DATA_VAR_FREE(name)    API_VAR_FREE(MEMP_SOCKET_SETGETSOCKOPT_DATA, name)
+#define LWIP_SETGETSOCKOPT_DATA_VAR_FREE(name) API_VAR_FREE(MEMP_SOCKET_SETGETSOCKOPT_DATA, name)
 #if LWIP_MPU_COMPATIBLE
-#define LWIP_SETGETSOCKOPT_DATA_VAR_ALLOC(name, sock) do { \
-  name = (struct lwip_setgetsockopt_data *)memp_malloc(MEMP_SOCKET_SETGETSOCKOPT_DATA); \
-  if (name == NULL) { \
-    sock_set_errno(sock, ENOMEM); \
-    done_socket(sock); \
-    return -1; \
-  } }while(0)
+#define LWIP_SETGETSOCKOPT_DATA_VAR_ALLOC(name, sock)                                         \
+	do                                                                                        \
+	{                                                                                         \
+		name = (struct lwip_setgetsockopt_data *)memp_malloc(MEMP_SOCKET_SETGETSOCKOPT_DATA); \
+		if (name == NULL)                                                                     \
+		{                                                                                     \
+			sock_set_errno(sock, ENOMEM);                                                     \
+			done_socket(sock);                                                                \
+			return -1;                                                                        \
+		}                                                                                     \
+	} while (0)
 #else /* LWIP_MPU_COMPATIBLE */
 #define LWIP_SETGETSOCKOPT_DATA_VAR_ALLOC(name, sock)
 #endif /* LWIP_MPU_COMPATIBLE */
@@ -194,27 +242,30 @@ static void sockaddr_to_ipaddr_port(const struct sockaddr *sockaddr, ip_addr_t *
 #if LWIP_SO_SNDRCVTIMEO_NONSTANDARD
 #define LWIP_SO_SNDRCVTIMEO_OPTTYPE int
 #define LWIP_SO_SNDRCVTIMEO_SET(optval, val) (*(int *)(optval) = (val))
-#define LWIP_SO_SNDRCVTIMEO_GET_MS(optval)   ((long)*(const int*)(optval))
+#define LWIP_SO_SNDRCVTIMEO_GET_MS(optval) ((long)*(const int *)(optval))
 #else
 #define LWIP_SO_SNDRCVTIMEO_OPTTYPE struct timeval
-#define LWIP_SO_SNDRCVTIMEO_SET(optval, val)  do { \
-  u32_t loc = (val); \
-  ((struct timeval *)(optval))->tv_sec = (long)((loc) / 1000U); \
-  ((struct timeval *)(optval))->tv_usec = (long)(((loc) % 1000U) * 1000U); }while(0)
+#define LWIP_SO_SNDRCVTIMEO_SET(optval, val)                                     \
+	do                                                                           \
+	{                                                                            \
+		u32_t loc = (val);                                                       \
+		((struct timeval *)(optval))->tv_sec = (long)((loc) / 1000U);            \
+		((struct timeval *)(optval))->tv_usec = (long)(((loc) % 1000U) * 1000U); \
+	} while (0)
 #define LWIP_SO_SNDRCVTIMEO_GET_MS(optval) ((((const struct timeval *)(optval))->tv_sec * 1000) + (((const struct timeval *)(optval))->tv_usec / 1000))
 #endif
 
-
 /** A struct sockaddr replacement that has the same alignment as sockaddr_in/
  *  sockaddr_in6 if instantiated.
  */
-union sockaddr_aligned {
-  struct sockaddr sa;
+union sockaddr_aligned
+{
+	struct sockaddr sa;
 #if LWIP_IPV6
-  struct sockaddr_in6 sin6;
+	struct sockaddr_in6 sin6;
 #endif /* LWIP_IPV6 */
 #if LWIP_IPV4
-  struct sockaddr_in sin;
+	struct sockaddr_in sin;
 #endif /* LWIP_IPV4 */
 };
 
@@ -226,18 +277,19 @@ union sockaddr_aligned {
 #if LWIP_IGMP
 /* This is to keep track of IP_ADD_MEMBERSHIP calls to drop the membership when
    a socket is closed */
-struct lwip_socket_multicast_pair {
-  /** the socket */
-  struct lwip_sock *sock;
-  /** the interface address */
-  ip4_addr_t if_addr;
-  /** the group address */
-  ip4_addr_t multi_addr;
+struct lwip_socket_multicast_pair
+{
+	/** the socket */
+	struct lwip_sock *sock;
+	/** the interface address */
+	ip4_addr_t if_addr;
+	/** the group address */
+	ip4_addr_t multi_addr;
 };
 
 static struct lwip_socket_multicast_pair socket_ipv4_multicast_memberships[LWIP_SOCKET_MAX_MEMBERSHIPS];
 
-static int  lwip_socket_register_membership(int s, const ip4_addr_t *if_addr, const ip4_addr_t *multi_addr);
+static int lwip_socket_register_membership(int s, const ip4_addr_t *if_addr, const ip4_addr_t *multi_addr);
 static void lwip_socket_unregister_membership(int s, const ip4_addr_t *if_addr, const ip4_addr_t *multi_addr);
 static void lwip_socket_drop_registered_memberships(int s);
 #endif /* LWIP_IGMP */
@@ -245,18 +297,19 @@ static void lwip_socket_drop_registered_memberships(int s);
 #if LWIP_IPV6_MLD
 /* This is to keep track of IP_JOIN_GROUP calls to drop the membership when
    a socket is closed */
-struct lwip_socket_multicast_mld6_pair {
-  /** the socket */
-  struct lwip_sock *sock;
-  /** the interface index */
-  u8_t if_idx;
-  /** the group address */
-  ip6_addr_t multi_addr;
+struct lwip_socket_multicast_mld6_pair
+{
+	/** the socket */
+	struct lwip_sock *sock;
+	/** the interface index */
+	u8_t if_idx;
+	/** the group address */
+	ip6_addr_t multi_addr;
 };
 
 static struct lwip_socket_multicast_mld6_pair socket_ipv6_multicast_memberships[LWIP_SOCKET_MAX_MEMBERSHIPS];
 
-static int  lwip_socket_register_mld6_membership(int s, unsigned int if_idx, const ip6_addr_t *multi_addr);
+static int lwip_socket_register_mld6_membership(int s, unsigned int if_idx, const ip6_addr_t *multi_addr);
 static void lwip_socket_unregister_mld6_membership(int s, unsigned int if_idx, const ip6_addr_t *multi_addr);
 static void lwip_socket_drop_registered_mld6_memberships(int s);
 #endif /* LWIP_IPV6_MLD */
@@ -268,25 +321,27 @@ static struct lwip_sock sockets[NUM_SOCKETS];
 #if LWIP_TCPIP_CORE_LOCKING
 /* protect the select_cb_list using core lock */
 #define LWIP_SOCKET_SELECT_DECL_PROTECT(lev)
-#define LWIP_SOCKET_SELECT_PROTECT(lev)   LOCK_TCPIP_CORE()
+#define LWIP_SOCKET_SELECT_PROTECT(lev) LOCK_TCPIP_CORE()
 #define LWIP_SOCKET_SELECT_UNPROTECT(lev) UNLOCK_TCPIP_CORE()
 #else /* LWIP_TCPIP_CORE_LOCKING */
 /* protect the select_cb_list using SYS_LIGHTWEIGHT_PROT */
-#define LWIP_SOCKET_SELECT_DECL_PROTECT(lev)  SYS_ARCH_DECL_PROTECT(lev)
-#define LWIP_SOCKET_SELECT_PROTECT(lev)       SYS_ARCH_PROTECT(lev)
-#define LWIP_SOCKET_SELECT_UNPROTECT(lev)     SYS_ARCH_UNPROTECT(lev)
+#define LWIP_SOCKET_SELECT_DECL_PROTECT(lev) SYS_ARCH_DECL_PROTECT(lev)
+#define LWIP_SOCKET_SELECT_PROTECT(lev) SYS_ARCH_PROTECT(lev)
+#define LWIP_SOCKET_SELECT_UNPROTECT(lev) SYS_ARCH_UNPROTECT(lev)
 /** This counter is increased from lwip_select when the list is changed
-    and checked in select_check_waiters to see if it has changed. */
+	and checked in select_check_waiters to see if it has changed. */
 static volatile int select_cb_ctr;
 #endif /* LWIP_TCPIP_CORE_LOCKING */
 /** The global list of tasks waiting for select */
 static struct lwip_select_cb *select_cb_list;
 #endif /* LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL */
 
-#define sock_set_errno(sk, e) do { \
-  const int sockerr = (e); \
-  set_errno(sockerr); \
-} while (0)
+#define sock_set_errno(sk, e)    \
+	do                           \
+	{                            \
+		const int sockerr = (e); \
+		set_errno(sockerr);      \
+	} while (0)
 
 /* Forward declaration of some functions */
 #if LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL
@@ -304,35 +359,36 @@ static void lwip_setsockopt_callback(void *arg);
 static int lwip_getsockopt_impl(int s, int level, int optname, void *optval, socklen_t *optlen);
 static int lwip_setsockopt_impl(int s, int level, int optname, const void *optval, socklen_t optlen);
 static int free_socket_locked(struct lwip_sock *sock, int is_tcp, struct netconn **conn,
-                              union lwip_sock_lastdata *lastdata);
+							  union lwip_sock_lastdata *lastdata);
 static void free_socket_free_elements(int is_tcp, struct netconn *conn, union lwip_sock_lastdata *lastdata);
 
 #if LWIP_IPV4 && LWIP_IPV6
 static void
 sockaddr_to_ipaddr_port(const struct sockaddr *sockaddr, ip_addr_t *ipaddr, u16_t *port)
 {
-  if ((sockaddr->sa_family) == AF_INET6) {
-    SOCKADDR6_TO_IP6ADDR_PORT((const struct sockaddr_in6 *)(const void *)(sockaddr), ipaddr, *port);
-    ipaddr->type = IPADDR_TYPE_V6;
-  } else {
-    SOCKADDR4_TO_IP4ADDR_PORT((const struct sockaddr_in *)(const void *)(sockaddr), ipaddr, *port);
-    ipaddr->type = IPADDR_TYPE_V4;
-  }
+	if ((sockaddr->sa_family) == AF_INET6)
+	{
+		SOCKADDR6_TO_IP6ADDR_PORT((const struct sockaddr_in6 *)(const void *)(sockaddr), ipaddr, *port);
+		ipaddr->type = IPADDR_TYPE_V6;
+	}
+	else
+	{
+		SOCKADDR4_TO_IP4ADDR_PORT((const struct sockaddr_in *)(const void *)(sockaddr), ipaddr, *port);
+		ipaddr->type = IPADDR_TYPE_V4;
+	}
 }
 #endif /* LWIP_IPV4 && LWIP_IPV6 */
 
 /** LWIP_NETCONN_SEM_PER_THREAD==1: initialize thread-local semaphore */
-void
-lwip_socket_thread_init(void)
+void lwip_socket_thread_init(void)
 {
-  netconn_thread_init();
+	netconn_thread_init();
 }
 
 /** LWIP_NETCONN_SEM_PER_THREAD==1: destroy thread-local semaphore */
-void
-lwip_socket_thread_cleanup(void)
+void lwip_socket_thread_cleanup(void)
 {
-  netconn_thread_cleanup();
+	netconn_thread_cleanup();
 }
 
 #if LWIP_NETCONN_FULLDUPLEX
@@ -340,38 +396,42 @@ lwip_socket_thread_cleanup(void)
 static int
 sock_inc_used(struct lwip_sock *sock)
 {
-  int ret;
-  SYS_ARCH_DECL_PROTECT(lev);
-
-  LWIP_ASSERT("sock != NULL", sock != NULL);
-
-  SYS_ARCH_PROTECT(lev);
-  if (sock->fd_free_pending) {
-    /* prevent new usage of this socket if free is pending */
-    ret = 0;
-  } else {
-    ++sock->fd_used;
-    ret = 1;
-    LWIP_ASSERT("sock->fd_used != 0", sock->fd_used != 0);
-  }
-  SYS_ARCH_UNPROTECT(lev);
-  return ret;
+	int ret;
+	SYS_ARCH_DECL_PROTECT(lev);
+
+	LWIP_ASSERT("sock != NULL", sock != NULL);
+
+	SYS_ARCH_PROTECT(lev);
+	if (sock->fd_free_pending)
+	{
+		/* prevent new usage of this socket if free is pending */
+		ret = 0;
+	}
+	else
+	{
+		++sock->fd_used;
+		ret = 1;
+		LWIP_ASSERT("sock->fd_used != 0", sock->fd_used != 0);
+	}
+	SYS_ARCH_UNPROTECT(lev);
+	return ret;
 }
 
 /* Like sock_inc_used(), but called under SYS_ARCH_PROTECT lock. */
 static int
 sock_inc_used_locked(struct lwip_sock *sock)
 {
-  LWIP_ASSERT("sock != NULL", sock != NULL);
+	LWIP_ASSERT("sock != NULL", sock != NULL);
 
-  if (sock->fd_free_pending) {
-    LWIP_ASSERT("sock->fd_used != 0", sock->fd_used != 0);
-    return 0;
-  }
+	if (sock->fd_free_pending)
+	{
+		LWIP_ASSERT("sock->fd_used != 0", sock->fd_used != 0);
+		return 0;
+	}
 
-  ++sock->fd_used;
-  LWIP_ASSERT("sock->fd_used != 0", sock->fd_used != 0);
-  return 1;
+	++sock->fd_used;
+	LWIP_ASSERT("sock->fd_used != 0", sock->fd_used != 0);
+	return 1;
 }
 
 /* In full-duplex mode,sock->fd_used != 0 prevents a socket descriptor from being
@@ -382,33 +442,36 @@ sock_inc_used_locked(struct lwip_sock *sock)
 static void
 done_socket(struct lwip_sock *sock)
 {
-  int freed = 0;
-  int is_tcp = 0;
-  struct netconn *conn = NULL;
-  union lwip_sock_lastdata lastdata;
-  SYS_ARCH_DECL_PROTECT(lev);
-  LWIP_ASSERT("sock != NULL", sock != NULL);
-
-  SYS_ARCH_PROTECT(lev);
-  LWIP_ASSERT("sock->fd_used > 0", sock->fd_used > 0);
-  if (--sock->fd_used == 0) {
-    if (sock->fd_free_pending) {
-      /* free the socket */
-      sock->fd_used = 1;
-      is_tcp = sock->fd_free_pending & LWIP_SOCK_FD_FREE_TCP;
-      freed = free_socket_locked(sock, is_tcp, &conn, &lastdata);
-    }
-  }
-  SYS_ARCH_UNPROTECT(lev);
-
-  if (freed) {
-    free_socket_free_elements(is_tcp, conn, &lastdata);
-  }
+	int freed = 0;
+	int is_tcp = 0;
+	struct netconn *conn = NULL;
+	union lwip_sock_lastdata lastdata;
+	SYS_ARCH_DECL_PROTECT(lev);
+	LWIP_ASSERT("sock != NULL", sock != NULL);
+
+	SYS_ARCH_PROTECT(lev);
+	LWIP_ASSERT("sock->fd_used > 0", sock->fd_used > 0);
+	if (--sock->fd_used == 0)
+	{
+		if (sock->fd_free_pending)
+		{
+			/* free the socket */
+			sock->fd_used = 1;
+			is_tcp = sock->fd_free_pending & LWIP_SOCK_FD_FREE_TCP;
+			freed = free_socket_locked(sock, is_tcp, &conn, &lastdata);
+		}
+	}
+	SYS_ARCH_UNPROTECT(lev);
+
+	if (freed)
+	{
+		free_socket_free_elements(is_tcp, conn, &lastdata);
+	}
 }
 
 #else /* LWIP_NETCONN_FULLDUPLEX */
-#define sock_inc_used(sock)         1
-#define sock_inc_used_locked(sock)  1
+#define sock_inc_used(sock) 1
+#define sock_inc_used_locked(sock) 1
 #define done_socket(sock)
 #endif /* LWIP_NETCONN_FULLDUPLEX */
 
@@ -416,44 +479,49 @@ done_socket(struct lwip_sock *sock)
 static struct lwip_sock *
 tryget_socket_unconn_nouse(int fd)
 {
-  int s = fd - LWIP_SOCKET_OFFSET;
-  if ((s < 0) || (s >= NUM_SOCKETS)) {
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("tryget_socket_unconn(%d): invalid\n", fd));
-    return NULL;
-  }
-  return &sockets[s];
+	int s = fd - LWIP_SOCKET_OFFSET;
+	if ((s < 0) || (s >= NUM_SOCKETS))
+	{
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("tryget_socket_unconn(%d): invalid\n", fd));
+		return NULL;
+	}
+	return &sockets[s];
 }
 
 struct lwip_sock *
 lwip_socket_dbg_get_socket(int fd)
 {
-  return tryget_socket_unconn_nouse(fd);
+	return tryget_socket_unconn_nouse(fd);
 }
 
 /* Translate a socket 'int' into a pointer (only fails if the index is invalid) */
 static struct lwip_sock *
 tryget_socket_unconn(int fd)
 {
-  struct lwip_sock *ret = tryget_socket_unconn_nouse(fd);
-  if (ret != NULL) {
-    if (!sock_inc_used(ret)) {
-      return NULL;
-    }
-  }
-  return ret;
+	struct lwip_sock *ret = tryget_socket_unconn_nouse(fd);
+	if (ret != NULL)
+	{
+		if (!sock_inc_used(ret))
+		{
+			return NULL;
+		}
+	}
+	return ret;
 }
 
 /* Like tryget_socket_unconn(), but called under SYS_ARCH_PROTECT lock. */
 static struct lwip_sock *
 tryget_socket_unconn_locked(int fd)
 {
-  struct lwip_sock *ret = tryget_socket_unconn_nouse(fd);
-  if (ret != NULL) {
-    if (!sock_inc_used_locked(ret)) {
-      return NULL;
-    }
-  }
-  return ret;
+	struct lwip_sock *ret = tryget_socket_unconn_nouse(fd);
+	if (ret != NULL)
+	{
+		if (!sock_inc_used_locked(ret))
+		{
+			return NULL;
+		}
+	}
+	return ret;
 }
 
 /**
@@ -465,14 +533,16 @@ tryget_socket_unconn_locked(int fd)
 static struct lwip_sock *
 tryget_socket(int fd)
 {
-  struct lwip_sock *sock = tryget_socket_unconn(fd);
-  if (sock != NULL) {
-    if (sock->conn) {
-      return sock;
-    }
-    done_socket(sock);
-  }
-  return NULL;
+	struct lwip_sock *sock = tryget_socket_unconn(fd);
+	if (sock != NULL)
+	{
+		if (sock->conn)
+		{
+			return sock;
+		}
+		done_socket(sock);
+	}
+	return NULL;
 }
 
 /**
@@ -484,15 +554,17 @@ tryget_socket(int fd)
 static struct lwip_sock *
 get_socket(int fd)
 {
-  struct lwip_sock *sock = tryget_socket(fd);
-  if (!sock) {
-    if ((fd < LWIP_SOCKET_OFFSET) || (fd >= (LWIP_SOCKET_OFFSET + NUM_SOCKETS))) {
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", fd));
-    }
-    set_errno(EBADF);
-    return NULL;
-  }
-  return sock;
+	struct lwip_sock *sock = tryget_socket(fd);
+	if (!sock)
+	{
+		if ((fd < LWIP_SOCKET_OFFSET) || (fd >= (LWIP_SOCKET_OFFSET + NUM_SOCKETS)))
+		{
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", fd));
+		}
+		set_errno(EBADF);
+		return NULL;
+	}
+	return sock;
 }
 
 /**
@@ -506,42 +578,45 @@ get_socket(int fd)
 static int
 alloc_socket(struct netconn *newconn, int accepted)
 {
-  int i;
-  SYS_ARCH_DECL_PROTECT(lev);
-  LWIP_UNUSED_ARG(accepted);
-
-  /* allocate a new socket identifier */
-  for (i = 0; i < NUM_SOCKETS; ++i) {
-    /* Protect socket array */
-    SYS_ARCH_PROTECT(lev);
-    if (!sockets[i].conn) {
+	int i;
+	SYS_ARCH_DECL_PROTECT(lev);
+	LWIP_UNUSED_ARG(accepted);
+
+	/* allocate a new socket identifier */
+	for (i = 0; i < NUM_SOCKETS; ++i)
+	{
+		/* Protect socket array */
+		SYS_ARCH_PROTECT(lev);
+		if (!sockets[i].conn)
+		{
 #if LWIP_NETCONN_FULLDUPLEX
-      if (sockets[i].fd_used) {
-        SYS_ARCH_UNPROTECT(lev);
-        continue;
-      }
-      sockets[i].fd_used    = 1;
-      sockets[i].fd_free_pending = 0;
+			if (sockets[i].fd_used)
+			{
+				SYS_ARCH_UNPROTECT(lev);
+				continue;
+			}
+			sockets[i].fd_used = 1;
+			sockets[i].fd_free_pending = 0;
 #endif
-      sockets[i].conn       = newconn;
-      /* The socket is not yet known to anyone, so no need to protect
-         after having marked it as used. */
-      SYS_ARCH_UNPROTECT(lev);
-      sockets[i].lastdata.pbuf = NULL;
+			sockets[i].conn = newconn;
+			/* The socket is not yet known to anyone, so no need to protect
+			   after having marked it as used. */
+			SYS_ARCH_UNPROTECT(lev);
+			sockets[i].lastdata.pbuf = NULL;
 #if LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL
-      LWIP_ASSERT("sockets[i].select_waiting == 0", sockets[i].select_waiting == 0);
-      sockets[i].rcvevent   = 0;
-      /* TCP sendbuf is empty, but the socket is not yet writable until connected
-       * (unless it has been created by accept()). */
-      sockets[i].sendevent  = (NETCONNTYPE_GROUP(newconn->type) == NETCONN_TCP ? (accepted != 0) : 1);
-      sockets[i].errevent   = 0;
-      sockets[i].sock_data  = NULL;
+			LWIP_ASSERT("sockets[i].select_waiting == 0", sockets[i].select_waiting == 0);
+			sockets[i].rcvevent = 0;
+			/* TCP sendbuf is empty, but the socket is not yet writable until connected
+			 * (unless it has been created by accept()). */
+			sockets[i].sendevent = (NETCONNTYPE_GROUP(newconn->type) == NETCONN_TCP ? (accepted != 0) : 1);
+			sockets[i].errevent = 0;
+			sockets[i].sock_data = NULL;
 #endif /* LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL */
-      return i + LWIP_SOCKET_OFFSET;
-    }
-    SYS_ARCH_UNPROTECT(lev);
-  }
-  return -1;
+			return i + LWIP_SOCKET_OFFSET;
+		}
+		SYS_ARCH_UNPROTECT(lev);
+	}
+	return -1;
 }
 
 /** Free a socket (under lock)
@@ -553,24 +628,25 @@ alloc_socket(struct netconn *newconn, int accepted)
  */
 static int
 free_socket_locked(struct lwip_sock *sock, int is_tcp, struct netconn **conn,
-                   union lwip_sock_lastdata *lastdata)
+				   union lwip_sock_lastdata *lastdata)
 {
 #if LWIP_NETCONN_FULLDUPLEX
-  LWIP_ASSERT("sock->fd_used > 0", sock->fd_used > 0);
-  sock->fd_used--;
-  if (sock->fd_used > 0) {
-    sock->fd_free_pending = LWIP_SOCK_FD_FREE_FREE | (is_tcp ? LWIP_SOCK_FD_FREE_TCP : 0);
-    return 0;
-  }
-#else /* LWIP_NETCONN_FULLDUPLEX */
-  LWIP_UNUSED_ARG(is_tcp);
+	LWIP_ASSERT("sock->fd_used > 0", sock->fd_used > 0);
+	sock->fd_used--;
+	if (sock->fd_used > 0)
+	{
+		sock->fd_free_pending = LWIP_SOCK_FD_FREE_FREE | (is_tcp ? LWIP_SOCK_FD_FREE_TCP : 0);
+		return 0;
+	}
+#else  /* LWIP_NETCONN_FULLDUPLEX */
+	LWIP_UNUSED_ARG(is_tcp);
 #endif /* LWIP_NETCONN_FULLDUPLEX */
 
-  *lastdata = sock->lastdata;
-  sock->lastdata.pbuf = NULL;
-  *conn = sock->conn;
-  sock->conn = NULL;
-  return 1;
+	*lastdata = sock->lastdata;
+	sock->lastdata.pbuf = NULL;
+	*conn = sock->conn;
+	sock->conn = NULL;
+	return 1;
 }
 
 /** Free a socket's leftover members.
@@ -578,17 +654,22 @@ free_socket_locked(struct lwip_sock *sock, int is_tcp, struct netconn **conn,
 static void
 free_socket_free_elements(int is_tcp, struct netconn *conn, union lwip_sock_lastdata *lastdata)
 {
-  if (lastdata->pbuf != NULL) {
-    if (is_tcp) {
-      pbuf_free(lastdata->pbuf);
-    } else {
-      netbuf_delete(lastdata->netbuf);
-    }
-  }
-  if (conn != NULL) {
-    /* netconn_prepare_delete() has already been called, here we only free the conn */
-    netconn_delete(conn);
-  }
+	if (lastdata->pbuf != NULL)
+	{
+		if (is_tcp)
+		{
+			pbuf_free(lastdata->pbuf);
+		}
+		else
+		{
+			netbuf_delete(lastdata->netbuf);
+		}
+	}
+	if (conn != NULL)
+	{
+		/* netconn_prepare_delete() has already been called, here we only free the conn */
+		netconn_delete(conn);
+	}
 }
 
 /** Free a socket. The socket's netconn must have been
@@ -600,21 +681,22 @@ free_socket_free_elements(int is_tcp, struct netconn *conn, union lwip_sock_last
 static void
 free_socket(struct lwip_sock *sock, int is_tcp)
 {
-  int freed;
-  struct netconn *conn;
-  union lwip_sock_lastdata lastdata;
-  SYS_ARCH_DECL_PROTECT(lev);
-
-  /* Protect socket array */
-  SYS_ARCH_PROTECT(lev);
-
-  freed = free_socket_locked(sock, is_tcp, &conn, &lastdata);
-  SYS_ARCH_UNPROTECT(lev);
-  /* don't use 'sock' after this line, as another task might have allocated it */
-
-  if (freed) {
-    free_socket_free_elements(is_tcp, conn, &lastdata);
-  }
+	int freed;
+	struct netconn *conn;
+	union lwip_sock_lastdata lastdata;
+	SYS_ARCH_DECL_PROTECT(lev);
+
+	/* Protect socket array */
+	SYS_ARCH_PROTECT(lev);
+
+	freed = free_socket_locked(sock, is_tcp, &conn, &lastdata);
+	SYS_ARCH_UNPROTECT(lev);
+	/* don't use 'sock' after this line, as another task might have allocated it */
+
+	if (freed)
+	{
+		free_socket_free_elements(is_tcp, conn, &lastdata);
+	}
 }
 
 /* Below this, the well-known socket functions are implemented.
@@ -623,253 +705,279 @@ free_socket(struct lwip_sock *sock, int is_tcp)
  * Exceptions are documented!
  */
 
-int
-lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
+int lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
 {
-  struct lwip_sock *sock, *nsock;
-  struct netconn *newconn;
-  ip_addr_t naddr;
-  u16_t port = 0;
-  int newsock;
-  err_t err;
-  int recvevent;
-  SYS_ARCH_DECL_PROTECT(lev);
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
-  sock = get_socket(s);
-  if (!sock) {
-    return -1;
-  }
-
-  /* wait for a new connection */
-  err = netconn_accept(sock->conn, &newconn);
-  if (err != ERR_OK) {
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
-    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
-      sock_set_errno(sock, EOPNOTSUPP);
-    } else if (err == ERR_CLSD) {
-      sock_set_errno(sock, EINVAL);
-    } else {
-      sock_set_errno(sock, err_to_errno(err));
-    }
-    done_socket(sock);
-    return -1;
-  }
-  LWIP_ASSERT("newconn != NULL", newconn != NULL);
-
-  newsock = alloc_socket(newconn, 1);
-  if (newsock == -1) {
-    netconn_delete(newconn);
-    sock_set_errno(sock, ENFILE);
-    done_socket(sock);
-    return -1;
-  }
-  LWIP_ASSERT("invalid socket index", (newsock >= LWIP_SOCKET_OFFSET) && (newsock < NUM_SOCKETS + LWIP_SOCKET_OFFSET));
-  nsock = &sockets[newsock - LWIP_SOCKET_OFFSET];
-
-  /* See event_callback: If data comes in right away after an accept, even
-   * though the server task might not have created a new socket yet.
-   * In that case, newconn->socket is counted down (newconn->socket--),
-   * so nsock->rcvevent is >= 1 here!
-   */
-  SYS_ARCH_PROTECT(lev);
-  recvevent = (s16_t)(-1 - newconn->socket);
-  newconn->socket = newsock;
-  SYS_ARCH_UNPROTECT(lev);
-
-  if (newconn->callback) {
-    LOCK_TCPIP_CORE();
-    while (recvevent > 0) {
-      recvevent--;
-      newconn->callback(newconn, NETCONN_EVT_RCVPLUS, 0);
-    }
-    UNLOCK_TCPIP_CORE();
-  }
-
-  /* Note that POSIX only requires us to check addr is non-NULL. addrlen must
-   * not be NULL if addr is valid.
-   */
-  if ((addr != NULL) && (addrlen != NULL)) {
-    union sockaddr_aligned tempaddr;
-    /* get the IP address and port of the remote host */
-    err = netconn_peer(newconn, &naddr, &port);
-    if (err != ERR_OK) {
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
-      free_socket(nsock, 1);
-      sock_set_errno(sock, err_to_errno(err));
-      done_socket(sock);
-      return -1;
-    }
-
-    IPADDR_PORT_TO_SOCKADDR(&tempaddr, &naddr, port);
-    MEMCPY(addr, &tempaddr, *addrlen);
-
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
-    ip_addr_debug_print_val(SOCKETS_DEBUG, naddr);
-    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));
-  } else {
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d", s, newsock));
-  }
-
-  sock_set_errno(sock, 0);
-  done_socket(sock);
-  done_socket(nsock);
-  return newsock;
+	struct lwip_sock *sock, *nsock;
+	struct netconn *newconn;
+	ip_addr_t naddr;
+	u16_t port = 0;
+	int newsock;
+	err_t err;
+	int recvevent;
+	SYS_ARCH_DECL_PROTECT(lev);
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
+	sock = get_socket(s);
+	if (!sock)
+	{
+		return -1;
+	}
+
+	/* wait for a new connection */
+	err = netconn_accept(sock->conn, &newconn);
+	if (err != ERR_OK)
+	{
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
+		if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP)
+		{
+			sock_set_errno(sock, EOPNOTSUPP);
+		}
+		else if (err == ERR_CLSD)
+		{
+			sock_set_errno(sock, EINVAL);
+		}
+		else
+		{
+			sock_set_errno(sock, err_to_errno(err));
+		}
+		done_socket(sock);
+		return -1;
+	}
+	LWIP_ASSERT("newconn != NULL", newconn != NULL);
+
+	newsock = alloc_socket(newconn, 1);
+	if (newsock == -1)
+	{
+		netconn_delete(newconn);
+		sock_set_errno(sock, ENFILE);
+		done_socket(sock);
+		return -1;
+	}
+	LWIP_ASSERT("invalid socket index", (newsock >= LWIP_SOCKET_OFFSET) && (newsock < NUM_SOCKETS + LWIP_SOCKET_OFFSET));
+	nsock = &sockets[newsock - LWIP_SOCKET_OFFSET];
+
+	/* See event_callback: If data comes in right away after an accept, even
+	 * though the server task might not have created a new socket yet.
+	 * In that case, newconn->socket is counted down (newconn->socket--),
+	 * so nsock->rcvevent is >= 1 here!
+	 */
+	SYS_ARCH_PROTECT(lev);
+	recvevent = (s16_t)(-1 - newconn->socket);
+	newconn->socket = newsock;
+	SYS_ARCH_UNPROTECT(lev);
+
+	if (newconn->callback)
+	{
+		LOCK_TCPIP_CORE();
+		while (recvevent > 0)
+		{
+			recvevent--;
+			newconn->callback(newconn, NETCONN_EVT_RCVPLUS, 0);
+		}
+		UNLOCK_TCPIP_CORE();
+	}
+
+	/* Note that POSIX only requires us to check addr is non-NULL. addrlen must
+	 * not be NULL if addr is valid.
+	 */
+	if ((addr != NULL) && (addrlen != NULL))
+	{
+		union sockaddr_aligned tempaddr;
+		/* get the IP address and port of the remote host */
+		err = netconn_peer(newconn, &naddr, &port);
+		if (err != ERR_OK)
+		{
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
+			free_socket(nsock, 1);
+			sock_set_errno(sock, err_to_errno(err));
+			done_socket(sock);
+			return -1;
+		}
+
+		IPADDR_PORT_TO_SOCKADDR(&tempaddr, &naddr, port);
+		MEMCPY(addr, &tempaddr, *addrlen);
+
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
+		ip_addr_debug_print_val(SOCKETS_DEBUG, naddr);
+		LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%" U16_F "\n", port));
+	}
+	else
+	{
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d", s, newsock));
+	}
+
+	sock_set_errno(sock, 0);
+	done_socket(sock);
+	done_socket(nsock);
+	return newsock;
 }
 
-int
-lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
+int lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
 {
-  struct lwip_sock *sock;
-  ip_addr_t local_addr;
-  u16_t local_port;
-  err_t err;
-
-  sock = get_socket(s);
-  if (!sock) {
-    return -1;
-  }
-
-  if (!SOCK_ADDR_TYPE_MATCH(name, sock)) {
-    /* sockaddr does not match socket type (IPv4/IPv6) */
-    sock_set_errno(sock, err_to_errno(ERR_VAL));
-    done_socket(sock);
-    return -1;
-  }
-
-  /* check size, family and alignment of 'name' */
-  LWIP_ERROR("lwip_bind: invalid address", (IS_SOCK_ADDR_LEN_VALID(namelen) &&
-             IS_SOCK_ADDR_TYPE_VALID(name) && IS_SOCK_ADDR_ALIGNED(name)),
-             sock_set_errno(sock, err_to_errno(ERR_ARG)); done_socket(sock); return -1;);
-  LWIP_UNUSED_ARG(namelen);
-
-  SOCKADDR_TO_IPADDR_PORT(name, &local_addr, local_port);
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
-  ip_addr_debug_print_val(SOCKETS_DEBUG, local_addr);
-  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", local_port));
+	struct lwip_sock *sock;
+	ip_addr_t local_addr;
+	u16_t local_port;
+	err_t err;
+
+	sock = get_socket(s);
+	if (!sock)
+	{
+		return -1;
+	}
+
+	if (!SOCK_ADDR_TYPE_MATCH(name, sock))
+	{
+		/* sockaddr does not match socket type (IPv4/IPv6) */
+		sock_set_errno(sock, err_to_errno(ERR_VAL));
+		done_socket(sock);
+		return -1;
+	}
+
+	/* check size, family and alignment of 'name' */
+	LWIP_ERROR("lwip_bind: invalid address", (IS_SOCK_ADDR_LEN_VALID(namelen) && IS_SOCK_ADDR_TYPE_VALID(name) && IS_SOCK_ADDR_ALIGNED(name)),
+			   sock_set_errno(sock, err_to_errno(ERR_ARG));
+			   done_socket(sock); return -1;);
+	LWIP_UNUSED_ARG(namelen);
+
+	SOCKADDR_TO_IPADDR_PORT(name, &local_addr, local_port);
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
+	ip_addr_debug_print_val(SOCKETS_DEBUG, local_addr);
+	LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%" U16_F ")\n", local_port));
 
 #if LWIP_IPV4 && LWIP_IPV6
-  /* Dual-stack: Unmap IPv4 mapped IPv6 addresses */
-  if (IP_IS_V6_VAL(local_addr) && ip6_addr_isipv4mappedipv6(ip_2_ip6(&local_addr))) {
-    unmap_ipv4_mapped_ipv6(ip_2_ip4(&local_addr), ip_2_ip6(&local_addr));
-    IP_SET_TYPE_VAL(local_addr, IPADDR_TYPE_V4);
-  }
+	/* Dual-stack: Unmap IPv4 mapped IPv6 addresses */
+	if (IP_IS_V6_VAL(local_addr) && ip6_addr_isipv4mappedipv6(ip_2_ip6(&local_addr)))
+	{
+		unmap_ipv4_mapped_ipv6(ip_2_ip4(&local_addr), ip_2_ip6(&local_addr));
+		IP_SET_TYPE_VAL(local_addr, IPADDR_TYPE_V4);
+	}
 #endif /* LWIP_IPV4 && LWIP_IPV6 */
 
-  err = netconn_bind(sock->conn, &local_addr, local_port);
+	err = netconn_bind(sock->conn, &local_addr, local_port);
 
-  if (err != ERR_OK) {
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
-    sock_set_errno(sock, err_to_errno(err));
-    done_socket(sock);
-    return -1;
-  }
+	if (err != ERR_OK)
+	{
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
+		sock_set_errno(sock, err_to_errno(err));
+		done_socket(sock);
+		return -1;
+	}
 
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
-  sock_set_errno(sock, 0);
-  done_socket(sock);
-  return 0;
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
+	sock_set_errno(sock, 0);
+	done_socket(sock);
+	return 0;
 }
 
-int
-lwip_close(int s)
+int lwip_close(int s)
 {
-  struct lwip_sock *sock;
-  int is_tcp = 0;
-  err_t err;
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));
-
-  sock = get_socket(s);
-  if (!sock) {
-    return -1;
-  }
-
-  if (sock->conn != NULL) {
-    is_tcp = NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP;
-  } else {
-    LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata.pbuf == NULL);
-  }
+	struct lwip_sock *sock;
+	int is_tcp = 0;
+	err_t err;
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));
+
+	sock = get_socket(s);
+	if (!sock)
+	{
+		return -1;
+	}
+
+	if (sock->conn != NULL)
+	{
+		is_tcp = NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP;
+	}
+	else
+	{
+		LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata.pbuf == NULL);
+	}
 
 #if LWIP_IGMP
-  /* drop all possibly joined IGMP memberships */
-  lwip_socket_drop_registered_memberships(s);
+	/* drop all possibly joined IGMP memberships */
+	lwip_socket_drop_registered_memberships(s);
 #endif /* LWIP_IGMP */
 #if LWIP_IPV6_MLD
-  /* drop all possibly joined MLD6 memberships */
-  lwip_socket_drop_registered_mld6_memberships(s);
+	/* drop all possibly joined MLD6 memberships */
+	lwip_socket_drop_registered_mld6_memberships(s);
 #endif /* LWIP_IPV6_MLD */
 
-  err = netconn_prepare_delete(sock->conn);
-  if (err != ERR_OK) {
-    sock_set_errno(sock, err_to_errno(err));
-    done_socket(sock);
-    return -1;
-  }
-
-  free_socket(sock, is_tcp);
-  set_errno(0);
-  return 0;
+	err = netconn_prepare_delete(sock->conn);
+	if (err != ERR_OK)
+	{
+		sock_set_errno(sock, err_to_errno(err));
+		done_socket(sock);
+		return -1;
+	}
+
+	free_socket(sock, is_tcp);
+	set_errno(0);
+	return 0;
 }
 
-int
-lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
+int lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
 {
-  struct lwip_sock *sock;
-  err_t err;
-
-  sock = get_socket(s);
-  if (!sock) {
-    return -1;
-  }
-
-  if (!SOCK_ADDR_TYPE_MATCH_OR_UNSPEC(name, sock)) {
-    /* sockaddr does not match socket type (IPv4/IPv6) */
-    sock_set_errno(sock, err_to_errno(ERR_VAL));
-    done_socket(sock);
-    return -1;
-  }
-
-  LWIP_UNUSED_ARG(namelen);
-  if (name->sa_family == AF_UNSPEC) {
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
-    err = netconn_disconnect(sock->conn);
-  } else {
-    ip_addr_t remote_addr;
-    u16_t remote_port;
-
-    /* check size, family and alignment of 'name' */
-    LWIP_ERROR("lwip_connect: invalid address", IS_SOCK_ADDR_LEN_VALID(namelen) &&
-               IS_SOCK_ADDR_TYPE_VALID_OR_UNSPEC(name) && IS_SOCK_ADDR_ALIGNED(name),
-               sock_set_errno(sock, err_to_errno(ERR_ARG)); done_socket(sock); return -1;);
-
-    SOCKADDR_TO_IPADDR_PORT(name, &remote_addr, remote_port);
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
-    ip_addr_debug_print_val(SOCKETS_DEBUG, remote_addr);
-    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", remote_port));
+	struct lwip_sock *sock;
+	err_t err;
+
+	sock = get_socket(s);
+	if (!sock)
+	{
+		return -1;
+	}
+
+	if (!SOCK_ADDR_TYPE_MATCH_OR_UNSPEC(name, sock))
+	{
+		/* sockaddr does not match socket type (IPv4/IPv6) */
+		sock_set_errno(sock, err_to_errno(ERR_VAL));
+		done_socket(sock);
+		return -1;
+	}
+
+	LWIP_UNUSED_ARG(namelen);
+	if (name->sa_family == AF_UNSPEC)
+	{
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
+		err = netconn_disconnect(sock->conn);
+	}
+	else
+	{
+		ip_addr_t remote_addr;
+		u16_t remote_port;
+
+		/* check size, family and alignment of 'name' */
+		LWIP_ERROR("lwip_connect: invalid address", IS_SOCK_ADDR_LEN_VALID(namelen) && IS_SOCK_ADDR_TYPE_VALID_OR_UNSPEC(name) && IS_SOCK_ADDR_ALIGNED(name),
+				   sock_set_errno(sock, err_to_errno(ERR_ARG));
+				   done_socket(sock); return -1;);
+
+		SOCKADDR_TO_IPADDR_PORT(name, &remote_addr, remote_port);
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
+		ip_addr_debug_print_val(SOCKETS_DEBUG, remote_addr);
+		LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%" U16_F ")\n", remote_port));
 
 #if LWIP_IPV4 && LWIP_IPV6
-    /* Dual-stack: Unmap IPv4 mapped IPv6 addresses */
-    if (IP_IS_V6_VAL(remote_addr) && ip6_addr_isipv4mappedipv6(ip_2_ip6(&remote_addr))) {
-      unmap_ipv4_mapped_ipv6(ip_2_ip4(&remote_addr), ip_2_ip6(&remote_addr));
-      IP_SET_TYPE_VAL(remote_addr, IPADDR_TYPE_V4);
-    }
+		/* Dual-stack: Unmap IPv4 mapped IPv6 addresses */
+		if (IP_IS_V6_VAL(remote_addr) && ip6_addr_isipv4mappedipv6(ip_2_ip6(&remote_addr)))
+		{
+			unmap_ipv4_mapped_ipv6(ip_2_ip4(&remote_addr), ip_2_ip6(&remote_addr));
+			IP_SET_TYPE_VAL(remote_addr, IPADDR_TYPE_V4);
+		}
 #endif /* LWIP_IPV4 && LWIP_IPV6 */
 
-    err = netconn_connect(sock->conn, &remote_addr, remote_port);
-  }
-
-  if (err != ERR_OK) {
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
-    sock_set_errno(sock, err_to_errno(err));
-    done_socket(sock);
-    return -1;
-  }
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
-  sock_set_errno(sock, 0);
-  done_socket(sock);
-  return 0;
+		err = netconn_connect(sock->conn, &remote_addr, remote_port);
+	}
+
+	if (err != ERR_OK)
+	{
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
+		sock_set_errno(sock, err_to_errno(err));
+		done_socket(sock);
+		return -1;
+	}
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
+	sock_set_errno(sock, 0);
+	done_socket(sock);
+	return 0;
 }
 
 /**
@@ -880,38 +988,42 @@ lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
  * @param backlog (ATTENTION: needs TCP_LISTEN_BACKLOG=1)
  * @return 0 on success, non-zero on failure
  */
-int
-lwip_listen(int s, int backlog)
+int lwip_listen(int s, int backlog)
 {
-  struct lwip_sock *sock;
-  err_t err;
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));
-
-  sock = get_socket(s);
-  if (!sock) {
-    return -1;
-  }
-
-  /* limit the "backlog" parameter to fit in an u8_t */
-  backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);
-
-  err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
-
-  if (err != ERR_OK) {
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
-    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
-      sock_set_errno(sock, EOPNOTSUPP);
-    } else {
-      sock_set_errno(sock, err_to_errno(err));
-    }
-    done_socket(sock);
-    return -1;
-  }
-
-  sock_set_errno(sock, 0);
-  done_socket(sock);
-  return 0;
+	struct lwip_sock *sock;
+	err_t err;
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));
+
+	sock = get_socket(s);
+	if (!sock)
+	{
+		return -1;
+	}
+
+	/* limit the "backlog" parameter to fit in an u8_t */
+	backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);
+
+	err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
+
+	if (err != ERR_OK)
+	{
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
+		if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP)
+		{
+			sock_set_errno(sock, EOPNOTSUPP);
+		}
+		else
+		{
+			sock_set_errno(sock, err_to_errno(err));
+		}
+		done_socket(sock);
+		return -1;
+	}
+
+	sock_set_errno(sock, 0);
+	done_socket(sock);
+	return 0;
 }
 
 #if LWIP_TCP
@@ -922,130 +1034,150 @@ lwip_listen(int s, int backlog)
 static ssize_t
 lwip_recv_tcp(struct lwip_sock *sock, void *mem, size_t len, int flags)
 {
-  u8_t apiflags = NETCONN_NOAUTORCVD;
-  ssize_t recvd = 0;
-  ssize_t recv_left = (len <= SSIZE_MAX) ? (ssize_t)len : SSIZE_MAX;
-
-  LWIP_ASSERT("no socket given", sock != NULL);
-  LWIP_ASSERT("this should be checked internally", NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP);
-
-  if (flags & MSG_DONTWAIT) {
-    apiflags |= NETCONN_DONTBLOCK;
-  }
-
-  do {
-    struct pbuf *p;
-    err_t err;
-    u16_t copylen;
-
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: top while sock->lastdata=%p\n", (void *)sock->lastdata.pbuf));
-    /* Check if there is data left from the last recv operation. */
-    if (sock->lastdata.pbuf) {
-      p = sock->lastdata.pbuf;
-    } else {
-      /* No data was left from the previous operation, so we try to get
-         some from the network. */
-      err = netconn_recv_tcp_pbuf_flags(sock->conn, &p, apiflags);
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: netconn_recv err=%d, pbuf=%p\n",
-                                  err, (void *)p));
-
-      if (err != ERR_OK) {
-        if (recvd > 0) {
-          /* already received data, return that (this trusts in getting the same error from
-             netconn layer again next time netconn_recv is called) */
-          goto lwip_recv_tcp_done;
-        }
-        /* We should really do some error checking here. */
-        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: p == NULL, error is \"%s\"!\n",
-                                    lwip_strerr(err)));
-        sock_set_errno(sock, err_to_errno(err));
-        if (err == ERR_CLSD) {
-          return 0;
-        } else {
-          return -1;
-        }
-      }
-      LWIP_ASSERT("p != NULL", p != NULL);
-      sock->lastdata.pbuf = p;
-    }
-
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: buflen=%"U16_F" recv_left=%d off=%d\n",
-                                p->tot_len, (int)recv_left, (int)recvd));
-
-    if (recv_left > p->tot_len) {
-      copylen = p->tot_len;
-    } else {
-      copylen = (u16_t)recv_left;
-    }
-    if (recvd + copylen < recvd) {
-      /* overflow */
-      copylen = (u16_t)(SSIZE_MAX - recvd);
-    }
-
-    /* copy the contents of the received buffer into
-    the supplied memory pointer mem */
-    pbuf_copy_partial(p, (u8_t *)mem + recvd, copylen, 0);
-
-    recvd += copylen;
-
-    /* TCP combines multiple pbufs for one recv */
-    LWIP_ASSERT("invalid copylen, len would underflow", recv_left >= copylen);
-    recv_left -= copylen;
-
-    /* Unless we peek the incoming message... */
-    if ((flags & MSG_PEEK) == 0) {
-      /* ... check if there is data left in the pbuf */
-      LWIP_ASSERT("invalid copylen", p->tot_len >= copylen);
-      if (p->tot_len - copylen > 0) {
-        /* If so, it should be saved in the sock structure for the next recv call.
-           We store the pbuf but hide/free the consumed data: */
-        sock->lastdata.pbuf = pbuf_free_header(p, copylen);
-        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: lastdata now pbuf=%p\n", (void *)sock->lastdata.pbuf));
-      } else {
-        sock->lastdata.pbuf = NULL;
-        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: deleting pbuf=%p\n", (void *)p));
-        pbuf_free(p);
-      }
-    }
-    /* once we have some data to return, only add more if we don't need to wait */
-    apiflags |= NETCONN_DONTBLOCK | NETCONN_NOFIN;
-    /* @todo: do we need to support peeking more than one pbuf? */
-  } while ((recv_left > 0) && !(flags & MSG_PEEK));
+	u8_t apiflags = NETCONN_NOAUTORCVD;
+	ssize_t recvd = 0;
+	ssize_t recv_left = (len <= SSIZE_MAX) ? (ssize_t)len : SSIZE_MAX;
+
+	LWIP_ASSERT("no socket given", sock != NULL);
+	LWIP_ASSERT("this should be checked internally", NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP);
+
+	if (flags & MSG_DONTWAIT)
+	{
+		apiflags |= NETCONN_DONTBLOCK;
+	}
+
+	do
+	{
+		struct pbuf *p;
+		err_t err;
+		u16_t copylen;
+
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: top while sock->lastdata=%p\n", (void *)sock->lastdata.pbuf));
+		/* Check if there is data left from the last recv operation. */
+		if (sock->lastdata.pbuf)
+		{
+			p = sock->lastdata.pbuf;
+		}
+		else
+		{
+			/* No data was left from the previous operation, so we try to get
+			   some from the network. */
+			err = netconn_recv_tcp_pbuf_flags(sock->conn, &p, apiflags);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: netconn_recv err=%d, pbuf=%p\n",
+										err, (void *)p));
+
+			if (err != ERR_OK)
+			{
+				if (recvd > 0)
+				{
+					/* already received data, return that (this trusts in getting the same error from
+					   netconn layer again next time netconn_recv is called) */
+					goto lwip_recv_tcp_done;
+				}
+				/* We should really do some error checking here. */
+				LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: p == NULL, error is \"%s\"!\n",
+											lwip_strerr(err)));
+				sock_set_errno(sock, err_to_errno(err));
+				if (err == ERR_CLSD)
+				{
+					return 0;
+				}
+				else
+				{
+					return -1;
+				}
+			}
+			LWIP_ASSERT("p != NULL", p != NULL);
+			sock->lastdata.pbuf = p;
+		}
+
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: buflen=%" U16_F " recv_left=%d off=%d\n",
+									p->tot_len, (int)recv_left, (int)recvd));
+
+		if (recv_left > p->tot_len)
+		{
+			copylen = p->tot_len;
+		}
+		else
+		{
+			copylen = (u16_t)recv_left;
+		}
+		if (recvd + copylen < recvd)
+		{
+			/* overflow */
+			copylen = (u16_t)(SSIZE_MAX - recvd);
+		}
+
+		/* copy the contents of the received buffer into
+		the supplied memory pointer mem */
+		pbuf_copy_partial(p, (u8_t *)mem + recvd, copylen, 0);
+
+		recvd += copylen;
+
+		/* TCP combines multiple pbufs for one recv */
+		LWIP_ASSERT("invalid copylen, len would underflow", recv_left >= copylen);
+		recv_left -= copylen;
+
+		/* Unless we peek the incoming message... */
+		if ((flags & MSG_PEEK) == 0)
+		{
+			/* ... check if there is data left in the pbuf */
+			LWIP_ASSERT("invalid copylen", p->tot_len >= copylen);
+			if (p->tot_len - copylen > 0)
+			{
+				/* If so, it should be saved in the sock structure for the next recv call.
+				   We store the pbuf but hide/free the consumed data: */
+				sock->lastdata.pbuf = pbuf_free_header(p, copylen);
+				LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: lastdata now pbuf=%p\n", (void *)sock->lastdata.pbuf));
+			}
+			else
+			{
+				sock->lastdata.pbuf = NULL;
+				LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recv_tcp: deleting pbuf=%p\n", (void *)p));
+				pbuf_free(p);
+			}
+		}
+		/* once we have some data to return, only add more if we don't need to wait */
+		apiflags |= NETCONN_DONTBLOCK | NETCONN_NOFIN;
+		/* @todo: do we need to support peeking more than one pbuf? */
+	} while ((recv_left > 0) && !(flags & MSG_PEEK));
 lwip_recv_tcp_done:
-  if ((recvd > 0) && !(flags & MSG_PEEK)) {
-    /* ensure window update after copying all data */
-    netconn_tcp_recvd(sock->conn, (size_t)recvd);
-  }
-  sock_set_errno(sock, 0);
-  return recvd;
+	if ((recvd > 0) && !(flags & MSG_PEEK))
+	{
+		/* ensure window update after copying all data */
+		netconn_tcp_recvd(sock->conn, (size_t)recvd);
+	}
+	sock_set_errno(sock, 0);
+	return recvd;
 }
 #endif
 
 /* Convert a netbuf's address data to struct sockaddr */
 static int
 lwip_sock_make_addr(struct netconn *conn, ip_addr_t *fromaddr, u16_t port,
-                    struct sockaddr *from, socklen_t *fromlen)
+					struct sockaddr *from, socklen_t *fromlen)
 {
-  int truncated = 0;
-  union sockaddr_aligned saddr;
+	int truncated = 0;
+	union sockaddr_aligned saddr;
 
-  LWIP_UNUSED_ARG(conn);
+	LWIP_UNUSED_ARG(conn);
 
-  LWIP_ASSERT("fromaddr != NULL", fromaddr != NULL);
-  LWIP_ASSERT("from != NULL", from != NULL);
-  LWIP_ASSERT("fromlen != NULL", fromlen != NULL);
+	LWIP_ASSERT("fromaddr != NULL", fromaddr != NULL);
+	LWIP_ASSERT("from != NULL", from != NULL);
+	LWIP_ASSERT("fromlen != NULL", fromlen != NULL);
 
 #if LWIP_IPV4 && LWIP_IPV6
-  /* Dual-stack: Map IPv4 addresses to IPv4 mapped IPv6 */
-  if (NETCONNTYPE_ISIPV6(netconn_type(conn)) && IP_IS_V4(fromaddr)) {
-    ip4_2_ipv4_mapped_ipv6(ip_2_ip6(fromaddr), ip_2_ip4(fromaddr));
-    IP_SET_TYPE(fromaddr, IPADDR_TYPE_V6);
-  }
+	/* Dual-stack: Map IPv4 addresses to IPv4 mapped IPv6 */
+	if (NETCONNTYPE_ISIPV6(netconn_type(conn)) && IP_IS_V4(fromaddr))
+	{
+		ip4_2_ipv4_mapped_ipv6(ip_2_ip6(fromaddr), ip_2_ip4(fromaddr));
+		IP_SET_TYPE(fromaddr, IPADDR_TYPE_V6);
+	}
 #endif /* LWIP_IPV4 && LWIP_IPV6 */
 
-  IPADDR_PORT_TO_SOCKADDR(&saddr, fromaddr, port);
-  MEMCPY(from, &saddr, *fromlen);
-  return truncated;
+	IPADDR_PORT_TO_SOCKADDR(&saddr, fromaddr, port);
+	MEMCPY(from, &saddr, *fromlen);
+	return truncated;
 }
 
 #if LWIP_TCP
@@ -1053,29 +1185,31 @@ lwip_sock_make_addr(struct netconn *conn, ip_addr_t *fromaddr, u16_t port,
 static int
 lwip_recv_tcp_from(struct lwip_sock *sock, struct sockaddr *from, socklen_t *fromlen, const char *dbg_fn, int dbg_s, ssize_t dbg_ret)
 {
-  if (sock == NULL) {
-    return 0;
-  }
-  LWIP_UNUSED_ARG(dbg_fn);
-  LWIP_UNUSED_ARG(dbg_s);
-  LWIP_UNUSED_ARG(dbg_ret);
+	if (sock == NULL)
+	{
+		return 0;
+	}
+	LWIP_UNUSED_ARG(dbg_fn);
+	LWIP_UNUSED_ARG(dbg_s);
+	LWIP_UNUSED_ARG(dbg_ret);
 
 #if !SOCKETS_DEBUG
-  if (from && fromlen)
+	if (from && fromlen)
 #endif /* !SOCKETS_DEBUG */
-  {
-    /* get remote addr/port from tcp_pcb */
-    u16_t port;
-    ip_addr_t tmpaddr;
-    netconn_getaddr(sock->conn, &tmpaddr, &port, 0);
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("%s(%d):  addr=", dbg_fn, dbg_s));
-    ip_addr_debug_print_val(SOCKETS_DEBUG, tmpaddr);
-    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F" len=%d\n", port, (int)dbg_ret));
-    if (from && fromlen) {
-      return lwip_sock_make_addr(sock->conn, &tmpaddr, port, from, fromlen);
-    }
-  }
-  return 0;
+	{
+		/* get remote addr/port from tcp_pcb */
+		u16_t port;
+		ip_addr_t tmpaddr;
+		netconn_getaddr(sock->conn, &tmpaddr, &port, 0);
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("%s(%d):  addr=", dbg_fn, dbg_s));
+		ip_addr_debug_print_val(SOCKETS_DEBUG, tmpaddr);
+		LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%" U16_F " len=%d\n", port, (int)dbg_ret));
+		if (from && fromlen)
+		{
+			return lwip_sock_make_addr(sock->conn, &tmpaddr, port, from, fromlen);
+		}
+	}
+	return 0;
 }
 #endif
 
@@ -1085,682 +1219,758 @@ lwip_recv_tcp_from(struct lwip_sock *sock, struct sockaddr *from, socklen_t *fro
 static err_t
 lwip_recvfrom_udp_raw(struct lwip_sock *sock, int flags, struct msghdr *msg, u16_t *datagram_len, int dbg_s)
 {
-  struct netbuf *buf;
-  u8_t apiflags;
-  err_t err;
-  u16_t buflen, copylen, copied;
-  int i;
-
-  LWIP_UNUSED_ARG(dbg_s);
-  LWIP_ERROR("lwip_recvfrom_udp_raw: invalid arguments", (msg->msg_iov != NULL) || (msg->msg_iovlen <= 0), return ERR_ARG;);
-
-  if (flags & MSG_DONTWAIT) {
-    apiflags = NETCONN_DONTBLOCK;
-  } else {
-    apiflags = 0;
-  }
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw[UDP/RAW]: top sock->lastdata=%p\n", (void *)sock->lastdata.netbuf));
-  /* Check if there is data left from the last recv operation. */
-  buf = sock->lastdata.netbuf;
-  if (buf == NULL) {
-    /* No data was left from the previous operation, so we try to get
-        some from the network. */
-    err = netconn_recv_udp_raw_netbuf_flags(sock->conn, &buf, apiflags);
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw[UDP/RAW]: netconn_recv err=%d, netbuf=%p\n",
-                                err, (void *)buf));
-
-    if (err != ERR_OK) {
-      return err;
-    }
-    LWIP_ASSERT("buf != NULL", buf != NULL);
-    sock->lastdata.netbuf = buf;
-  }
-  buflen = buf->p->tot_len;
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw: buflen=%"U16_F"\n", buflen));
-
-  copied = 0;
-  /* copy the pbuf payload into the iovs */
-  for (i = 0; (i < msg->msg_iovlen) && (copied < buflen); i++) {
-    u16_t len_left = (u16_t)(buflen - copied);
-    if (msg->msg_iov[i].iov_len > len_left) {
-      copylen = len_left;
-    } else {
-      copylen = (u16_t)msg->msg_iov[i].iov_len;
-    }
-
-    /* copy the contents of the received buffer into
-        the supplied memory buffer */
-    pbuf_copy_partial(buf->p, (u8_t *)msg->msg_iov[i].iov_base, copylen, copied);
-    copied = (u16_t)(copied + copylen);
-  }
-
-  /* Check to see from where the data was.*/
+	struct netbuf *buf;
+	u8_t apiflags;
+	err_t err;
+	u16_t buflen, copylen, copied;
+	int i;
+
+	LWIP_UNUSED_ARG(dbg_s);
+	LWIP_ERROR("lwip_recvfrom_udp_raw: invalid arguments", (msg->msg_iov != NULL) || (msg->msg_iovlen <= 0), return ERR_ARG;);
+
+	if (flags & MSG_DONTWAIT)
+	{
+		apiflags = NETCONN_DONTBLOCK;
+	}
+	else
+	{
+		apiflags = 0;
+	}
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw[UDP/RAW]: top sock->lastdata=%p\n", (void *)sock->lastdata.netbuf));
+	/* Check if there is data left from the last recv operation. */
+	buf = sock->lastdata.netbuf;
+	if (buf == NULL)
+	{
+		/* No data was left from the previous operation, so we try to get
+			some from the network. */
+		err = netconn_recv_udp_raw_netbuf_flags(sock->conn, &buf, apiflags);
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw[UDP/RAW]: netconn_recv err=%d, netbuf=%p\n",
+									err, (void *)buf));
+
+		if (err != ERR_OK)
+		{
+			return err;
+		}
+		LWIP_ASSERT("buf != NULL", buf != NULL);
+		sock->lastdata.netbuf = buf;
+	}
+	buflen = buf->p->tot_len;
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw: buflen=%" U16_F "\n", buflen));
+
+	copied = 0;
+	/* copy the pbuf payload into the iovs */
+	for (i = 0; (i < msg->msg_iovlen) && (copied < buflen); i++)
+	{
+		u16_t len_left = (u16_t)(buflen - copied);
+		if (msg->msg_iov[i].iov_len > len_left)
+		{
+			copylen = len_left;
+		}
+		else
+		{
+			copylen = (u16_t)msg->msg_iov[i].iov_len;
+		}
+
+		/* copy the contents of the received buffer into
+			the supplied memory buffer */
+		pbuf_copy_partial(buf->p, (u8_t *)msg->msg_iov[i].iov_base, copylen, copied);
+		copied = (u16_t)(copied + copylen);
+	}
+
+	/* Check to see from where the data was.*/
 #if !SOCKETS_DEBUG
-  if (msg->msg_name && msg->msg_namelen)
+	if (msg->msg_name && msg->msg_namelen)
 #endif /* !SOCKETS_DEBUG */
-  {
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw(%d):  addr=", dbg_s));
-    ip_addr_debug_print_val(SOCKETS_DEBUG, *netbuf_fromaddr(buf));
-    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F" len=%d\n", netbuf_fromport(buf), copied));
-    if (msg->msg_name && msg->msg_namelen) {
-      lwip_sock_make_addr(sock->conn, netbuf_fromaddr(buf), netbuf_fromport(buf),
-                          (struct sockaddr *)msg->msg_name, &msg->msg_namelen);
-    }
-  }
-
-  /* Initialize flag output */
-  msg->msg_flags = 0;
-
-  if (msg->msg_control) {
-    u8_t wrote_msg = 0;
+	{
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom_udp_raw(%d):  addr=", dbg_s));
+		ip_addr_debug_print_val(SOCKETS_DEBUG, *netbuf_fromaddr(buf));
+		LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%" U16_F " len=%d\n", netbuf_fromport(buf), copied));
+		if (msg->msg_name && msg->msg_namelen)
+		{
+			lwip_sock_make_addr(sock->conn, netbuf_fromaddr(buf), netbuf_fromport(buf),
+								(struct sockaddr *)msg->msg_name, &msg->msg_namelen);
+		}
+	}
+
+	/* Initialize flag output */
+	msg->msg_flags = 0;
+
+	if (msg->msg_control)
+	{
+		u8_t wrote_msg = 0;
 #if LWIP_NETBUF_RECVINFO
-    /* Check if packet info was recorded */
-    if (buf->flags & NETBUF_FLAG_DESTADDR) {
-      if (IP_IS_V4(&buf->toaddr)) {
+		/* Check if packet info was recorded */
+		if (buf->flags & NETBUF_FLAG_DESTADDR)
+		{
+			if (IP_IS_V4(&buf->toaddr))
+			{
 #if LWIP_IPV4
-        if (msg->msg_controllen >= CMSG_SPACE(sizeof(struct in_pktinfo))) {
-          struct cmsghdr *chdr = CMSG_FIRSTHDR(msg); /* This will always return a header!! */
-          struct in_pktinfo *pkti = (struct in_pktinfo *)CMSG_DATA(chdr);
-          chdr->cmsg_level = IPPROTO_IP;
-          chdr->cmsg_type = IP_PKTINFO;
-          chdr->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));
-          pkti->ipi_ifindex = buf->p->if_idx;
-          inet_addr_from_ip4addr(&pkti->ipi_addr, ip_2_ip4(netbuf_destaddr(buf)));
-          msg->msg_controllen = CMSG_SPACE(sizeof(struct in_pktinfo));
-          wrote_msg = 1;
-        } else {
-          msg->msg_flags |= MSG_CTRUNC;
-        }
+				if (msg->msg_controllen >= CMSG_SPACE(sizeof(struct in_pktinfo)))
+				{
+					struct cmsghdr *chdr = CMSG_FIRSTHDR(msg); /* This will always return a header!! */
+					struct in_pktinfo *pkti = (struct in_pktinfo *)CMSG_DATA(chdr);
+					chdr->cmsg_level = IPPROTO_IP;
+					chdr->cmsg_type = IP_PKTINFO;
+					chdr->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));
+					pkti->ipi_ifindex = buf->p->if_idx;
+					inet_addr_from_ip4addr(&pkti->ipi_addr, ip_2_ip4(netbuf_destaddr(buf)));
+					msg->msg_controllen = CMSG_SPACE(sizeof(struct in_pktinfo));
+					wrote_msg = 1;
+				}
+				else
+				{
+					msg->msg_flags |= MSG_CTRUNC;
+				}
 #endif /* LWIP_IPV4 */
-      }
-    }
+			}
+		}
 #endif /* LWIP_NETBUF_RECVINFO */
 
-    if (!wrote_msg) {
-      msg->msg_controllen = 0;
-    }
-  }
-
-  /* If we don't peek the incoming message: zero lastdata pointer and free the netbuf */
-  if ((flags & MSG_PEEK) == 0) {
-    sock->lastdata.netbuf = NULL;
-    netbuf_delete(buf);
-  }
-  if (datagram_len) {
-    *datagram_len = buflen;
-  }
-  return ERR_OK;
+		if (!wrote_msg)
+		{
+			msg->msg_controllen = 0;
+		}
+	}
+
+	/* If we don't peek the incoming message: zero lastdata pointer and free the netbuf */
+	if ((flags & MSG_PEEK) == 0)
+	{
+		sock->lastdata.netbuf = NULL;
+		netbuf_delete(buf);
+	}
+	if (datagram_len)
+	{
+		*datagram_len = buflen;
+	}
+	return ERR_OK;
 }
 
 ssize_t
 lwip_recvfrom(int s, void *mem, size_t len, int flags,
-              struct sockaddr *from, socklen_t *fromlen)
+			  struct sockaddr *from, socklen_t *fromlen)
 {
-  struct lwip_sock *sock;
-  ssize_t ret;
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %"SZT_F", 0x%x, ..)\n", s, mem, len, flags));
-  sock = get_socket(s);
-  if (!sock) {
-    return -1;
-  }
+	struct lwip_sock *sock;
+	ssize_t ret;
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %" SZT_F ", 0x%x, ..)\n", s, mem, len, flags));
+	sock = get_socket(s);
+	if (!sock)
+	{
+		return -1;
+	}
 #if LWIP_TCP
-  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
-    ret = lwip_recv_tcp(sock, mem, len, flags);
-    lwip_recv_tcp_from(sock, from, fromlen, "lwip_recvfrom", s, ret);
-    done_socket(sock);
-    return ret;
-  } else
+	if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP)
+	{
+		ret = lwip_recv_tcp(sock, mem, len, flags);
+		lwip_recv_tcp_from(sock, from, fromlen, "lwip_recvfrom", s, ret);
+		done_socket(sock);
+		return ret;
+	}
+	else
 #endif
-  {
-    u16_t datagram_len = 0;
-    struct iovec vec;
-    struct msghdr msg;
-    err_t err;
-    vec.iov_base = mem;
-    vec.iov_len = len;
-    msg.msg_control = NULL;
-    msg.msg_controllen = 0;
-    msg.msg_flags = 0;
-    msg.msg_iov = &vec;
-    msg.msg_iovlen = 1;
-    msg.msg_name = from;
-    msg.msg_namelen = (fromlen ? *fromlen : 0);
-    err = lwip_recvfrom_udp_raw(sock, flags, &msg, &datagram_len, s);
-    if (err != ERR_OK) {
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom[UDP/RAW](%d): buf == NULL, error is \"%s\"!\n",
-                                  s, lwip_strerr(err)));
-      sock_set_errno(sock, err_to_errno(err));
-      done_socket(sock);
-      return -1;
-    }
-    ret = (ssize_t)LWIP_MIN(LWIP_MIN(len, datagram_len), SSIZE_MAX);
-    if (fromlen) {
-      *fromlen = msg.msg_namelen;
-    }
-  }
-
-  sock_set_errno(sock, 0);
-  done_socket(sock);
-  return ret;
+	{
+		u16_t datagram_len = 0;
+		struct iovec vec;
+		struct msghdr msg;
+		err_t err;
+		vec.iov_base = mem;
+		vec.iov_len = len;
+		msg.msg_control = NULL;
+		msg.msg_controllen = 0;
+		msg.msg_flags = 0;
+		msg.msg_iov = &vec;
+		msg.msg_iovlen = 1;
+		msg.msg_name = from;
+		msg.msg_namelen = (fromlen ? *fromlen : 0);
+		err = lwip_recvfrom_udp_raw(sock, flags, &msg, &datagram_len, s);
+		if (err != ERR_OK)
+		{
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom[UDP/RAW](%d): buf == NULL, error is \"%s\"!\n",
+										s, lwip_strerr(err)));
+			sock_set_errno(sock, err_to_errno(err));
+			done_socket(sock);
+			return -1;
+		}
+		ret = (ssize_t)LWIP_MIN(LWIP_MIN(len, datagram_len), SSIZE_MAX);
+		if (fromlen)
+		{
+			*fromlen = msg.msg_namelen;
+		}
+	}
+
+	sock_set_errno(sock, 0);
+	done_socket(sock);
+	return ret;
 }
 
 ssize_t
 lwip_read(int s, void *mem, size_t len)
 {
-  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
+	return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
 }
 
 ssize_t
 lwip_readv(int s, const struct iovec *iov, int iovcnt)
 {
-  struct msghdr msg;
-
-  msg.msg_name = NULL;
-  msg.msg_namelen = 0;
-  /* Hack: we have to cast via number to cast from 'const' pointer to non-const.
-     Blame the opengroup standard for this inconsistency. */
-  msg.msg_iov = LWIP_CONST_CAST(struct iovec *, iov);
-  msg.msg_iovlen = iovcnt;
-  msg.msg_control = NULL;
-  msg.msg_controllen = 0;
-  msg.msg_flags = 0;
-  return lwip_recvmsg(s, &msg, 0);
+	struct msghdr msg;
+
+	msg.msg_name = NULL;
+	msg.msg_namelen = 0;
+	/* Hack: we have to cast via number to cast from 'const' pointer to non-const.
+	   Blame the opengroup standard for this inconsistency. */
+	msg.msg_iov = LWIP_CONST_CAST(struct iovec *, iov);
+	msg.msg_iovlen = iovcnt;
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	msg.msg_flags = 0;
+	return lwip_recvmsg(s, &msg, 0);
 }
 
 ssize_t
 lwip_recv(int s, void *mem, size_t len, int flags)
 {
-  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
+	return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
 }
 
 ssize_t
 lwip_recvmsg(int s, struct msghdr *message, int flags)
 {
-  struct lwip_sock *sock;
-  int i;
-  ssize_t buflen;
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvmsg(%d, message=%p, flags=0x%x)\n", s, (void *)message, flags));
-  LWIP_ERROR("lwip_recvmsg: invalid message pointer", message != NULL, return ERR_ARG;);
-  LWIP_ERROR("lwip_recvmsg: unsupported flags", (flags & ~(MSG_PEEK|MSG_DONTWAIT)) == 0,
-             set_errno(EOPNOTSUPP); return -1;);
-
-  if ((message->msg_iovlen <= 0) || (message->msg_iovlen > IOV_MAX)) {
-    set_errno(EMSGSIZE);
-    return -1;
-  }
-
-  sock = get_socket(s);
-  if (!sock) {
-    return -1;
-  }
-
-  /* check for valid vectors */
-  buflen = 0;
-  for (i = 0; i < message->msg_iovlen; i++) {
-    if ((message->msg_iov[i].iov_base == NULL) || ((ssize_t)message->msg_iov[i].iov_len <= 0) ||
-        ((size_t)(ssize_t)message->msg_iov[i].iov_len != message->msg_iov[i].iov_len) ||
-        ((ssize_t)(buflen + (ssize_t)message->msg_iov[i].iov_len) <= 0)) {
-      sock_set_errno(sock, err_to_errno(ERR_VAL));
-      done_socket(sock);
-      return -1;
-    }
-    buflen = (ssize_t)(buflen + (ssize_t)message->msg_iov[i].iov_len);
-  }
-
-  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
+	struct lwip_sock *sock;
+	int i;
+	ssize_t buflen;
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvmsg(%d, message=%p, flags=0x%x)\n", s, (void *)message, flags));
+	LWIP_ERROR("lwip_recvmsg: invalid message pointer", message != NULL, return ERR_ARG;);
+	LWIP_ERROR("lwip_recvmsg: unsupported flags", (flags & ~(MSG_PEEK | MSG_DONTWAIT)) == 0,
+			   set_errno(EOPNOTSUPP);
+			   return -1;);
+
+	if ((message->msg_iovlen <= 0) || (message->msg_iovlen > IOV_MAX))
+	{
+		set_errno(EMSGSIZE);
+		return -1;
+	}
+
+	sock = get_socket(s);
+	if (!sock)
+	{
+		return -1;
+	}
+
+	/* check for valid vectors */
+	buflen = 0;
+	for (i = 0; i < message->msg_iovlen; i++)
+	{
+		if ((message->msg_iov[i].iov_base == NULL) || ((ssize_t)message->msg_iov[i].iov_len <= 0) ||
+			((size_t)(ssize_t)message->msg_iov[i].iov_len != message->msg_iov[i].iov_len) ||
+			((ssize_t)(buflen + (ssize_t)message->msg_iov[i].iov_len) <= 0))
+		{
+			sock_set_errno(sock, err_to_errno(ERR_VAL));
+			done_socket(sock);
+			return -1;
+		}
+		buflen = (ssize_t)(buflen + (ssize_t)message->msg_iov[i].iov_len);
+	}
+
+	if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP)
+	{
 #if LWIP_TCP
-    int recv_flags = flags;
-    message->msg_flags = 0;
-    /* recv the data */
-    buflen = 0;
-    for (i = 0; i < message->msg_iovlen; i++) {
-      /* try to receive into this vector's buffer */
-      ssize_t recvd_local = lwip_recv_tcp(sock, message->msg_iov[i].iov_base, message->msg_iov[i].iov_len, recv_flags);
-      if (recvd_local > 0) {
-        /* sum up received bytes */
-        buflen += recvd_local;
-      }
-      if ((recvd_local < 0) || (recvd_local < (int)message->msg_iov[i].iov_len) ||
-          (flags & MSG_PEEK)) {
-        /* returned prematurely (or peeking, which might actually be limitated to the first iov) */
-        if (buflen <= 0) {
-          /* nothing received at all, propagate the error */
-          buflen = recvd_local;
-        }
-        break;
-      }
-      /* pass MSG_DONTWAIT to lwip_recv_tcp() to prevent waiting for more data */
-      recv_flags |= MSG_DONTWAIT;
-    }
-    if (buflen > 0) {
-      /* reset socket error since we have received something */
-      sock_set_errno(sock, 0);
-    }
-    /* " If the socket is connected, the msg_name and msg_namelen members shall be ignored." */
-    done_socket(sock);
-    return buflen;
-#else /* LWIP_TCP */
-    sock_set_errno(sock, err_to_errno(ERR_ARG));
-    done_socket(sock);
-    return -1;
+		int recv_flags = flags;
+		message->msg_flags = 0;
+		/* recv the data */
+		buflen = 0;
+		for (i = 0; i < message->msg_iovlen; i++)
+		{
+			/* try to receive into this vector's buffer */
+			ssize_t recvd_local = lwip_recv_tcp(sock, message->msg_iov[i].iov_base, message->msg_iov[i].iov_len, recv_flags);
+			if (recvd_local > 0)
+			{
+				/* sum up received bytes */
+				buflen += recvd_local;
+			}
+			if ((recvd_local < 0) || (recvd_local < (int)message->msg_iov[i].iov_len) ||
+				(flags & MSG_PEEK))
+			{
+				/* returned prematurely (or peeking, which might actually be limitated to the first iov) */
+				if (buflen <= 0)
+				{
+					/* nothing received at all, propagate the error */
+					buflen = recvd_local;
+				}
+				break;
+			}
+			/* pass MSG_DONTWAIT to lwip_recv_tcp() to prevent waiting for more data */
+			recv_flags |= MSG_DONTWAIT;
+		}
+		if (buflen > 0)
+		{
+			/* reset socket error since we have received something */
+			sock_set_errno(sock, 0);
+		}
+		/* " If the socket is connected, the msg_name and msg_namelen members shall be ignored." */
+		done_socket(sock);
+		return buflen;
+#else  /* LWIP_TCP */
+		sock_set_errno(sock, err_to_errno(ERR_ARG));
+		done_socket(sock);
+		return -1;
 #endif /* LWIP_TCP */
-  }
-  /* else, UDP and RAW NETCONNs */
+	}
+	/* else, UDP and RAW NETCONNs */
 #if LWIP_UDP || LWIP_RAW
-  {
-    u16_t datagram_len = 0;
-    err_t err;
-    err = lwip_recvfrom_udp_raw(sock, flags, message, &datagram_len, s);
-    if (err != ERR_OK) {
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvmsg[UDP/RAW](%d): buf == NULL, error is \"%s\"!\n",
-                                  s, lwip_strerr(err)));
-      sock_set_errno(sock, err_to_errno(err));
-      done_socket(sock);
-      return -1;
-    }
-    if (datagram_len > buflen) {
-      message->msg_flags |= MSG_TRUNC;
-    }
-
-    sock_set_errno(sock, 0);
-    done_socket(sock);
-    return (int)datagram_len;
-  }
-#else /* LWIP_UDP || LWIP_RAW */
-  sock_set_errno(sock, err_to_errno(ERR_ARG));
-  done_socket(sock);
-  return -1;
+	{
+		u16_t datagram_len = 0;
+		err_t err;
+		err = lwip_recvfrom_udp_raw(sock, flags, message, &datagram_len, s);
+		if (err != ERR_OK)
+		{
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvmsg[UDP/RAW](%d): buf == NULL, error is \"%s\"!\n",
+										s, lwip_strerr(err)));
+			sock_set_errno(sock, err_to_errno(err));
+			done_socket(sock);
+			return -1;
+		}
+		if (datagram_len > buflen)
+		{
+			message->msg_flags |= MSG_TRUNC;
+		}
+
+		sock_set_errno(sock, 0);
+		done_socket(sock);
+		return (int)datagram_len;
+	}
+#else  /* LWIP_UDP || LWIP_RAW */
+	sock_set_errno(sock, err_to_errno(ERR_ARG));
+	done_socket(sock);
+	return -1;
 #endif /* LWIP_UDP || LWIP_RAW */
 }
 
 ssize_t
 lwip_send(int s, const void *data, size_t size, int flags)
 {
-  struct lwip_sock *sock;
-  err_t err;
-  u8_t write_flags;
-  size_t written;
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%"SZT_F", flags=0x%x)\n",
-                              s, data, size, flags));
-
-  sock = get_socket(s);
-  if (!sock) {
-    return -1;
-  }
-
-  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
+	struct lwip_sock *sock;
+	err_t err;
+	u8_t write_flags;
+	size_t written;
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%" SZT_F ", flags=0x%x)\n",
+								s, data, size, flags));
+
+	sock = get_socket(s);
+	if (!sock)
+	{
+		return -1;
+	}
+
+	if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP)
+	{
 #if (LWIP_UDP || LWIP_RAW)
-    done_socket(sock);
-    return lwip_sendto(s, data, size, flags, NULL, 0);
-#else /* (LWIP_UDP || LWIP_RAW) */
-    sock_set_errno(sock, err_to_errno(ERR_ARG));
-    done_socket(sock);
-    return -1;
+		done_socket(sock) return lwip_sendto(s, data, size, flags, NULL, 0);
+#else  /* (LWIP_UDP || LWIP_RAW) */
+		sock_set_errno(sock, err_to_errno(ERR_ARG));
+		done_socket(sock);
+		return -1;
 #endif /* (LWIP_UDP || LWIP_RAW) */
-  }
-
-  write_flags = (u8_t)(NETCONN_COPY |
-                       ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
-                       ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0));
-  written = 0;
-  err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
-  sock_set_errno(sock, err_to_errno(err));
-  done_socket(sock);
-  /* casting 'written' to ssize_t is OK here since the netconn API limits it to SSIZE_MAX */
-  return (err == ERR_OK ? (ssize_t)written : -1);
+	}
+
+	write_flags = (u8_t)(NETCONN_COPY |
+						 ((flags & MSG_MORE) ? NETCONN_MORE : 0) |
+						 ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0));
+	written = 0;
+	err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%" SZT_F "\n", s, err, written));
+	sock_set_errno(sock, err_to_errno(err));
+	done_socket(sock);
+	/* casting 'written' to ssize_t is OK here since the netconn API limits it to SSIZE_MAX */
+	return (err == ERR_OK ? (ssize_t)written : -1);
 }
 
 ssize_t
 lwip_sendmsg(int s, const struct msghdr *msg, int flags)
 {
-  struct lwip_sock *sock;
+	struct lwip_sock *sock;
 #if LWIP_TCP
-  u8_t write_flags;
-  size_t written;
+	u8_t write_flags;
+	size_t written;
 #endif
-  err_t err = ERR_OK;
-
-  sock = get_socket(s);
-  if (!sock) {
-    return -1;
-  }
-
-  LWIP_ERROR("lwip_sendmsg: invalid msghdr", msg != NULL,
-             sock_set_errno(sock, err_to_errno(ERR_ARG)); done_socket(sock); return -1;);
-  LWIP_ERROR("lwip_sendmsg: invalid msghdr iov", msg->msg_iov != NULL,
-             sock_set_errno(sock, err_to_errno(ERR_ARG)); done_socket(sock); return -1;);
-  LWIP_ERROR("lwip_sendmsg: maximum iovs exceeded", (msg->msg_iovlen > 0) && (msg->msg_iovlen <= IOV_MAX),
-             sock_set_errno(sock, EMSGSIZE); done_socket(sock); return -1;);
-  LWIP_ERROR("lwip_sendmsg: unsupported flags", (flags & ~(MSG_DONTWAIT | MSG_MORE)) == 0,
-             sock_set_errno(sock, EOPNOTSUPP); done_socket(sock); return -1;);
-
-  LWIP_UNUSED_ARG(msg->msg_control);
-  LWIP_UNUSED_ARG(msg->msg_controllen);
-  LWIP_UNUSED_ARG(msg->msg_flags);
-
-  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
+	err_t err = ERR_OK;
+
+	sock = get_socket(s);
+	if (!sock)
+	{
+		return -1;
+	}
+
+	LWIP_ERROR("lwip_sendmsg: invalid msghdr", msg != NULL,
+			   sock_set_errno(sock, err_to_errno(ERR_ARG));
+			   done_socket(sock); return -1;);
+	LWIP_ERROR("lwip_sendmsg: invalid msghdr iov", msg->msg_iov != NULL,
+			   sock_set_errno(sock, err_to_errno(ERR_ARG));
+			   done_socket(sock); return -1;);
+	LWIP_ERROR("lwip_sendmsg: maximum iovs exceeded", (msg->msg_iovlen > 0) && (msg->msg_iovlen <= IOV_MAX),
+			   sock_set_errno(sock, EMSGSIZE);
+			   done_socket(sock); return -1;);
+	LWIP_ERROR("lwip_sendmsg: unsupported flags", (flags & ~(MSG_DONTWAIT | MSG_MORE)) == 0,
+			   sock_set_errno(sock, EOPNOTSUPP);
+			   done_socket(sock); return -1;);
+
+	LWIP_UNUSED_ARG(msg->msg_control);
+	LWIP_UNUSED_ARG(msg->msg_controllen);
+	LWIP_UNUSED_ARG(msg->msg_flags);
+
+	if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP)
+	{
 #if LWIP_TCP
-    write_flags = (u8_t)(NETCONN_COPY |
-                         ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
-                         ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0));
-
-    written = 0;
-    err = netconn_write_vectors_partly(sock->conn, (struct netvector *)msg->msg_iov, (u16_t)msg->msg_iovlen, write_flags, &written);
-    sock_set_errno(sock, err_to_errno(err));
-    done_socket(sock);
-    /* casting 'written' to ssize_t is OK here since the netconn API limits it to SSIZE_MAX */
-    return (err == ERR_OK ? (ssize_t)written : -1);
-#else /* LWIP_TCP */
-    sock_set_errno(sock, err_to_errno(ERR_ARG));
-    done_socket(sock);
-    return -1;
+		write_flags = (u8_t)(NETCONN_COPY |
+							 ((flags & MSG_MORE) ? NETCONN_MORE : 0) |
+							 ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0));
+
+		written = 0;
+		err = netconn_write_vectors_partly(sock->conn, (struct netvector *)msg->msg_iov, (u16_t)msg->msg_iovlen, write_flags, &written);
+		sock_set_errno(sock, err_to_errno(err));
+		done_socket(sock);
+		/* casting 'written' to ssize_t is OK here since the netconn API limits it to SSIZE_MAX */
+		return (err == ERR_OK ? (ssize_t)written : -1);
+#else  /* LWIP_TCP */
+		sock_set_errno(sock, err_to_errno(ERR_ARG));
+		done_socket(sock);
+		return -1;
 #endif /* LWIP_TCP */
-  }
-  /* else, UDP and RAW NETCONNs */
+	}
+	/* else, UDP and RAW NETCONNs */
 #if LWIP_UDP || LWIP_RAW
-  {
-    struct netbuf chain_buf;
-    int i;
-    ssize_t size = 0;
-
-    LWIP_UNUSED_ARG(flags);
-    LWIP_ERROR("lwip_sendmsg: invalid msghdr name", (((msg->msg_name == NULL) && (msg->msg_namelen == 0)) ||
-               IS_SOCK_ADDR_LEN_VALID(msg->msg_namelen)),
-               sock_set_errno(sock, err_to_errno(ERR_ARG)); done_socket(sock); return -1;);
-
-    /* initialize chain buffer with destination */
-    memset(&chain_buf, 0, sizeof(struct netbuf));
-    if (msg->msg_name) {
-      u16_t remote_port;
-      SOCKADDR_TO_IPADDR_PORT((const struct sockaddr *)msg->msg_name, &chain_buf.addr, remote_port);
-      netbuf_fromport(&chain_buf) = remote_port;
-    }
+	{
+		struct netbuf chain_buf;
+		int i;
+		ssize_t size = 0;
+
+		LWIP_UNUSED_ARG(flags);
+		LWIP_ERROR("lwip_sendmsg: invalid msghdr name", (((msg->msg_name == NULL) && (msg->msg_namelen == 0)) || IS_SOCK_ADDR_LEN_VALID(msg->msg_namelen)),
+				   sock_set_errno(sock, err_to_errno(ERR_ARG));
+				   done_socket(sock); return -1;);
+
+		/* initialize chain buffer with destination */
+		memset(&chain_buf, 0, sizeof(struct netbuf));
+		if (msg->msg_name)
+		{
+			u16_t remote_port;
+			SOCKADDR_TO_IPADDR_PORT((const struct sockaddr *)msg->msg_name, &chain_buf.addr, remote_port);
+			netbuf_fromport(&chain_buf) = remote_port;
+		}
 #if LWIP_NETIF_TX_SINGLE_PBUF
-    for (i = 0; i < msg->msg_iovlen; i++) {
-      size += msg->msg_iov[i].iov_len;
-      if ((msg->msg_iov[i].iov_len > INT_MAX) || (size < (int)msg->msg_iov[i].iov_len)) {
-        /* overflow */
-        goto sendmsg_emsgsize;
-      }
-    }
-    if (size > 0xFFFF) {
-      /* overflow */
-      goto sendmsg_emsgsize;
-    }
-    /* Allocate a new netbuf and copy the data into it. */
-    if (netbuf_alloc(&chain_buf, (u16_t)size) == NULL) {
-      err = ERR_MEM;
-    } else {
-      /* flatten the IO vectors */
-      size_t offset = 0;
-      for (i = 0; i < msg->msg_iovlen; i++) {
-        MEMCPY(&((u8_t *)chain_buf.p->payload)[offset], msg->msg_iov[i].iov_base, msg->msg_iov[i].iov_len);
-        offset += msg->msg_iov[i].iov_len;
-      }
+		for (i = 0; i < msg->msg_iovlen; i++)
+		{
+			size += msg->msg_iov[i].iov_len;
+			if ((msg->msg_iov[i].iov_len > INT_MAX) || (size < (int)msg->msg_iov[i].iov_len))
+			{
+				/* overflow */
+				goto sendmsg_emsgsize;
+			}
+		}
+		if (size > 0xFFFF)
+		{
+			/* overflow */
+			goto sendmsg_emsgsize;
+		}
+		/* Allocate a new netbuf and copy the data into it. */
+		if (netbuf_alloc(&chain_buf, (u16_t)size) == NULL)
+		{
+			err = ERR_MEM;
+		}
+		else
+		{
+			/* flatten the IO vectors */
+			size_t offset = 0;
+			for (i = 0; i < msg->msg_iovlen; i++)
+			{
+				MEMCPY(&((u8_t *)chain_buf.p->payload)[offset], msg->msg_iov[i].iov_base, msg->msg_iov[i].iov_len);
+				offset += msg->msg_iov[i].iov_len;
+			}
 #if LWIP_CHECKSUM_ON_COPY
-      {
-        /* This can be improved by using LWIP_CHKSUM_COPY() and aggregating the checksum for each IO vector */
-        u16_t chksum = ~inet_chksum_pbuf(chain_buf.p);
-        netbuf_set_chksum(&chain_buf, chksum);
-      }
+			{
+				/* This can be improved by using LWIP_CHKSUM_COPY() and aggregating the checksum for each IO vector */
+				u16_t chksum = ~inet_chksum_pbuf(chain_buf.p);
+				netbuf_set_chksum(&chain_buf, chksum);
+			}
 #endif /* LWIP_CHECKSUM_ON_COPY */
-      err = ERR_OK;
-    }
-#else /* LWIP_NETIF_TX_SINGLE_PBUF */
-    /* create a chained netbuf from the IO vectors. NOTE: we assemble a pbuf chain
-       manually to avoid having to allocate, chain, and delete a netbuf for each iov */
-    for (i = 0; i < msg->msg_iovlen; i++) {
-      struct pbuf *p;
-      if (msg->msg_iov[i].iov_len > 0xFFFF) {
-        /* overflow */
-        goto sendmsg_emsgsize;
-      }
-      p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
-      if (p == NULL) {
-        err = ERR_MEM; /* let netbuf_delete() cleanup chain_buf */
-        break;
-      }
-      p->payload = msg->msg_iov[i].iov_base;
-      p->len = p->tot_len = (u16_t)msg->msg_iov[i].iov_len;
-      /* netbuf empty, add new pbuf */
-      if (chain_buf.p == NULL) {
-        chain_buf.p = chain_buf.ptr = p;
-        /* add pbuf to existing pbuf chain */
-      } else {
-        if (chain_buf.p->tot_len + p->len > 0xffff) {
-          /* overflow */
-          pbuf_free(p);
-          goto sendmsg_emsgsize;
-        }
-        pbuf_cat(chain_buf.p, p);
-      }
-    }
-    /* save size of total chain */
-    if (err == ERR_OK) {
-      size = netbuf_len(&chain_buf);
-    }
+			err = ERR_OK;
+		}
+#else  /* LWIP_NETIF_TX_SINGLE_PBUF */
+		/* create a chained netbuf from the IO vectors. NOTE: we assemble a pbuf chain
+		   manually to avoid having to allocate, chain, and delete a netbuf for each iov */
+		for (i = 0; i < msg->msg_iovlen; i++)
+		{
+			struct pbuf *p;
+			if (msg->msg_iov[i].iov_len > 0xFFFF)
+			{
+				/* overflow */
+				goto sendmsg_emsgsize;
+			}
+			p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
+			if (p == NULL)
+			{
+				err = ERR_MEM; /* let netbuf_delete() cleanup chain_buf */
+				break;
+			}
+			p->payload = msg->msg_iov[i].iov_base;
+			p->len = p->tot_len = (u16_t)msg->msg_iov[i].iov_len;
+			/* netbuf empty, add new pbuf */
+			if (chain_buf.p == NULL)
+			{
+				chain_buf.p = chain_buf.ptr = p;
+				/* add pbuf to existing pbuf chain */
+			}
+			else
+			{
+				if (chain_buf.p->tot_len + p->len > 0xffff)
+				{
+					/* overflow */
+					pbuf_free(p);
+					goto sendmsg_emsgsize;
+				}
+				pbuf_cat(chain_buf.p, p);
+			}
+		}
+		/* save size of total chain */
+		if (err == ERR_OK)
+		{
+			size = netbuf_len(&chain_buf);
+		}
 #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
 
-    if (err == ERR_OK) {
+		if (err == ERR_OK)
+		{
 #if LWIP_IPV4 && LWIP_IPV6
-      /* Dual-stack: Unmap IPv4 mapped IPv6 addresses */
-      if (IP_IS_V6_VAL(chain_buf.addr) && ip6_addr_isipv4mappedipv6(ip_2_ip6(&chain_buf.addr))) {
-        unmap_ipv4_mapped_ipv6(ip_2_ip4(&chain_buf.addr), ip_2_ip6(&chain_buf.addr));
-        IP_SET_TYPE_VAL(chain_buf.addr, IPADDR_TYPE_V4);
-      }
+			/* Dual-stack: Unmap IPv4 mapped IPv6 addresses */
+			if (IP_IS_V6_VAL(chain_buf.addr) && ip6_addr_isipv4mappedipv6(ip_2_ip6(&chain_buf.addr)))
+			{
+				unmap_ipv4_mapped_ipv6(ip_2_ip4(&chain_buf.addr), ip_2_ip6(&chain_buf.addr));
+				IP_SET_TYPE_VAL(chain_buf.addr, IPADDR_TYPE_V4);
+			}
 #endif /* LWIP_IPV4 && LWIP_IPV6 */
 
-      /* send the data */
-      err = netconn_send(sock->conn, &chain_buf);
-    }
-
-    /* deallocated the buffer */
-    netbuf_free(&chain_buf);
-
-    sock_set_errno(sock, err_to_errno(err));
-    done_socket(sock);
-    return (err == ERR_OK ? size : -1);
-sendmsg_emsgsize:
-    sock_set_errno(sock, EMSGSIZE);
-    netbuf_free(&chain_buf);
-    done_socket(sock);
-    return -1;
-  }
-#else /* LWIP_UDP || LWIP_RAW */
-  sock_set_errno(sock, err_to_errno(ERR_ARG));
-  done_socket(sock);
-  return -1;
+			/* send the data */
+			err = netconn_send(sock->conn, &chain_buf);
+		}
+
+		/* deallocated the buffer */
+		netbuf_free(&chain_buf);
+
+		sock_set_errno(sock, err_to_errno(err));
+		done_socket(sock);
+		return (err == ERR_OK ? size : -1);
+	sendmsg_emsgsize:
+		sock_set_errno(sock, EMSGSIZE);
+		netbuf_free(&chain_buf);
+		done_socket(sock);
+		return -1;
+	}
+#else  /* LWIP_UDP || LWIP_RAW */
+	sock_set_errno(sock, err_to_errno(ERR_ARG));
+	done_socket(sock);
+	return -1;
 #endif /* LWIP_UDP || LWIP_RAW */
 }
 
 ssize_t
 lwip_sendto(int s, const void *data, size_t size, int flags,
-            const struct sockaddr *to, socklen_t tolen)
+			const struct sockaddr *to, socklen_t tolen)
 {
-  struct lwip_sock *sock;
-  err_t err;
-  u16_t short_size;
-  u16_t remote_port;
-  struct netbuf buf;
-
-  sock = get_socket(s);
-  if (!sock) {
-    return -1;
-  }
-
-  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
+	struct lwip_sock *sock;
+	err_t err;
+	u16_t short_size;
+	u16_t remote_port;
+	struct netbuf buf;
+
+	sock = get_socket(s);
+	if (!sock)
+	{
+		return -1;
+	}
+
+	if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP)
+	{
 #if LWIP_TCP
-    done_socket(sock);
-    return lwip_send(s, data, size, flags);
-#else /* LWIP_TCP */
-    LWIP_UNUSED_ARG(flags);
-    sock_set_errno(sock, err_to_errno(ERR_ARG));
-    done_socket(sock);
-    return -1;
+		done_socket(sock);
+		return lwip_send(s, data, size, flags);
+#else  /* LWIP_TCP */
+		LWIP_UNUSED_ARG(flags);
+		sock_set_errno(sock, err_to_errno(ERR_ARG));
+		done_socket(sock);
+		return -1;
 #endif /* LWIP_TCP */
-  }
-
-  if (size > LWIP_MIN(0xFFFF, SSIZE_MAX)) {
-    /* cannot fit into one datagram (at least for us) */
-    sock_set_errno(sock, EMSGSIZE);
-    done_socket(sock);
-    return -1;
-  }
-  short_size = (u16_t)size;
-  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
-             (IS_SOCK_ADDR_LEN_VALID(tolen) &&
-              ((to != NULL) && (IS_SOCK_ADDR_TYPE_VALID(to) && IS_SOCK_ADDR_ALIGNED(to))))),
-             sock_set_errno(sock, err_to_errno(ERR_ARG)); done_socket(sock); return -1;);
-  LWIP_UNUSED_ARG(tolen);
-
-  /* initialize a buffer */
-  buf.p = buf.ptr = NULL;
+	}
+
+	if (size > LWIP_MIN(0xFFFF, SSIZE_MAX))
+	{
+		/* cannot fit into one datagram (at least for us) */
+		sock_set_errno(sock, EMSGSIZE);
+		done_socket(sock);
+		return -1;
+	}
+	short_size = (u16_t)size;
+	LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) || (IS_SOCK_ADDR_LEN_VALID(tolen) && ((to != NULL) && (IS_SOCK_ADDR_TYPE_VALID(to) && IS_SOCK_ADDR_ALIGNED(to))))),
+			   sock_set_errno(sock, err_to_errno(ERR_ARG));
+			   done_socket(sock); return -1;);
+	LWIP_UNUSED_ARG(tolen);
+
+	/* initialize a buffer */
+	buf.p = buf.ptr = NULL;
 #if LWIP_CHECKSUM_ON_COPY
-  buf.flags = 0;
+	buf.flags = 0;
 #endif /* LWIP_CHECKSUM_ON_COPY */
-  if (to) {
-    SOCKADDR_TO_IPADDR_PORT(to, &buf.addr, remote_port);
-  } else {
-    remote_port = 0;
-    ip_addr_set_any(NETCONNTYPE_ISIPV6(netconn_type(sock->conn)), &buf.addr);
-  }
-  netbuf_fromport(&buf) = remote_port;
-
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_sendto(%d, data=%p, short_size=%"U16_F", flags=0x%x to=",
-                              s, data, short_size, flags));
-  ip_addr_debug_print_val(SOCKETS_DEBUG, buf.addr);
-  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", remote_port));
-
-  /* make the buffer point to the data that should be sent */
+	if (to)
+	{
+		SOCKADDR_TO_IPADDR_PORT(to, &buf.addr, remote_port);
+	}
+	else
+	{
+		remote_port = 0;
+		ip_addr_set_any(NETCONNTYPE_ISIPV6(netconn_type(sock->conn)), &buf.addr);
+	}
+	netbuf_fromport(&buf) = remote_port;
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_sendto(%d, data=%p, short_size=%" U16_F ", flags=0x%x to=",
+								s, data, short_size, flags));
+	ip_addr_debug_print_val(SOCKETS_DEBUG, buf.addr);
+	LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%" U16_F "\n", remote_port));
+
+	/* make the buffer point to the data that should be sent */
 #if LWIP_NETIF_TX_SINGLE_PBUF
-  /* Allocate a new netbuf and copy the data into it. */
-  if (netbuf_alloc(&buf, short_size) == NULL) {
-    err = ERR_MEM;
-  } else {
+	/* Allocate a new netbuf and copy the data into it. */
+	if (netbuf_alloc(&buf, short_size) == NULL)
+	{
+		err = ERR_MEM;
+	}
+	else
+	{
 #if LWIP_CHECKSUM_ON_COPY
-    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_RAW) {
-      u16_t chksum = LWIP_CHKSUM_COPY(buf.p->payload, data, short_size);
-      netbuf_set_chksum(&buf, chksum);
-    } else
+		if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_RAW)
+		{
+			u16_t chksum = LWIP_CHKSUM_COPY(buf.p->payload, data, short_size);
+			netbuf_set_chksum(&buf, chksum);
+		}
+		else
 #endif /* LWIP_CHECKSUM_ON_COPY */
-    {
-      MEMCPY(buf.p->payload, data, short_size);
-    }
-    err = ERR_OK;
-  }
-#else /* LWIP_NETIF_TX_SINGLE_PBUF */
-  err = netbuf_ref(&buf, data, short_size);
+		{
+			MEMCPY(buf.p->payload, data, short_size);
+		}
+		err = ERR_OK;
+	}
+#else  /* LWIP_NETIF_TX_SINGLE_PBUF */
+	err = netbuf_ref(&buf, data, short_size);
 #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
-  if (err == ERR_OK) {
+	if (err == ERR_OK)
+	{
 #if LWIP_IPV4 && LWIP_IPV6
-    /* Dual-stack: Unmap IPv4 mapped IPv6 addresses */
-    if (IP_IS_V6_VAL(buf.addr) && ip6_addr_isipv4mappedipv6(ip_2_ip6(&buf.addr))) {
-      unmap_ipv4_mapped_ipv6(ip_2_ip4(&buf.addr), ip_2_ip6(&buf.addr));
-      IP_SET_TYPE_VAL(buf.addr, IPADDR_TYPE_V4);
-    }
+		/* Dual-stack: Unmap IPv4 mapped IPv6 addresses */
+		if (IP_IS_V6_VAL(buf.addr) && ip6_addr_isipv4mappedipv6(ip_2_ip6(&buf.addr)))
+		{
+			unmap_ipv4_mapped_ipv6(ip_2_ip4(&buf.addr), ip_2_ip6(&buf.addr));
+			IP_SET_TYPE_VAL(buf.addr, IPADDR_TYPE_V4);
+		}
 #endif /* LWIP_IPV4 && LWIP_IPV6 */
 
-    /* send the data */
-    err = netconn_send(sock->conn, &buf);
-  }
+		/* send the data */
+		err = netconn_send(sock->conn, &buf);
+	}
 
-  /* deallocated the buffer */
-  netbuf_free(&buf);
+	/* deallocated the buffer */
+	netbuf_free(&buf);
 
-  sock_set_errno(sock, err_to_errno(err));
-  done_socket(sock);
-  return (err == ERR_OK ? short_size : -1);
+	sock_set_errno(sock, err_to_errno(err));
+	done_socket(sock);
+	return (err == ERR_OK ? short_size : -1);
 }
 
-int
-lwip_socket(int domain, int type, int protocol)
+int lwip_socket(int domain, int type, int protocol)
 {
-  struct netconn *conn;
-  int i;
-
-  LWIP_UNUSED_ARG(domain); /* @todo: check this */
-
-  /* create a netconn */
-  switch (type) {
-    case SOCK_RAW:
-      conn = netconn_new_with_proto_and_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_RAW),
-             (u8_t)protocol, DEFAULT_SOCKET_EVENTCB);
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
-                                  domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
-      break;
-    case SOCK_DGRAM:
-      conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain,
-                                       ((protocol == IPPROTO_UDPLITE) ? NETCONN_UDPLITE : NETCONN_UDP)),
-                                       DEFAULT_SOCKET_EVENTCB);
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
-                                  domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
+	struct netconn *conn;
+	int i;
+
+	LWIP_UNUSED_ARG(domain); /* @todo: check this */
+
+	/* create a netconn */
+	switch (type)
+	{
+	case SOCK_RAW:
+		conn = netconn_new_with_proto_and_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_RAW),
+												   (u8_t)protocol, DEFAULT_SOCKET_EVENTCB);
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
+									domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
+		break;
+	case SOCK_DGRAM:
+		conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain,
+																((protocol == IPPROTO_UDPLITE) ? NETCONN_UDPLITE : NETCONN_UDP)),
+										 DEFAULT_SOCKET_EVENTCB);
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
+									domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
 #if LWIP_NETBUF_RECVINFO
-      if (conn) {
-        /* netconn layer enables pktinfo by default, sockets default to off */
-        conn->flags &= ~NETCONN_FLAG_PKTINFO;
-      }
+		if (conn)
+		{
+			/* netconn layer enables pktinfo by default, sockets default to off */
+			conn->flags &= ~NETCONN_FLAG_PKTINFO;
+		}
 #endif /* LWIP_NETBUF_RECVINFO */
-      break;
-    case SOCK_STREAM:
-      conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_TCP), DEFAULT_SOCKET_EVENTCB);
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
-                                  domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
-      break;
-    default:
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
-                                  domain, type, protocol));
-      set_errno(EINVAL);
-      return -1;
-  }
-
-  if (!conn) {
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
-    set_errno(ENOBUFS);
-    return -1;
-  }
-
-  i = alloc_socket(conn, 0);
-
-  if (i == -1) {
-    netconn_delete(conn);
-    set_errno(ENFILE);
-    return -1;
-  }
-  conn->socket = i;
-  done_socket(&sockets[i - LWIP_SOCKET_OFFSET]);
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
-  set_errno(0);
-  return i;
+		break;
+	case SOCK_STREAM:
+		conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_TCP), DEFAULT_SOCKET_EVENTCB);
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
+									domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
+		break;
+	default:
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
+									domain, type, protocol));
+		set_errno(EINVAL);
+		return -1;
+	}
+
+	if (!conn)
+	{
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
+		set_errno(ENOBUFS);
+		return -1;
+	}
+
+	i = alloc_socket(conn, 0);
+
+	if (i == -1)
+	{
+		netconn_delete(conn);
+		set_errno(ENFILE);
+		return -1;
+	}
+	conn->socket = i;
+	done_socket(&sockets[i - LWIP_SOCKET_OFFSET]);
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
+	set_errno(0);
+	return i;
 }
 
 ssize_t
 lwip_write(int s, const void *data, size_t size)
 {
-  return lwip_send(s, data, size, 0);
+	return lwip_send(s, data, size, 0);
 }
 
 ssize_t
 lwip_writev(int s, const struct iovec *iov, int iovcnt)
 {
-  struct msghdr msg;
-
-  msg.msg_name = NULL;
-  msg.msg_namelen = 0;
-  /* Hack: we have to cast via number to cast from 'const' pointer to non-const.
-     Blame the opengroup standard for this inconsistency. */
-  msg.msg_iov = LWIP_CONST_CAST(struct iovec *, iov);
-  msg.msg_iovlen = iovcnt;
-  msg.msg_control = NULL;
-  msg.msg_controllen = 0;
-  msg.msg_flags = 0;
-  return lwip_sendmsg(s, &msg, 0);
+	struct msghdr msg;
+
+	msg.msg_name = NULL;
+	msg.msg_namelen = 0;
+	/* Hack: we have to cast via number to cast from 'const' pointer to non-const.
+	   Blame the opengroup standard for this inconsistency. */
+	msg.msg_iov = LWIP_CONST_CAST(struct iovec *, iov);
+	msg.msg_iovlen = iovcnt;
+	msg.msg_control = NULL;
+	msg.msg_controllen = 0;
+	msg.msg_flags = 0;
+	return lwip_sendmsg(s, &msg, 0);
 }
 
 #if LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL
@@ -1768,49 +1978,54 @@ lwip_writev(int s, const struct iovec *iov, int iovcnt)
 static void
 lwip_link_select_cb(struct lwip_select_cb *select_cb)
 {
-  LWIP_SOCKET_SELECT_DECL_PROTECT(lev);
-
-  /* Protect the select_cb_list */
-  LWIP_SOCKET_SELECT_PROTECT(lev);
-
-  /* Put this select_cb on top of list */
-  select_cb->next = select_cb_list;
-  if (select_cb_list != NULL) {
-    select_cb_list->prev = select_cb;
-  }
-  select_cb_list = select_cb;
+	LWIP_SOCKET_SELECT_DECL_PROTECT(lev);
+
+	/* Protect the select_cb_list */
+	LWIP_SOCKET_SELECT_PROTECT(lev);
+
+	/* Put this select_cb on top of list */
+	select_cb->next = select_cb_list;
+	if (select_cb_list != NULL)
+	{
+		select_cb_list->prev = select_cb;
+	}
+	select_cb_list = select_cb;
 #if !LWIP_TCPIP_CORE_LOCKING
-  /* Increasing this counter tells select_check_waiters that the list has changed. */
-  select_cb_ctr++;
+	/* Increasing this counter tells select_check_waiters that the list has changed. */
+	select_cb_ctr++;
 #endif
 
-  /* Now we can safely unprotect */
-  LWIP_SOCKET_SELECT_UNPROTECT(lev);
+	/* Now we can safely unprotect */
+	LWIP_SOCKET_SELECT_UNPROTECT(lev);
 }
 
 /* Remove select_cb from select_cb_list. */
 static void
 lwip_unlink_select_cb(struct lwip_select_cb *select_cb)
 {
-  LWIP_SOCKET_SELECT_DECL_PROTECT(lev);
-
-  /* Take us off the list */
-  LWIP_SOCKET_SELECT_PROTECT(lev);
-  if (select_cb->next != NULL) {
-    select_cb->next->prev = select_cb->prev;
-  }
-  if (select_cb_list == select_cb) {
-    LWIP_ASSERT("select_cb->prev == NULL", select_cb->prev == NULL);
-    select_cb_list = select_cb->next;
-  } else {
-    LWIP_ASSERT("select_cb->prev != NULL", select_cb->prev != NULL);
-    select_cb->prev->next = select_cb->next;
-  }
+	LWIP_SOCKET_SELECT_DECL_PROTECT(lev);
+
+	/* Take us off the list */
+	LWIP_SOCKET_SELECT_PROTECT(lev);
+	if (select_cb->next != NULL)
+	{
+		select_cb->next->prev = select_cb->prev;
+	}
+	if (select_cb_list == select_cb)
+	{
+		LWIP_ASSERT("select_cb->prev == NULL", select_cb->prev == NULL);
+		select_cb_list = select_cb->next;
+	}
+	else
+	{
+		LWIP_ASSERT("select_cb->prev != NULL", select_cb->prev != NULL);
+		select_cb->prev->next = select_cb->next;
+	}
 #if !LWIP_TCPIP_CORE_LOCKING
-  /* Increasing this counter tells select_check_waiters that the list has changed. */
-  select_cb_ctr++;
+	/* Increasing this counter tells select_check_waiters that the list has changed. */
+	select_cb_ctr++;
 #endif
-  LWIP_SOCKET_SELECT_UNPROTECT(lev);
+	LWIP_SOCKET_SELECT_UNPROTECT(lev);
 }
 #endif /* LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL */
 
@@ -1831,69 +2046,77 @@ lwip_unlink_select_cb(struct lwip_select_cb *select_cb)
  */
 static int
 lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *exceptset_in,
-             fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
+			 fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
 {
-  int i, nready = 0;
-  fd_set lreadset, lwriteset, lexceptset;
-  struct lwip_sock *sock;
-  SYS_ARCH_DECL_PROTECT(lev);
-
-  FD_ZERO(&lreadset);
-  FD_ZERO(&lwriteset);
-  FD_ZERO(&lexceptset);
-
-  /* Go through each socket in each list to count number of sockets which
-     currently match */
-  for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
-    /* if this FD is not in the set, continue */
-    if (!(readset_in && FD_ISSET(i, readset_in)) &&
-        !(writeset_in && FD_ISSET(i, writeset_in)) &&
-        !(exceptset_in && FD_ISSET(i, exceptset_in))) {
-      continue;
-    }
-    /* First get the socket's status (protected)... */
-    SYS_ARCH_PROTECT(lev);
-    sock = tryget_socket_unconn_locked(i);
-    if (sock != NULL) {
-      void *lastdata = sock->lastdata.pbuf;
-      s16_t rcvevent = sock->rcvevent;
-      u16_t sendevent = sock->sendevent;
-      u16_t errevent = sock->errevent;
-      SYS_ARCH_UNPROTECT(lev);
-
-      /* ... then examine it: */
-      /* See if netconn of this socket is ready for read */
-      if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
-        FD_SET(i, &lreadset);
-        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
-        nready++;
-      }
-      /* See if netconn of this socket is ready for write */
-      if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
-        FD_SET(i, &lwriteset);
-        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
-        nready++;
-      }
-      /* See if netconn of this socket had an error */
-      if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
-        FD_SET(i, &lexceptset);
-        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
-        nready++;
-      }
-      done_socket(sock);
-    } else {
-      SYS_ARCH_UNPROTECT(lev);
-      /* no a valid open socket */
-      return -1;
-    }
-  }
-  /* copy local sets to the ones provided as arguments */
-  *readset_out = lreadset;
-  *writeset_out = lwriteset;
-  *exceptset_out = lexceptset;
-
-  LWIP_ASSERT("nready >= 0", nready >= 0);
-  return nready;
+	int i, nready = 0;
+	fd_set lreadset, lwriteset, lexceptset;
+	struct lwip_sock *sock;
+	SYS_ARCH_DECL_PROTECT(lev);
+
+	FD_ZERO(&lreadset);
+	FD_ZERO(&lwriteset);
+	FD_ZERO(&lexceptset);
+
+	/* Go through each socket in each list to count number of sockets which
+	   currently match */
+	for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++)
+	{
+		/* if this FD is not in the set, continue */
+		if (!(readset_in && FD_ISSET(i, readset_in)) &&
+			!(writeset_in && FD_ISSET(i, writeset_in)) &&
+			!(exceptset_in && FD_ISSET(i, exceptset_in)))
+		{
+			continue;
+		}
+		/* First get the socket's status (protected)... */
+		SYS_ARCH_PROTECT(lev);
+		sock = tryget_socket_unconn_locked(i);
+		if (sock != NULL)
+		{
+			void *lastdata = sock->lastdata.pbuf;
+			s16_t rcvevent = sock->rcvevent;
+			u16_t sendevent = sock->sendevent;
+			u16_t errevent = sock->errevent;
+			SYS_ARCH_UNPROTECT(lev);
+
+			/* ... then examine it: */
+			/* See if netconn of this socket is ready for read */
+			if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0)))
+			{
+				FD_SET(i, &lreadset);
+				LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
+				nready++;
+			}
+			/* See if netconn of this socket is ready for write */
+			if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0))
+			{
+				FD_SET(i, &lwriteset);
+				LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
+				nready++;
+			}
+			/* See if netconn of this socket had an error */
+			if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0))
+			{
+				FD_SET(i, &lexceptset);
+				LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
+				nready++;
+			}
+			done_socket(sock);
+		}
+		else
+		{
+			SYS_ARCH_UNPROTECT(lev);
+			/* no a valid open socket */
+			return -1;
+		}
+	}
+	/* copy local sets to the ones provided as arguments */
+	*readset_out = lreadset;
+	*writeset_out = lwriteset;
+	*exceptset_out = lexceptset;
+
+	LWIP_ASSERT("nready >= 0", nready >= 0);
+	return nready;
 }
 
 #if LWIP_NETCONN_FULLDUPLEX
@@ -1904,23 +2127,27 @@ lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *excep
 static void
 lwip_select_inc_sockets_used_set(int maxfdp, fd_set *fdset, fd_set *used_sockets)
 {
-  SYS_ARCH_DECL_PROTECT(lev);
-  if (fdset) {
-    int i;
-    for (i = LWIP_SOCKET_OFFSET; i < maxfdp; i++) {
-      /* if this FD is in the set, lock it (unless already done) */
-      if (FD_ISSET(i, fdset) && !FD_ISSET(i, used_sockets)) {
-        struct lwip_sock *sock;
-        SYS_ARCH_PROTECT(lev);
-        sock = tryget_socket_unconn_locked(i);
-        if (sock != NULL) {
-          /* leave the socket used until released by lwip_select_dec_sockets_used */
-          FD_SET(i, used_sockets);
-        }
-        SYS_ARCH_UNPROTECT(lev);
-      }
-    }
-  }
+	SYS_ARCH_DECL_PROTECT(lev);
+	if (fdset)
+	{
+		int i;
+		for (i = LWIP_SOCKET_OFFSET; i < maxfdp; i++)
+		{
+			/* if this FD is in the set, lock it (unless already done) */
+			if (FD_ISSET(i, fdset) && !FD_ISSET(i, used_sockets))
+			{
+				struct lwip_sock *sock;
+				SYS_ARCH_PROTECT(lev);
+				sock = tryget_socket_unconn_locked(i);
+				if (sock != NULL)
+				{
+					/* leave the socket used until released by lwip_select_dec_sockets_used */
+					FD_SET(i, used_sockets);
+				}
+				SYS_ARCH_UNPROTECT(lev);
+			}
+		}
+	}
 }
 
 /* Mark all sockets passed to select as used to prevent them from being freed
@@ -1931,243 +2158,286 @@ lwip_select_inc_sockets_used_set(int maxfdp, fd_set *fdset, fd_set *used_sockets
 static void
 lwip_select_inc_sockets_used(int maxfdp, fd_set *fdset1, fd_set *fdset2, fd_set *fdset3, fd_set *used_sockets)
 {
-  FD_ZERO(used_sockets);
-  lwip_select_inc_sockets_used_set(maxfdp, fdset1, used_sockets);
-  lwip_select_inc_sockets_used_set(maxfdp, fdset2, used_sockets);
-  lwip_select_inc_sockets_used_set(maxfdp, fdset3, used_sockets);
+	FD_ZERO(used_sockets);
+	lwip_select_inc_sockets_used_set(maxfdp, fdset1, used_sockets);
+	lwip_select_inc_sockets_used_set(maxfdp, fdset2, used_sockets);
+	lwip_select_inc_sockets_used_set(maxfdp, fdset3, used_sockets);
 }
 
 /* Let go all sockets that were marked as used when starting select */
 static void
 lwip_select_dec_sockets_used(int maxfdp, fd_set *used_sockets)
 {
-  int i;
-  for (i = LWIP_SOCKET_OFFSET; i < maxfdp; i++) {
-    /* if this FD is not in the set, continue */
-    if (FD_ISSET(i, used_sockets)) {
-      struct lwip_sock *sock = tryget_socket_unconn_nouse(i);
-      LWIP_ASSERT("socket gone at the end of select", sock != NULL);
-      if (sock != NULL) {
-        done_socket(sock);
-      }
-    }
-  }
+	int i;
+	for (i = LWIP_SOCKET_OFFSET; i < maxfdp; i++)
+	{
+		/* if this FD is not in the set, continue */
+		if (FD_ISSET(i, used_sockets))
+		{
+			struct lwip_sock *sock = tryget_socket_unconn_nouse(i);
+			LWIP_ASSERT("socket gone at the end of select", sock != NULL);
+			if (sock != NULL)
+			{
+				done_socket(sock);
+			}
+		}
+	}
 }
 #else /* LWIP_NETCONN_FULLDUPLEX */
 #define lwip_select_inc_sockets_used(maxfdp1, readset, writeset, exceptset, used_sockets)
 #define lwip_select_dec_sockets_used(maxfdp1, used_sockets)
 #endif /* LWIP_NETCONN_FULLDUPLEX */
 
-int
-lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
-            struct timeval *timeout)
+int lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
+				struct timeval *timeout)
 {
-  u32_t waitres = 0;
-  int nready;
-  fd_set lreadset, lwriteset, lexceptset;
-  u32_t msectimeout;
-  int i;
-  int maxfdp2;
+	u32_t waitres = 0;
+	int nready;
+	fd_set lreadset, lwriteset, lexceptset;
+	u32_t msectimeout;
+	int i;
+	int maxfdp2;
 #if LWIP_NETCONN_SEM_PER_THREAD
-  int waited = 0;
+	int waited = 0;
 #endif
 #if LWIP_NETCONN_FULLDUPLEX
-  fd_set used_sockets;
+	fd_set used_sockets;
 #endif
-  SYS_ARCH_DECL_PROTECT(lev);
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%"S32_F" tvusec=%"S32_F")\n",
-                              maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
-                              timeout ? (s32_t)timeout->tv_sec : (s32_t) - 1,
-                              timeout ? (s32_t)timeout->tv_usec : (s32_t) - 1));
-
-  if ((maxfdp1 < 0) || (maxfdp1 > LWIP_SELECT_MAXNFDS)) {
-    set_errno(EINVAL);
-    return -1;
-  }
-
-  lwip_select_inc_sockets_used(maxfdp1, readset, writeset, exceptset, &used_sockets);
-
-  /* Go through each socket in each list to count number of sockets which
-     currently match */
-  nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
-
-  if (nready < 0) {
-    /* one of the sockets in one of the fd_sets was invalid */
-    set_errno(EBADF);
-    lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
-    return -1;
-  } else if (nready > 0) {
-    /* one or more sockets are set, no need to wait */
-    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
-  } else {
-    /* If we don't have any current events, then suspend if we are supposed to */
-    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
-      /* This is OK as the local fdsets are empty and nready is zero,
-         or we would have returned earlier. */
-    } else {
-      /* None ready: add our semaphore to list:
-         We don't actually need any dynamic memory. Our entry on the
-         list is only valid while we are in this function, so it's ok
-         to use local variables (unless we're running in MPU compatible
-         mode). */
-      API_SELECT_CB_VAR_DECLARE(select_cb);
-      API_SELECT_CB_VAR_ALLOC(select_cb, set_errno(ENOMEM); lwip_select_dec_sockets_used(maxfdp1, &used_sockets); return -1);
-      memset(&API_SELECT_CB_VAR_REF(select_cb), 0, sizeof(struct lwip_select_cb));
-
-      API_SELECT_CB_VAR_REF(select_cb).readset = readset;
-      API_SELECT_CB_VAR_REF(select_cb).writeset = writeset;
-      API_SELECT_CB_VAR_REF(select_cb).exceptset = exceptset;
+	SYS_ARCH_DECL_PROTECT(lev);
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%" S32_F " tvusec=%" S32_F ")\n",
+								maxfdp1, (void *)readset, (void *)writeset, (void *)exceptset,
+								timeout ? (s32_t)timeout->tv_sec : (s32_t)-1,
+								timeout ? (s32_t)timeout->tv_usec : (s32_t)-1));
+
+	if ((maxfdp1 < 0) || (maxfdp1 > LWIP_SELECT_MAXNFDS))
+	{
+		set_errno(EINVAL);
+		return -1;
+	}
+
+	lwip_select_inc_sockets_used(maxfdp1, readset, writeset, exceptset, &used_sockets);
+
+	/* Go through each socket in each list to count number of sockets which
+	   currently match */
+	nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
+
+	if (nready < 0)
+	{
+		/* one of the sockets in one of the fd_sets was invalid */
+		set_errno(EBADF);
+		lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
+		return -1;
+	}
+	else if (nready > 0)
+	{
+		/* one or more sockets are set, no need to wait */
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
+	}
+	else
+	{
+		/* If we don't have any current events, then suspend if we are supposed to */
+		if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0)
+		{
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
+			/* This is OK as the local fdsets are empty and nready is zero,
+			   or we would have returned earlier. */
+		}
+		else
+		{
+			/* None ready: add our semaphore to list:
+			   We don't actually need any dynamic memory. Our entry on the
+			   list is only valid while we are in this function, so it's ok
+			   to use local variables (unless we're running in MPU compatible
+			   mode). */
+			API_SELECT_CB_VAR_DECLARE(select_cb);
+			API_SELECT_CB_VAR_ALLOC(select_cb, set_errno(ENOMEM); lwip_select_dec_sockets_used(maxfdp1, &used_sockets); return -1);
+			memset(&API_SELECT_CB_VAR_REF(select_cb), 0, sizeof(struct lwip_select_cb));
+
+			API_SELECT_CB_VAR_REF(select_cb).readset = readset;
+			API_SELECT_CB_VAR_REF(select_cb).writeset = writeset;
+			API_SELECT_CB_VAR_REF(select_cb).exceptset = exceptset;
 #if LWIP_NETCONN_SEM_PER_THREAD
-      API_SELECT_CB_VAR_REF(select_cb).sem = LWIP_NETCONN_THREAD_SEM_GET();
-#else /* LWIP_NETCONN_SEM_PER_THREAD */
-      if (sys_sem_new(&API_SELECT_CB_VAR_REF(select_cb).sem, 0) != ERR_OK) {
-        /* failed to create semaphore */
-        set_errno(ENOMEM);
-        lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
-        API_SELECT_CB_VAR_FREE(select_cb);
-        return -1;
-      }
+			API_SELECT_CB_VAR_REF(select_cb).sem = LWIP_NETCONN_THREAD_SEM_GET();
+#else  /* LWIP_NETCONN_SEM_PER_THREAD */
+			if (sys_sem_new(&API_SELECT_CB_VAR_REF(select_cb).sem, 0) != ERR_OK)
+			{
+				/* failed to create semaphore */
+				set_errno(ENOMEM);
+				lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
+				API_SELECT_CB_VAR_FREE(select_cb);
+				return -1;
+			}
 #endif /* LWIP_NETCONN_SEM_PER_THREAD */
 
-      lwip_link_select_cb(&API_SELECT_CB_VAR_REF(select_cb));
-
-      /* Increase select_waiting for each socket we are interested in */
-      maxfdp2 = maxfdp1;
-      for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
-        if ((readset && FD_ISSET(i, readset)) ||
-            (writeset && FD_ISSET(i, writeset)) ||
-            (exceptset && FD_ISSET(i, exceptset))) {
-          struct lwip_sock *sock;
-          SYS_ARCH_PROTECT(lev);
-          sock = tryget_socket_unconn_locked(i);
-          if (sock != NULL) {
-            sock->select_waiting++;
-            if (sock->select_waiting == 0) {
-              /* overflow - too many threads waiting */
-              sock->select_waiting--;
-              nready = -1;
-              maxfdp2 = i;
-              SYS_ARCH_UNPROTECT(lev);
-              done_socket(sock);
-              set_errno(EBUSY);
-              break;
-            }
-            SYS_ARCH_UNPROTECT(lev);
-            done_socket(sock);
-          } else {
-            /* Not a valid socket */
-            nready = -1;
-            maxfdp2 = i;
-            SYS_ARCH_UNPROTECT(lev);
-            set_errno(EBADF);
-            break;
-          }
-        }
-      }
-
-      if (nready >= 0) {
-        /* Call lwip_selscan again: there could have been events between
-           the last scan (without us on the list) and putting us on the list! */
-        nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
-        if (nready < 0) {
-          set_errno(EBADF);
-        } else if (!nready) {
-          /* Still none ready, just wait to be woken */
-          if (timeout == 0) {
-            /* Wait forever */
-            msectimeout = 0;
-          } else {
-            long msecs_long = ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500) / 1000));
-            if (msecs_long <= 0) {
-              /* Wait 1ms at least (0 means wait forever) */
-              msectimeout = 1;
-            } else {
-              msectimeout = (u32_t)msecs_long;
-            }
-          }
-
-          waitres = sys_arch_sem_wait(SELECT_SEM_PTR(API_SELECT_CB_VAR_REF(select_cb).sem), msectimeout);
+			lwip_link_select_cb(&API_SELECT_CB_VAR_REF(select_cb));
+
+			/* Increase select_waiting for each socket we are interested in */
+			maxfdp2 = maxfdp1;
+			for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++)
+			{
+				if ((readset && FD_ISSET(i, readset)) ||
+					(writeset && FD_ISSET(i, writeset)) ||
+					(exceptset && FD_ISSET(i, exceptset)))
+				{
+					struct lwip_sock *sock;
+					SYS_ARCH_PROTECT(lev);
+					sock = tryget_socket_unconn_locked(i);
+					if (sock != NULL)
+					{
+						sock->select_waiting++;
+						if (sock->select_waiting == 0)
+						{
+							/* overflow - too many threads waiting */
+							sock->select_waiting--;
+							nready = -1;
+							maxfdp2 = i;
+							SYS_ARCH_UNPROTECT(lev);
+							done_socket(sock);
+							set_errno(EBUSY);
+							break;
+						}
+						SYS_ARCH_UNPROTECT(lev);
+						done_socket(sock);
+					}
+					else
+					{
+						/* Not a valid socket */
+						nready = -1;
+						maxfdp2 = i;
+						SYS_ARCH_UNPROTECT(lev);
+						set_errno(EBADF);
+						break;
+					}
+				}
+			}
+
+			if (nready >= 0)
+			{
+				/* Call lwip_selscan again: there could have been events between
+				   the last scan (without us on the list) and putting us on the list! */
+				nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
+				if (nready < 0)
+				{
+					set_errno(EBADF);
+				}
+				else if (!nready)
+				{
+					/* Still none ready, just wait to be woken */
+					if (timeout == 0)
+					{
+						/* Wait forever */
+						msectimeout = 0;
+					}
+					else
+					{
+						long msecs_long = ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500) / 1000));
+						if (msecs_long <= 0)
+						{
+							/* Wait 1ms at least (0 means wait forever) */
+							msectimeout = 1;
+						}
+						else
+						{
+							msectimeout = (u32_t)msecs_long;
+						}
+					}
+
+					waitres = sys_arch_sem_wait(SELECT_SEM_PTR(API_SELECT_CB_VAR_REF(select_cb).sem), msectimeout);
 #if LWIP_NETCONN_SEM_PER_THREAD
-          waited = 1;
+					waited = 1;
 #endif
-        }
-      }
-
-      /* Decrease select_waiting for each socket we are interested in */
-      for (i = LWIP_SOCKET_OFFSET; i < maxfdp2; i++) {
-        if ((readset && FD_ISSET(i, readset)) ||
-            (writeset && FD_ISSET(i, writeset)) ||
-            (exceptset && FD_ISSET(i, exceptset))) {
-          struct lwip_sock *sock;
-          SYS_ARCH_PROTECT(lev);
-          sock = tryget_socket_unconn_nouse(i);
-          LWIP_ASSERT("socket gone at the end of select", sock != NULL);
-          if (sock != NULL) {
-            /* for now, handle select_waiting==0... */
-            LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
-            if (sock->select_waiting > 0) {
-              sock->select_waiting--;
-            }
-            SYS_ARCH_UNPROTECT(lev);
-          } else {
-            SYS_ARCH_UNPROTECT(lev);
-            /* Not a valid socket */
-            nready = -1;
-            set_errno(EBADF);
-          }
-        }
-      }
-
-      lwip_unlink_select_cb(&API_SELECT_CB_VAR_REF(select_cb));
+				}
+			}
+
+			/* Decrease select_waiting for each socket we are interested in */
+			for (i = LWIP_SOCKET_OFFSET; i < maxfdp2; i++)
+			{
+				if ((readset && FD_ISSET(i, readset)) ||
+					(writeset && FD_ISSET(i, writeset)) ||
+					(exceptset && FD_ISSET(i, exceptset)))
+				{
+					struct lwip_sock *sock;
+					SYS_ARCH_PROTECT(lev);
+					sock = tryget_socket_unconn_nouse(i);
+					LWIP_ASSERT("socket gone at the end of select", sock != NULL);
+					if (sock != NULL)
+					{
+						/* for now, handle select_waiting==0... */
+						LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
+						if (sock->select_waiting > 0)
+						{
+							sock->select_waiting--;
+						}
+						SYS_ARCH_UNPROTECT(lev);
+					}
+					else
+					{
+						SYS_ARCH_UNPROTECT(lev);
+						/* Not a valid socket */
+						nready = -1;
+						set_errno(EBADF);
+					}
+				}
+			}
+
+			lwip_unlink_select_cb(&API_SELECT_CB_VAR_REF(select_cb));
 
 #if LWIP_NETCONN_SEM_PER_THREAD
-      if (API_SELECT_CB_VAR_REF(select_cb).sem_signalled && (!waited || (waitres == SYS_ARCH_TIMEOUT))) {
-        /* don't leave the thread-local semaphore signalled */
-        sys_arch_sem_wait(API_SELECT_CB_VAR_REF(select_cb).sem, 1);
-      }
-#else /* LWIP_NETCONN_SEM_PER_THREAD */
-      sys_sem_free(&API_SELECT_CB_VAR_REF(select_cb).sem);
+			if (API_SELECT_CB_VAR_REF(select_cb).sem_signalled && (!waited || (waitres == SYS_ARCH_TIMEOUT)))
+			{
+				/* don't leave the thread-local semaphore signalled */
+				sys_arch_sem_wait(API_SELECT_CB_VAR_REF(select_cb).sem, 1);
+			}
+#else  /* LWIP_NETCONN_SEM_PER_THREAD */
+			sys_sem_free(&API_SELECT_CB_VAR_REF(select_cb).sem);
 #endif /* LWIP_NETCONN_SEM_PER_THREAD */
-      API_SELECT_CB_VAR_FREE(select_cb);
-
-      if (nready < 0) {
-        /* This happens when a socket got closed while waiting */
-        lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
-        return -1;
-      }
-
-      if (waitres == SYS_ARCH_TIMEOUT) {
-        /* Timeout */
-        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
-        /* This is OK as the local fdsets are empty and nready is zero,
-           or we would have returned earlier. */
-      } else {
-        /* See what's set now after waiting */
-        nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
-        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
-        if (nready < 0) {
-          set_errno(EBADF);
-          lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
-          return -1;
-        }
-      }
-    }
-  }
-
-  lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
-  set_errno(0);
-  if (readset) {
-    *readset = lreadset;
-  }
-  if (writeset) {
-    *writeset = lwriteset;
-  }
-  if (exceptset) {
-    *exceptset = lexceptset;
-  }
-  return nready;
+			API_SELECT_CB_VAR_FREE(select_cb);
+
+			if (nready < 0)
+			{
+				/* This happens when a socket got closed while waiting */
+				lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
+				return -1;
+			}
+
+			if (waitres == SYS_ARCH_TIMEOUT)
+			{
+				/* Timeout */
+				LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
+				/* This is OK as the local fdsets are empty and nready is zero,
+				   or we would have returned earlier. */
+			}
+			else
+			{
+				/* See what's set now after waiting */
+				nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
+				LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
+				if (nready < 0)
+				{
+					set_errno(EBADF);
+					lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
+					return -1;
+				}
+			}
+		}
+	}
+
+	lwip_select_dec_sockets_used(maxfdp1, &used_sockets);
+	set_errno(0);
+	if (readset)
+	{
+		*readset = lreadset;
+	}
+	if (writeset)
+	{
+		*writeset = lwriteset;
+	}
+	if (exceptset)
+	{
+		*exceptset = lexceptset;
+	}
+	return nready;
 }
 #endif /* LWIP_SOCKET_SELECT */
 
@@ -2175,14 +2445,14 @@ lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
 /** Options for the lwip_pollscan function. */
 enum lwip_pollscan_opts
 {
-  /** Clear revents in each struct pollfd. */
-  LWIP_POLLSCAN_CLEAR = 1,
+	/** Clear revents in each struct pollfd. */
+	LWIP_POLLSCAN_CLEAR = 1,
 
-  /** Increment select_waiting in each struct lwip_sock. */
-  LWIP_POLLSCAN_INC_WAIT = 2,
+	/** Increment select_waiting in each struct lwip_sock. */
+	LWIP_POLLSCAN_INC_WAIT = 2,
 
-  /** Decrement select_waiting in each struct lwip_sock. */
-  LWIP_POLLSCAN_DEC_WAIT = 4
+	/** Decrement select_waiting in each struct lwip_sock. */
+	LWIP_POLLSCAN_DEC_WAIT = 4
 };
 
 /**
@@ -2197,86 +2467,101 @@ enum lwip_pollscan_opts
 static int
 lwip_pollscan(struct pollfd *fds, nfds_t nfds, enum lwip_pollscan_opts opts)
 {
-  int nready = 0;
-  nfds_t fdi;
-  struct lwip_sock *sock;
-  SYS_ARCH_DECL_PROTECT(lev);
-
-  /* Go through each struct pollfd in the array. */
-  for (fdi = 0; fdi < nfds; fdi++) {
-    if ((opts & LWIP_POLLSCAN_CLEAR) != 0) {
-      fds[fdi].revents = 0;
-    }
-
-    /* Negative fd means the caller wants us to ignore this struct.
-       POLLNVAL means we already detected that the fd is invalid;
-       if another thread has since opened a new socket with that fd,
-       we must not use that socket. */
-    if (fds[fdi].fd >= 0 && (fds[fdi].revents & POLLNVAL) == 0) {
-      /* First get the socket's status (protected)... */
-      SYS_ARCH_PROTECT(lev);
-      sock = tryget_socket_unconn_locked(fds[fdi].fd);
-      if (sock != NULL) {
-        void* lastdata = sock->lastdata.pbuf;
-        s16_t rcvevent = sock->rcvevent;
-        u16_t sendevent = sock->sendevent;
-        u16_t errevent = sock->errevent;
-
-        if ((opts & LWIP_POLLSCAN_INC_WAIT) != 0) {
-          sock->select_waiting++;
-          if (sock->select_waiting == 0) {
-            /* overflow - too many threads waiting */
-            sock->select_waiting--;
-            nready = -1;
-            SYS_ARCH_UNPROTECT(lev);
-            done_socket(sock);
-            break;
-          }
-        } else if ((opts & LWIP_POLLSCAN_DEC_WAIT) != 0) {
-          /* for now, handle select_waiting==0... */
-          LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
-          if (sock->select_waiting > 0) {
-            sock->select_waiting--;
-          }
-        }
-        SYS_ARCH_UNPROTECT(lev);
-        done_socket(sock);
-
-        /* ... then examine it: */
-        /* See if netconn of this socket is ready for read */
-        if ((fds[fdi].events & POLLIN) != 0 && ((lastdata != NULL) || (rcvevent > 0))) {
-          fds[fdi].revents |= POLLIN;
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_pollscan: fd=%d ready for reading\n", fds[fdi].fd));
-        }
-        /* See if netconn of this socket is ready for write */
-        if ((fds[fdi].events & POLLOUT) != 0 && (sendevent != 0)) {
-          fds[fdi].revents |= POLLOUT;
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_pollscan: fd=%d ready for writing\n", fds[fdi].fd));
-        }
-        /* See if netconn of this socket had an error */
-        if (errevent != 0) {
-          /* POLLERR is output only. */
-          fds[fdi].revents |= POLLERR;
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_pollscan: fd=%d ready for exception\n", fds[fdi].fd));
-        }
-      } else {
-        /* Not a valid socket */
-        SYS_ARCH_UNPROTECT(lev);
-        /* POLLNVAL is output only. */
-        fds[fdi].revents |= POLLNVAL;
-        return -1;
-      }
-    }
-
-    /* Will return the number of structures that have events,
-       not the number of events. */
-    if (fds[fdi].revents != 0) {
-      nready++;
-    }
-  }
-
-  LWIP_ASSERT("nready >= 0", nready >= 0);
-  return nready;
+	int nready = 0;
+	nfds_t fdi;
+	struct lwip_sock *sock;
+	SYS_ARCH_DECL_PROTECT(lev);
+
+	/* Go through each struct pollfd in the array. */
+	for (fdi = 0; fdi < nfds; fdi++)
+	{
+		if ((opts & LWIP_POLLSCAN_CLEAR) != 0)
+		{
+			fds[fdi].revents = 0;
+		}
+
+		/* Negative fd means the caller wants us to ignore this struct.
+		   POLLNVAL means we already detected that the fd is invalid;
+		   if another thread has since opened a new socket with that fd,
+		   we must not use that socket. */
+		if (fds[fdi].fd >= 0 && (fds[fdi].revents & POLLNVAL) == 0)
+		{
+			/* First get the socket's status (protected)... */
+			SYS_ARCH_PROTECT(lev);
+			sock = tryget_socket_unconn_locked(fds[fdi].fd);
+			if (sock != NULL)
+			{
+				void *lastdata = sock->lastdata.pbuf;
+				s16_t rcvevent = sock->rcvevent;
+				u16_t sendevent = sock->sendevent;
+				u16_t errevent = sock->errevent;
+
+				if ((opts & LWIP_POLLSCAN_INC_WAIT) != 0)
+				{
+					sock->select_waiting++;
+					if (sock->select_waiting == 0)
+					{
+						/* overflow - too many threads waiting */
+						sock->select_waiting--;
+						nready = -1;
+						SYS_ARCH_UNPROTECT(lev);
+						done_socket(sock);
+						break;
+					}
+				}
+				else if ((opts & LWIP_POLLSCAN_DEC_WAIT) != 0)
+				{
+					/* for now, handle select_waiting==0... */
+					LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
+					if (sock->select_waiting > 0)
+					{
+						sock->select_waiting--;
+					}
+				}
+				SYS_ARCH_UNPROTECT(lev);
+				done_socket(sock);
+
+				/* ... then examine it: */
+				/* See if netconn of this socket is ready for read */
+				if ((fds[fdi].events & POLLIN) != 0 && ((lastdata != NULL) || (rcvevent > 0)))
+				{
+					fds[fdi].revents |= POLLIN;
+					LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_pollscan: fd=%d ready for reading\n", fds[fdi].fd));
+				}
+				/* See if netconn of this socket is ready for write */
+				if ((fds[fdi].events & POLLOUT) != 0 && (sendevent != 0))
+				{
+					fds[fdi].revents |= POLLOUT;
+					LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_pollscan: fd=%d ready for writing\n", fds[fdi].fd));
+				}
+				/* See if netconn of this socket had an error */
+				if (errevent != 0)
+				{
+					/* POLLERR is output only. */
+					fds[fdi].revents |= POLLERR;
+					LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_pollscan: fd=%d ready for exception\n", fds[fdi].fd));
+				}
+			}
+			else
+			{
+				/* Not a valid socket */
+				SYS_ARCH_UNPROTECT(lev);
+				/* POLLNVAL is output only. */
+				fds[fdi].revents |= POLLNVAL;
+				return -1;
+			}
+		}
+
+		/* Will return the number of structures that have events,
+		   not the number of events. */
+		if (fds[fdi].revents != 0)
+		{
+			nready++;
+		}
+	}
+
+	LWIP_ASSERT("nready >= 0", nready >= 0);
+	return nready;
 }
 
 #if LWIP_NETCONN_FULLDUPLEX
@@ -2288,151 +2573,167 @@ lwip_pollscan(struct pollfd *fds, nfds_t nfds, enum lwip_pollscan_opts opts)
 static void
 lwip_poll_inc_sockets_used(struct pollfd *fds, nfds_t nfds)
 {
-  nfds_t fdi;
-
-  if(fds) {
-    /* Go through each struct pollfd in the array. */
-    for (fdi = 0; fdi < nfds; fdi++) {
-      /* Increase the reference counter */
-      tryget_socket_unconn(fds[fdi].fd);
-    }
-  }
+	nfds_t fdi;
+
+	if (fds)
+	{
+		/* Go through each struct pollfd in the array. */
+		for (fdi = 0; fdi < nfds; fdi++)
+		{
+			/* Increase the reference counter */
+			tryget_socket_unconn(fds[fdi].fd);
+		}
+	}
 }
 
 /* Let go all sockets that were marked as used when starting poll */
 static void
 lwip_poll_dec_sockets_used(struct pollfd *fds, nfds_t nfds)
 {
-  nfds_t fdi;
-
-  if(fds) {
-    /* Go through each struct pollfd in the array. */
-    for (fdi = 0; fdi < nfds; fdi++) {
-      struct lwip_sock *sock = tryget_socket_unconn_nouse(fds[fdi].fd);
-      if (sock != NULL) {
-        done_socket(sock);
-      }
-    }
-  }
+	nfds_t fdi;
+
+	if (fds)
+	{
+		/* Go through each struct pollfd in the array. */
+		for (fdi = 0; fdi < nfds; fdi++)
+		{
+			struct lwip_sock *sock = tryget_socket_unconn_nouse(fds[fdi].fd);
+			if (sock != NULL)
+			{
+				done_socket(sock);
+			}
+		}
+	}
 }
 #else /* LWIP_NETCONN_FULLDUPLEX */
 #define lwip_poll_inc_sockets_used(fds, nfds)
 #define lwip_poll_dec_sockets_used(fds, nfds)
 #endif /* LWIP_NETCONN_FULLDUPLEX */
 
-int
-lwip_poll(struct pollfd *fds, nfds_t nfds, int timeout)
+int lwip_poll(struct pollfd *fds, nfds_t nfds, int timeout)
 {
-  u32_t waitres = 0;
-  int nready;
-  u32_t msectimeout;
+	u32_t waitres = 0;
+	int nready;
+	u32_t msectimeout;
 #if LWIP_NETCONN_SEM_PER_THREAD
-  int waited = 0;
+	int waited = 0;
 #endif
 
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll(%p, %d, %d)\n",
-                  (void*)fds, (int)nfds, timeout));
-  LWIP_ERROR("lwip_poll: invalid fds", ((fds != NULL && nfds > 0) || (fds == NULL && nfds == 0)),
-             set_errno(EINVAL); return -1;);
-
-  lwip_poll_inc_sockets_used(fds, nfds);
-
-  /* Go through each struct pollfd to count number of structures
-     which currently match */
-  nready = lwip_pollscan(fds, nfds, LWIP_POLLSCAN_CLEAR);
-
-  if (nready < 0) {
-    lwip_poll_dec_sockets_used(fds, nfds);
-    return -1;
-  }
-
-  /* If we don't have any current events, then suspend if we are supposed to */
-  if (!nready) {
-    API_SELECT_CB_VAR_DECLARE(select_cb);
-
-    if (timeout == 0) {
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll: no timeout, returning 0\n"));
-      goto return_success;
-    }
-    API_SELECT_CB_VAR_ALLOC(select_cb, set_errno(EAGAIN); lwip_poll_dec_sockets_used(fds, nfds); return -1);
-    memset(&API_SELECT_CB_VAR_REF(select_cb), 0, sizeof(struct lwip_select_cb));
-
-    /* None ready: add our semaphore to list:
-       We don't actually need any dynamic memory. Our entry on the
-       list is only valid while we are in this function, so it's ok
-       to use local variables. */
-
-    API_SELECT_CB_VAR_REF(select_cb).poll_fds = fds;
-    API_SELECT_CB_VAR_REF(select_cb).poll_nfds = nfds;
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll(%p, %d, %d)\n",
+								(void *)fds, (int)nfds, timeout));
+	LWIP_ERROR("lwip_poll: invalid fds", ((fds != NULL && nfds > 0) || (fds == NULL && nfds == 0)),
+			   set_errno(EINVAL);
+			   return -1;);
+
+	lwip_poll_inc_sockets_used(fds, nfds);
+
+	/* Go through each struct pollfd to count number of structures
+	   which currently match */
+	nready = lwip_pollscan(fds, nfds, LWIP_POLLSCAN_CLEAR);
+
+	if (nready < 0)
+	{
+		lwip_poll_dec_sockets_used(fds, nfds);
+		return -1;
+	}
+
+	/* If we don't have any current events, then suspend if we are supposed to */
+	if (!nready)
+	{
+		API_SELECT_CB_VAR_DECLARE(select_cb);
+
+		if (timeout == 0)
+		{
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll: no timeout, returning 0\n"));
+			goto return_success;
+		}
+		API_SELECT_CB_VAR_ALLOC(select_cb, set_errno(EAGAIN); lwip_poll_dec_sockets_used(fds, nfds); return -1);
+		memset(&API_SELECT_CB_VAR_REF(select_cb), 0, sizeof(struct lwip_select_cb));
+
+		/* None ready: add our semaphore to list:
+		   We don't actually need any dynamic memory. Our entry on the
+		   list is only valid while we are in this function, so it's ok
+		   to use local variables. */
+
+		API_SELECT_CB_VAR_REF(select_cb).poll_fds = fds;
+		API_SELECT_CB_VAR_REF(select_cb).poll_nfds = nfds;
 #if LWIP_NETCONN_SEM_PER_THREAD
-    API_SELECT_CB_VAR_REF(select_cb).sem = LWIP_NETCONN_THREAD_SEM_GET();
-#else /* LWIP_NETCONN_SEM_PER_THREAD */
-    if (sys_sem_new(&API_SELECT_CB_VAR_REF(select_cb).sem, 0) != ERR_OK) {
-      /* failed to create semaphore */
-      set_errno(EAGAIN);
-      lwip_poll_dec_sockets_used(fds, nfds);
-      API_SELECT_CB_VAR_FREE(select_cb);
-      return -1;
-    }
+		API_SELECT_CB_VAR_REF(select_cb).sem = LWIP_NETCONN_THREAD_SEM_GET();
+#else  /* LWIP_NETCONN_SEM_PER_THREAD */
+		if (sys_sem_new(&API_SELECT_CB_VAR_REF(select_cb).sem, 0) != ERR_OK)
+		{
+			/* failed to create semaphore */
+			set_errno(EAGAIN);
+			lwip_poll_dec_sockets_used(fds, nfds);
+			API_SELECT_CB_VAR_FREE(select_cb);
+			return -1;
+		}
 #endif /* LWIP_NETCONN_SEM_PER_THREAD */
 
-    lwip_link_select_cb(&API_SELECT_CB_VAR_REF(select_cb));
-
-    /* Increase select_waiting for each socket we are interested in.
-       Also, check for events again: there could have been events between
-       the last scan (without us on the list) and putting us on the list! */
-    nready = lwip_pollscan(fds, nfds, LWIP_POLLSCAN_INC_WAIT);
-
-    if (!nready) {
-      /* Still none ready, just wait to be woken */
-      if (timeout < 0) {
-        /* Wait forever */
-        msectimeout = 0;
-      } else {
-        /* timeout == 0 would have been handled earlier. */
-        LWIP_ASSERT("timeout > 0", timeout > 0);
-        msectimeout = timeout;
-      }
-      waitres = sys_arch_sem_wait(SELECT_SEM_PTR(API_SELECT_CB_VAR_REF(select_cb).sem), msectimeout);
+		lwip_link_select_cb(&API_SELECT_CB_VAR_REF(select_cb));
+
+		/* Increase select_waiting for each socket we are interested in.
+		   Also, check for events again: there could have been events between
+		   the last scan (without us on the list) and putting us on the list! */
+		nready = lwip_pollscan(fds, nfds, LWIP_POLLSCAN_INC_WAIT);
+
+		if (!nready)
+		{
+			/* Still none ready, just wait to be woken */
+			if (timeout < 0)
+			{
+				/* Wait forever */
+				msectimeout = 0;
+			}
+			else
+			{
+				/* timeout == 0 would have been handled earlier. */
+				LWIP_ASSERT("timeout > 0", timeout > 0);
+				msectimeout = timeout;
+			}
+			waitres = sys_arch_sem_wait(SELECT_SEM_PTR(API_SELECT_CB_VAR_REF(select_cb).sem), msectimeout);
 #if LWIP_NETCONN_SEM_PER_THREAD
-      waited = 1;
+			waited = 1;
 #endif
-    }
+		}
 
-    /* Decrease select_waiting for each socket we are interested in,
-       and check which events occurred while we waited. */
-    nready = lwip_pollscan(fds, nfds, LWIP_POLLSCAN_DEC_WAIT);
+		/* Decrease select_waiting for each socket we are interested in,
+		   and check which events occurred while we waited. */
+		nready = lwip_pollscan(fds, nfds, LWIP_POLLSCAN_DEC_WAIT);
 
-    lwip_unlink_select_cb(&API_SELECT_CB_VAR_REF(select_cb));
+		lwip_unlink_select_cb(&API_SELECT_CB_VAR_REF(select_cb));
 
 #if LWIP_NETCONN_SEM_PER_THREAD
-    if (select_cb.sem_signalled && (!waited || (waitres == SYS_ARCH_TIMEOUT))) {
-      /* don't leave the thread-local semaphore signalled */
-      sys_arch_sem_wait(API_SELECT_CB_VAR_REF(select_cb).sem, 1);
-    }
-#else /* LWIP_NETCONN_SEM_PER_THREAD */
-    sys_sem_free(&API_SELECT_CB_VAR_REF(select_cb).sem);
+		if (select_cb.sem_signalled && (!waited || (waitres == SYS_ARCH_TIMEOUT)))
+		{
+			/* don't leave the thread-local semaphore signalled */
+			sys_arch_sem_wait(API_SELECT_CB_VAR_REF(select_cb).sem, 1);
+		}
+#else  /* LWIP_NETCONN_SEM_PER_THREAD */
+		sys_sem_free(&API_SELECT_CB_VAR_REF(select_cb).sem);
 #endif /* LWIP_NETCONN_SEM_PER_THREAD */
-    API_SELECT_CB_VAR_FREE(select_cb);
-
-    if (nready < 0) {
-      /* This happens when a socket got closed while waiting */
-      lwip_poll_dec_sockets_used(fds, nfds);
-      return -1;
-    }
-
-    if (waitres == SYS_ARCH_TIMEOUT) {
-      /* Timeout */
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll: timeout expired\n"));
-      goto return_success;
-    }
-  }
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll: nready=%d\n", nready));
+		API_SELECT_CB_VAR_FREE(select_cb);
+
+		if (nready < 0)
+		{
+			/* This happens when a socket got closed while waiting */
+			lwip_poll_dec_sockets_used(fds, nfds);
+			return -1;
+		}
+
+		if (waitres == SYS_ARCH_TIMEOUT)
+		{
+			/* Timeout */
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll: timeout expired\n"));
+			goto return_success;
+		}
+	}
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_poll: nready=%d\n", nready));
 return_success:
-  lwip_poll_dec_sockets_used(fds, nfds);
-  set_errno(0);
-  return nready;
+	lwip_poll_dec_sockets_used(fds, nfds);
+	set_errno(0);
+	return nready;
 }
 
 /**
@@ -2442,26 +2743,31 @@ return_success:
 static int
 lwip_poll_should_wake(const struct lwip_select_cb *scb, int fd, int has_recvevent, int has_sendevent, int has_errevent)
 {
-  nfds_t fdi;
-  for (fdi = 0; fdi < scb->poll_nfds; fdi++) {
-    const struct pollfd *pollfd = &scb->poll_fds[fdi];
-    if (pollfd->fd == fd) {
-      /* Do not update pollfd->revents right here;
-         that would be a data race because lwip_pollscan
-         accesses revents without protecting. */
-      if (has_recvevent && (pollfd->events & POLLIN) != 0) {
-        return 1;
-      }
-      if (has_sendevent && (pollfd->events & POLLOUT) != 0) {
-        return 1;
-      }
-      if (has_errevent) {
-        /* POLLERR is output only. */
-        return 1;
-      }
-    }
-  }
-  return 0;
+	nfds_t fdi;
+	for (fdi = 0; fdi < scb->poll_nfds; fdi++)
+	{
+		const struct pollfd *pollfd = &scb->poll_fds[fdi];
+		if (pollfd->fd == fd)
+		{
+			/* Do not update pollfd->revents right here;
+			   that would be a data race because lwip_pollscan
+			   accesses revents without protecting. */
+			if (has_recvevent && (pollfd->events & POLLIN) != 0)
+			{
+				return 1;
+			}
+			if (has_sendevent && (pollfd->events & POLLOUT) != 0)
+			{
+				return 1;
+			}
+			if (has_errevent)
+			{
+				/* POLLERR is output only. */
+				return 1;
+			}
+		}
+	}
+	return 0;
 }
 #endif /* LWIP_SOCKET_POLL */
 
@@ -2481,90 +2787,103 @@ lwip_poll_should_wake(const struct lwip_select_cb *scb, int fd, int has_recveven
 static void
 event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
 {
-  int s, check_waiters;
-  struct lwip_sock *sock;
-  SYS_ARCH_DECL_PROTECT(lev);
-
-  LWIP_UNUSED_ARG(len);
-
-  /* Get socket */
-  if (conn) {
-    s = conn->socket;
-    if (s < 0) {
-      /* Data comes in right away after an accept, even though
-       * the server task might not have created a new socket yet.
-       * Just count down (or up) if that's the case and we
-       * will use the data later. Note that only receive events
-       * can happen before the new socket is set up. */
-      SYS_ARCH_PROTECT(lev);
-      if (conn->socket < 0) {
-        if (evt == NETCONN_EVT_RCVPLUS) {
-          /* conn->socket is -1 on initialization
-             lwip_accept adjusts sock->recvevent if conn->socket < -1 */
-          conn->socket--;
-        }
-        SYS_ARCH_UNPROTECT(lev);
-        return;
-      }
-      s = conn->socket;
-      SYS_ARCH_UNPROTECT(lev);
-    }
-
-    sock = get_socket(s);
-    if (!sock) {
-      return;
-    }
-  } else {
-    return;
-  }
-
-  check_waiters = 1;
-  SYS_ARCH_PROTECT(lev);
-  /* Set event as required */
-  switch (evt) {
-    case NETCONN_EVT_RCVPLUS:
-      sock->rcvevent++;
-      if (sock->rcvevent > 1) {
-        check_waiters = 0;
-      }
-      break;
-    case NETCONN_EVT_RCVMINUS:
-      sock->rcvevent--;
-      check_waiters = 0;
-      break;
-    case NETCONN_EVT_SENDPLUS:
-      if (sock->sendevent) {
-        check_waiters = 0;
-      }
-      sock->sendevent = 1;
-      break;
-    case NETCONN_EVT_SENDMINUS:
-      sock->sendevent = 0;
-      check_waiters = 0;
-      break;
-    case NETCONN_EVT_ERROR:
-      sock->errevent = 1;
-      break;
-    default:
-      LWIP_ASSERT("unknown event", 0);
-      break;
-  }
-
-  lwip_posix_socket_event_callback(sock, evt, len);
-
-  if (sock->select_waiting && check_waiters) {
-    /* Save which events are active */
-    int has_recvevent, has_sendevent, has_errevent;
-    has_recvevent = sock->rcvevent > 0;
-    has_sendevent = sock->sendevent != 0;
-    has_errevent = sock->errevent != 0;
-    SYS_ARCH_UNPROTECT(lev);
-    /* Check any select calls waiting on this socket */
-    select_check_waiters(s, has_recvevent, has_sendevent, has_errevent);
-  } else {
-    SYS_ARCH_UNPROTECT(lev);
-  }
-  done_socket(sock);
+	int s, check_waiters;
+	struct lwip_sock *sock;
+	SYS_ARCH_DECL_PROTECT(lev);
+
+	LWIP_UNUSED_ARG(len);
+
+	/* Get socket */
+	if (conn)
+	{
+		s = conn->socket;
+		if (s < 0)
+		{
+			/* Data comes in right away after an accept, even though
+			 * the server task might not have created a new socket yet.
+			 * Just count down (or up) if that's the case and we
+			 * will use the data later. Note that only receive events
+			 * can happen before the new socket is set up. */
+			SYS_ARCH_PROTECT(lev);
+			if (conn->socket < 0)
+			{
+				if (evt == NETCONN_EVT_RCVPLUS)
+				{
+					/* conn->socket is -1 on initialization
+					   lwip_accept adjusts sock->recvevent if conn->socket < -1 */
+					conn->socket--;
+				}
+				SYS_ARCH_UNPROTECT(lev);
+				return;
+			}
+			s = conn->socket;
+			SYS_ARCH_UNPROTECT(lev);
+		}
+
+		sock = get_socket(s);
+		if (!sock)
+		{
+			return;
+		}
+	}
+	else
+	{
+		return;
+	}
+
+	check_waiters = 1;
+	SYS_ARCH_PROTECT(lev);
+	/* Set event as required */
+	switch (evt)
+	{
+	case NETCONN_EVT_RCVPLUS:
+		sock->rcvevent++;
+		if (sock->rcvevent > 1)
+		{
+			check_waiters = 0;
+		}
+		break;
+	case NETCONN_EVT_RCVMINUS:
+		sock->rcvevent--;
+		check_waiters = 0;
+		break;
+	case NETCONN_EVT_SENDPLUS:
+		if (sock->sendevent)
+		{
+			check_waiters = 0;
+		}
+		sock->sendevent = 1;
+		break;
+	case NETCONN_EVT_SENDMINUS:
+		sock->sendevent = 0;
+		check_waiters = 0;
+		break;
+	case NETCONN_EVT_ERROR:
+		sock->errevent = 1;
+		break;
+	default:
+		LWIP_ASSERT("unknown event", 0);
+		break;
+	}
+
+	lwip_posix_socket_event_callback(sock, evt, len);
+
+	if (sock->select_waiting && check_waiters)
+	{
+		/* Save which events are active */
+		int has_recvevent, has_sendevent, has_errevent;
+		has_recvevent = sock->rcvevent > 0;
+		has_sendevent = sock->sendevent != 0;
+		has_errevent = sock->errevent != 0;
+		SYS_ARCH_UNPROTECT(lev);
+		/* Check any select calls waiting on this socket */
+		select_check_waiters(s, has_recvevent, has_sendevent, has_errevent);
+	}
+	else
+	{
+		SYS_ARCH_UNPROTECT(lev);
+	}
+	done_socket(sock);
 }
 
 /**
@@ -2582,75 +2901,86 @@ event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
  */
 static void select_check_waiters(int s, int has_recvevent, int has_sendevent, int has_errevent)
 {
-  struct lwip_select_cb *scb;
+	struct lwip_select_cb *scb;
 #if !LWIP_TCPIP_CORE_LOCKING
-  int last_select_cb_ctr;
-  SYS_ARCH_DECL_PROTECT(lev);
+	int last_select_cb_ctr;
+	SYS_ARCH_DECL_PROTECT(lev);
 #endif /* !LWIP_TCPIP_CORE_LOCKING */
 
-  LWIP_ASSERT_CORE_LOCKED();
+	LWIP_ASSERT_CORE_LOCKED();
 
 #if !LWIP_TCPIP_CORE_LOCKING
-  SYS_ARCH_PROTECT(lev);
+	SYS_ARCH_PROTECT(lev);
 again:
-  /* remember the state of select_cb_list to detect changes */
-  last_select_cb_ctr = select_cb_ctr;
+	/* remember the state of select_cb_list to detect changes */
+	last_select_cb_ctr = select_cb_ctr;
 #endif /* !LWIP_TCPIP_CORE_LOCKING */
-  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
-    if (scb->sem_signalled == 0) {
-      /* semaphore not signalled yet */
-      int do_signal = 0;
+	for (scb = select_cb_list; scb != NULL; scb = scb->next)
+	{
+		if (scb->sem_signalled == 0)
+		{
+			/* semaphore not signalled yet */
+			int do_signal = 0;
 #if LWIP_SOCKET_POLL
-      if (scb->poll_fds != NULL) {
-        do_signal = lwip_poll_should_wake(scb, s, has_recvevent, has_sendevent, has_errevent);
-      }
+			if (scb->poll_fds != NULL)
+			{
+				do_signal = lwip_poll_should_wake(scb, s, has_recvevent, has_sendevent, has_errevent);
+			}
 #endif /* LWIP_SOCKET_POLL */
 #if LWIP_SOCKET_SELECT && LWIP_SOCKET_POLL
-      else
+			else
 #endif /* LWIP_SOCKET_SELECT && LWIP_SOCKET_POLL */
 #if LWIP_SOCKET_SELECT
-      {
-        /* Test this select call for our socket */
-        if (has_recvevent) {
-          if (scb->readset && FD_ISSET(s, scb->readset)) {
-            do_signal = 1;
-          }
-        }
-        if (has_sendevent) {
-          if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
-            do_signal = 1;
-          }
-        }
-        if (has_errevent) {
-          if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
-            do_signal = 1;
-          }
-        }
-      }
+			{
+				/* Test this select call for our socket */
+				if (has_recvevent)
+				{
+					if (scb->readset && FD_ISSET(s, scb->readset))
+					{
+						do_signal = 1;
+					}
+				}
+				if (has_sendevent)
+				{
+					if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset))
+					{
+						do_signal = 1;
+					}
+				}
+				if (has_errevent)
+				{
+					if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset))
+					{
+						do_signal = 1;
+					}
+				}
+			}
 #endif /* LWIP_SOCKET_SELECT */
-      if (do_signal) {
-        scb->sem_signalled = 1;
-        /* For !LWIP_TCPIP_CORE_LOCKING, we don't call SYS_ARCH_UNPROTECT() before signaling
-           the semaphore, as this might lead to the select thread taking itself off the list,
-           invalidating the semaphore. */
-        sys_sem_signal(SELECT_SEM_PTR(scb->sem));
-      }
-    }
+			if (do_signal)
+			{
+				scb->sem_signalled = 1;
+				/* For !LWIP_TCPIP_CORE_LOCKING, we don't call SYS_ARCH_UNPROTECT() before signaling
+				   the semaphore, as this might lead to the select thread taking itself off the list,
+				   invalidating the semaphore. */
+				sys_sem_signal(SELECT_SEM_PTR(scb->sem));
+			}
+		}
 #if LWIP_TCPIP_CORE_LOCKING
-  }
+	}
 #else
-    /* unlock interrupts with each step */
-    SYS_ARCH_UNPROTECT(lev);
-    /* this makes sure interrupt protection time is short */
-    SYS_ARCH_PROTECT(lev);
-    if (last_select_cb_ctr != select_cb_ctr) {
-      /* someone has changed select_cb_list, restart at the beginning */
-      goto again;
-    }
-    /* remember the state of select_cb_list to detect changes */
-    last_select_cb_ctr = select_cb_ctr;
-  }
-  SYS_ARCH_UNPROTECT(lev);
+		/* unlock interrupts with each step */
+		SYS_ARCH_UNPROTECT(lev);
+		/* this makes sure interrupt protection time is short */
+		SYS_ARCH_PROTECT(lev);
+		if (last_select_cb_ctr != select_cb_ctr)
+		{
+			/* someone has changed select_cb_list, restart at the beginning */
+			goto again;
+		}
+		/* remember the state of select_cb_list to detect changes */
+		last_select_cb_ctr = select_cb_ctr;
+	}
+	SYS_ARCH_UNPROTECT(lev);
 #endif
 }
 #endif /* LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL */
@@ -2658,182 +2988,197 @@ again:
 /**
  * Close one end of a full-duplex connection.
  */
-int
-lwip_shutdown(int s, int how)
+int lwip_shutdown(int s, int how)
 {
-  struct lwip_sock *sock;
-  err_t err;
-  u8_t shut_rx = 0, shut_tx = 0;
-
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
-
-  sock = get_socket(s);
-  if (!sock) {
-    return -1;
-  }
-
-  if (sock->conn != NULL) {
-    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
-      sock_set_errno(sock, EOPNOTSUPP);
-      done_socket(sock);
-      return -1;
-    }
-  } else {
-    sock_set_errno(sock, ENOTCONN);
-    done_socket(sock);
-    return -1;
-  }
-
-  if (how == SHUT_RD) {
-    shut_rx = 1;
-  } else if (how == SHUT_WR) {
-    shut_tx = 1;
-  } else if (how == SHUT_RDWR) {
-    shut_rx = 1;
-    shut_tx = 1;
-  } else {
-    sock_set_errno(sock, EINVAL);
-    done_socket(sock);
-    return -1;
-  }
-  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
-
-  sock_set_errno(sock, err_to_errno(err));
-  done_socket(sock);
-  return (err == ERR_OK ? 0 : -1);
+	struct lwip_sock *sock;
+	err_t err;
+	u8_t shut_rx = 0, shut_tx = 0;
+
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
+
+	sock = get_socket(s);
+	if (!sock)
+	{
+		return -1;
+	}
+
+	if (sock->conn != NULL)
+	{
+		if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP)
+		{
+			sock_set_errno(sock, EOPNOTSUPP);
+			done_socket(sock);
+			return -1;
+		}
+	}
+	else
+	{
+		sock_set_errno(sock, ENOTCONN);
+		done_socket(sock);
+		return -1;
+	}
+
+	if (how == SHUT_RD)
+	{
+		shut_rx = 1;
+	}
+	else if (how == SHUT_WR)
+	{
+		shut_tx = 1;
+	}
+	else if (how == SHUT_RDWR)
+	{
+		shut_rx = 1;
+		shut_tx = 1;
+	}
+	else
+	{
+		sock_set_errno(sock, EINVAL);
+		done_socket(sock);
+		return -1;
+	}
+	err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
+
+	sock_set_errno(sock, err_to_errno(err));
+	done_socket(sock);
+	return (err == ERR_OK ? 0 : -1);
 }
 
 static int
 lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
 {
-  struct lwip_sock *sock;
-  union sockaddr_aligned saddr;
-  ip_addr_t naddr;
-  u16_t port;
-  err_t err;
-
-  sock = get_socket(s);
-  if (!sock) {
-    return -1;
-  }
-
-  /* get the IP address and port */
-  err = netconn_getaddr(sock->conn, &naddr, &port, local);
-  if (err != ERR_OK) {
-    sock_set_errno(sock, err_to_errno(err));
-    done_socket(sock);
-    return -1;
-  }
+	struct lwip_sock *sock;
+	union sockaddr_aligned saddr;
+	ip_addr_t naddr;
+	u16_t port;
+	err_t err;
+
+	sock = get_socket(s);
+	if (!sock)
+	{
+		return -1;
+	}
+
+	/* get the IP address and port */
+	err = netconn_getaddr(sock->conn, &naddr, &port, local);
+	if (err != ERR_OK)
+	{
+		sock_set_errno(sock, err_to_errno(err));
+		done_socket(sock);
+		return -1;
+	}
 
 #if LWIP_IPV4 && LWIP_IPV6
-  /* Dual-stack: Map IPv4 addresses to IPv4 mapped IPv6 */
-  if (NETCONNTYPE_ISIPV6(netconn_type(sock->conn)) &&
-      IP_IS_V4_VAL(naddr)) {
-    ip4_2_ipv4_mapped_ipv6(ip_2_ip6(&naddr), ip_2_ip4(&naddr));
-    IP_SET_TYPE_VAL(naddr, IPADDR_TYPE_V6);
-  }
+	/* Dual-stack: Map IPv4 addresses to IPv4 mapped IPv6 */
+	if (NETCONNTYPE_ISIPV6(netconn_type(sock->conn)) &&
+		IP_IS_V4_VAL(naddr))
+	{
+		ip4_2_ipv4_mapped_ipv6(ip_2_ip6(&naddr), ip_2_ip4(&naddr));
+		IP_SET_TYPE_VAL(naddr, IPADDR_TYPE_V6);
+	}
 #endif /* LWIP_IPV4 && LWIP_IPV6 */
 
-  IPADDR_PORT_TO_SOCKADDR(&saddr, &naddr, port);
+	IPADDR_PORT_TO_SOCKADDR(&saddr, &naddr, port);
 
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
-  ip_addr_debug_print_val(SOCKETS_DEBUG, naddr);
-  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", port));
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
+	ip_addr_debug_print_val(SOCKETS_DEBUG, naddr);
+	LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%" U16_F ")\n", port));
 
-  MEMCPY(name, &saddr, *namelen);
+	MEMCPY(name, &saddr, *namelen);
 
-  sock_set_errno(sock, 0);
-  done_socket(sock);
-  return 0;
+	sock_set_errno(sock, 0);
+	done_socket(sock);
+	return 0;
 }
 
-int
-lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
+int lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
 {
-  return lwip_getaddrname(s, name, namelen, 0);
+	return lwip_getaddrname(s, name, namelen, 0);
 }
 
-int
-lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
+int lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
 {
-  return lwip_getaddrname(s, name, namelen, 1);
+	return lwip_getaddrname(s, name, namelen, 1);
 }
 
-int
-lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
+int lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
 {
-  int err;
-  struct lwip_sock *sock = get_socket(s);
+	int err;
+	struct lwip_sock *sock = get_socket(s);
 #if !LWIP_TCPIP_CORE_LOCKING
-  err_t cberr;
-  LWIP_SETGETSOCKOPT_DATA_VAR_DECLARE(data);
+	err_t cberr;
+	LWIP_SETGETSOCKOPT_DATA_VAR_DECLARE(data);
 #endif /* !LWIP_TCPIP_CORE_LOCKING */
 
-  if (!sock) {
-    return -1;
-  }
+	if (!sock)
+	{
+		return -1;
+	}
 
-  if ((NULL == optval) || (NULL == optlen)) {
-    sock_set_errno(sock, EFAULT);
-    done_socket(sock);
-    return -1;
-  }
+	if ((NULL == optval) || (NULL == optlen))
+	{
+		sock_set_errno(sock, EFAULT);
+		done_socket(sock);
+		return -1;
+	}
 
 #if LWIP_TCPIP_CORE_LOCKING
-  /* core-locking can just call the -impl function */
-  LOCK_TCPIP_CORE();
-  err = lwip_getsockopt_impl(s, level, optname, optval, optlen);
-  UNLOCK_TCPIP_CORE();
+	/* core-locking can just call the -impl function */
+	LOCK_TCPIP_CORE();
+	err = lwip_getsockopt_impl(s, level, optname, optval, optlen);
+	UNLOCK_TCPIP_CORE();
 
 #else /* LWIP_TCPIP_CORE_LOCKING */
 
 #if LWIP_MPU_COMPATIBLE
-  /* MPU_COMPATIBLE copies the optval data, so check for max size here */
-  if (*optlen > LWIP_SETGETSOCKOPT_MAXOPTLEN) {
-    sock_set_errno(sock, ENOBUFS);
-    done_socket(sock);
-    return -1;
-  }
+	/* MPU_COMPATIBLE copies the optval data, so check for max size here */
+	if (*optlen > LWIP_SETGETSOCKOPT_MAXOPTLEN)
+	{
+		sock_set_errno(sock, ENOBUFS);
+		done_socket(sock);
+		return -1;
+	}
 #endif /* LWIP_MPU_COMPATIBLE */
 
-  LWIP_SETGETSOCKOPT_DATA_VAR_ALLOC(data, sock);
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).s = s;
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).level = level;
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optname = optname;
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen = *optlen;
+	LWIP_SETGETSOCKOPT_DATA_VAR_ALLOC(data, sock);
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).s = s;
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).level = level;
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optname = optname;
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen = *optlen;
 #if !LWIP_MPU_COMPATIBLE
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optval.p = optval;
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optval.p = optval;
 #endif /* !LWIP_MPU_COMPATIBLE */
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err = 0;
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err = 0;
 #if LWIP_NETCONN_SEM_PER_THREAD
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem = LWIP_NETCONN_THREAD_SEM_GET();
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem = LWIP_NETCONN_THREAD_SEM_GET();
 #else
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem = &sock->conn->op_completed;
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem = &sock->conn->op_completed;
 #endif
-  cberr = tcpip_callback(lwip_getsockopt_callback, &LWIP_SETGETSOCKOPT_DATA_VAR_REF(data));
-  if (cberr != ERR_OK) {
-    LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
-    sock_set_errno(sock, err_to_errno(cberr));
-    done_socket(sock);
-    return -1;
-  }
-  sys_arch_sem_wait((sys_sem_t *)(LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem), 0);
-
-  /* write back optlen and optval */
-  *optlen = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen;
+	cberr = tcpip_callback(lwip_getsockopt_callback, &LWIP_SETGETSOCKOPT_DATA_VAR_REF(data));
+	if (cberr != ERR_OK)
+	{
+		LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
+		sock_set_errno(sock, err_to_errno(cberr));
+		done_socket(sock);
+		return -1;
+	}
+	sys_arch_sem_wait((sys_sem_t *)(LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem), 0);
+
+	/* write back optlen and optval */
+	*optlen = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen;
 #if LWIP_MPU_COMPATIBLE
-  MEMCPY(optval, LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optval,
-         LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen);
+	MEMCPY(optval, LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optval,
+		   LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen);
 #endif /* LWIP_MPU_COMPATIBLE */
 
-  /* maybe lwip_getsockopt_internal has changed err */
-  err = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err;
-  LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
+	/* maybe lwip_getsockopt_internal has changed err */
+	err = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err;
+	LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
 #endif /* LWIP_TCPIP_CORE_LOCKING */
 
-  sock_set_errno(sock, err);
-  done_socket(sock);
-  return err ? -1 : 0;
+	sock_set_errno(sock, err);
+	done_socket(sock);
+	return err ? -1 : 0;
 }
 
 #if !LWIP_TCPIP_CORE_LOCKING
@@ -2843,40 +3188,41 @@ lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
 static void
 lwip_getsockopt_callback(void *arg)
 {
-  struct lwip_setgetsockopt_data *data;
-  LWIP_ASSERT("arg != NULL", arg != NULL);
-  data = (struct lwip_setgetsockopt_data *)arg;
+	struct lwip_setgetsockopt_data *data;
+	LWIP_ASSERT("arg != NULL", arg != NULL);
+	data = (struct lwip_setgetsockopt_data *)arg;
 
-  data->err = lwip_getsockopt_impl(data->s, data->level, data->optname,
+	data->err = lwip_getsockopt_impl(data->s, data->level, data->optname,
 #if LWIP_MPU_COMPATIBLE
-                                   data->optval,
-#else /* LWIP_MPU_COMPATIBLE */
-                                   data->optval.p,
+									 data->optval,
+#else  /* LWIP_MPU_COMPATIBLE */
+									 data->optval.p,
 #endif /* LWIP_MPU_COMPATIBLE */
-                                   &data->optlen);
+									 &data->optlen);
 
-  sys_sem_signal((sys_sem_t *)(data->completed_sem));
+	sys_sem_signal((sys_sem_t *)(data->completed_sem));
 }
-#endif  /* LWIP_TCPIP_CORE_LOCKING */
+#endif /* LWIP_TCPIP_CORE_LOCKING */
 
 static int
 lwip_sockopt_to_ipopt(int optname)
 {
-  /* Map SO_* values to our internal SOF_* values
-   * We should not rely on #defines in socket.h
-   * being in sync with ip.h.
-   */
-  switch (optname) {
-  case SO_BROADCAST:
-    return SOF_BROADCAST;
-  case SO_KEEPALIVE:
-    return SOF_KEEPALIVE;
-  case SO_REUSEADDR:
-    return SOF_REUSEADDR;
-  default:
-    LWIP_ASSERT("Unknown socket option", 0);
-    return 0;
-  }
+	/* Map SO_* values to our internal SOF_* values
+	 * We should not rely on #defines in socket.h
+	 * being in sync with ip.h.
+	 */
+	switch (optname)
+	{
+	case SO_BROADCAST:
+		return SOF_BROADCAST;
+	case SO_KEEPALIVE:
+		return SOF_KEEPALIVE;
+	case SO_REUSEADDR:
+		return SOF_REUSEADDR;
+	default:
+		LWIP_ASSERT("Unknown socket option", 0);
+		return 0;
+	}
 }
 
 /** lwip_getsockopt_impl: the actual implementation of getsockopt:
@@ -2885,396 +3231,429 @@ lwip_sockopt_to_ipopt(int optname)
 static int
 lwip_getsockopt_impl(int s, int level, int optname, void *optval, socklen_t *optlen)
 {
-  int err = 0;
-  struct lwip_sock *sock = tryget_socket(s);
-  if (!sock) {
-    return EBADF;
-  }
+	int err = 0;
+	struct lwip_sock *sock = tryget_socket(s);
+	if (!sock)
+	{
+		return EBADF;
+	}
 
 #ifdef LWIP_HOOK_SOCKETS_GETSOCKOPT
-  if (LWIP_HOOK_SOCKETS_GETSOCKOPT(s, sock, level, optname, optval, optlen, &err)) {
-    return err;
-  }
+	if (LWIP_HOOK_SOCKETS_GETSOCKOPT(s, sock, level, optname, optval, optlen, &err))
+	{
+		return err;
+	}
 #endif
 
-  switch (level) {
+	switch (level)
+	{
 
-    /* Level: SOL_SOCKET */
-    case SOL_SOCKET:
-      switch (optname) {
+	/* Level: SOL_SOCKET */
+	case SOL_SOCKET:
+		switch (optname)
+		{
 
 #if LWIP_TCP
-        case SO_ACCEPTCONN:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
-          if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_TCP) {
-            done_socket(sock);
-            return ENOPROTOOPT;
-          }
-          if ((sock->conn->pcb.tcp != NULL) && (sock->conn->pcb.tcp->state == LISTEN)) {
-            *(int *)optval = 1;
-          } else {
-            *(int *)optval = 0;
-          }
-          break;
+		case SO_ACCEPTCONN:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
+			if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_TCP)
+			{
+				done_socket(sock);
+				return ENOPROTOOPT;
+			}
+			if ((sock->conn->pcb.tcp != NULL) && (sock->conn->pcb.tcp->state == LISTEN))
+			{
+				*(int *)optval = 1;
+			}
+			else
+			{
+				*(int *)optval = 0;
+			}
+			break;
 #endif /* LWIP_TCP */
 
-        /* The option flags */
-        case SO_BROADCAST:
-        case SO_KEEPALIVE:
+		/* The option flags */
+		case SO_BROADCAST:
+		case SO_KEEPALIVE:
 #if SO_REUSE
-        case SO_REUSEADDR:
+		case SO_REUSEADDR:
 #endif /* SO_REUSE */
-          if ((optname == SO_BROADCAST) &&
-              (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP)) {
-            done_socket(sock);
-            return ENOPROTOOPT;
-          }
-
-          optname = lwip_sockopt_to_ipopt(optname);
-
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
-          *(int *)optval = ip_get_option(sock->conn->pcb.ip, optname);
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
-                                      s, optname, (*(int *)optval ? "on" : "off")));
-          break;
-
-        case SO_TYPE:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, int);
-          switch (NETCONNTYPE_GROUP(netconn_type(sock->conn))) {
-            case NETCONN_RAW:
-              *(int *)optval = SOCK_RAW;
-              break;
-            case NETCONN_TCP:
-              *(int *)optval = SOCK_STREAM;
-              break;
-            case NETCONN_UDP:
-              *(int *)optval = SOCK_DGRAM;
-              break;
-            default: /* unrecognized socket type */
-              *(int *)optval = netconn_type(sock->conn);
-              LWIP_DEBUGF(SOCKETS_DEBUG,
-                          ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
-                           s, *(int *)optval));
-          }  /* switch (netconn_type(sock->conn)) */
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
-                                      s, *(int *)optval));
-          break;
-
-        case SO_ERROR:
-          LWIP_SOCKOPT_CHECK_OPTLEN(sock, *optlen, int);
-          *(int *)optval = err_to_errno(netconn_err(sock->conn));
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
-                                      s, *(int *)optval));
-          break;
+			if ((optname == SO_BROADCAST) &&
+				(NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP))
+			{
+				done_socket(sock);
+				return ENOPROTOOPT;
+			}
+
+			optname = lwip_sockopt_to_ipopt(optname);
+
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
+			*(int *)optval = ip_get_option(sock->conn->pcb.ip, optname);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
+										s, optname, (*(int *)optval ? "on" : "off")));
+			break;
+
+		case SO_TYPE:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, int);
+			switch (NETCONNTYPE_GROUP(netconn_type(sock->conn)))
+			{
+			case NETCONN_RAW:
+				*(int *)optval = SOCK_RAW;
+				break;
+			case NETCONN_TCP:
+				*(int *)optval = SOCK_STREAM;
+				break;
+			case NETCONN_UDP:
+				*(int *)optval = SOCK_DGRAM;
+				break;
+			default: /* unrecognized socket type */
+				*(int *)optval = netconn_type(sock->conn);
+				LWIP_DEBUGF(SOCKETS_DEBUG,
+							("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
+							 s, *(int *)optval));
+			} /* switch (netconn_type(sock->conn)) */
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
+										s, *(int *)optval));
+			break;
+
+		case SO_ERROR:
+			LWIP_SOCKOPT_CHECK_OPTLEN(sock, *optlen, int);
+			*(int *)optval = err_to_errno(netconn_err(sock->conn));
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
+										s, *(int *)optval));
+			break;
 
 #if LWIP_SO_SNDTIMEO
-        case SO_SNDTIMEO:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
-          LWIP_SO_SNDRCVTIMEO_SET(optval, netconn_get_sendtimeout(sock->conn));
-          break;
+		case SO_SNDTIMEO:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
+			LWIP_SO_SNDRCVTIMEO_SET(optval, netconn_get_sendtimeout(sock->conn));
+			break;
 #endif /* LWIP_SO_SNDTIMEO */
 #if LWIP_SO_RCVTIMEO
-        case SO_RCVTIMEO:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
-          LWIP_SO_SNDRCVTIMEO_SET(optval, netconn_get_recvtimeout(sock->conn));
-          break;
+		case SO_RCVTIMEO:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
+			LWIP_SO_SNDRCVTIMEO_SET(optval, netconn_get_recvtimeout(sock->conn));
+			break;
 #endif /* LWIP_SO_RCVTIMEO */
 #if LWIP_SO_RCVBUF
-        case SO_RCVBUF:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, int);
-          *(int *)optval = netconn_get_recvbufsize(sock->conn);
-          break;
+		case SO_RCVBUF:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, int);
+			*(int *)optval = netconn_get_recvbufsize(sock->conn);
+			break;
 #endif /* LWIP_SO_RCVBUF */
 #if LWIP_SO_LINGER
-        case SO_LINGER: {
-          s16_t conn_linger;
-          struct linger *linger = (struct linger *)optval;
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, struct linger);
-          conn_linger = sock->conn->linger;
-          if (conn_linger >= 0) {
-            linger->l_onoff = 1;
-            linger->l_linger = (int)conn_linger;
-          } else {
-            linger->l_onoff = 0;
-            linger->l_linger = 0;
-          }
-        }
-        break;
+		case SO_LINGER:
+		{
+			s16_t conn_linger;
+			struct linger *linger = (struct linger *)optval;
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, struct linger);
+			conn_linger = sock->conn->linger;
+			if (conn_linger >= 0)
+			{
+				linger->l_onoff = 1;
+				linger->l_linger = (int)conn_linger;
+			}
+			else
+			{
+				linger->l_onoff = 0;
+				linger->l_linger = 0;
+			}
+		}
+		break;
 #endif /* LWIP_SO_LINGER */
 #if LWIP_UDP
-        case SO_NO_CHECK:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, *optlen, int, NETCONN_UDP);
+		case SO_NO_CHECK:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, *optlen, int, NETCONN_UDP);
 #if LWIP_UDPLITE
-          if (udp_is_flag_set(sock->conn->pcb.udp, UDP_FLAGS_UDPLITE)) {
-            /* this flag is only available for UDP, not for UDP lite */
-            done_socket(sock);
-            return EAFNOSUPPORT;
-          }
+			if (udp_is_flag_set(sock->conn->pcb.udp, UDP_FLAGS_UDPLITE))
+			{
+				/* this flag is only available for UDP, not for UDP lite */
+				done_socket(sock);
+				return EAFNOSUPPORT;
+			}
 #endif /* LWIP_UDPLITE */
-          *(int *)optval = udp_is_flag_set(sock->conn->pcb.udp, UDP_FLAGS_NOCHKSUM) ? 1 : 0;
-          break;
+			*(int *)optval = udp_is_flag_set(sock->conn->pcb.udp, UDP_FLAGS_NOCHKSUM) ? 1 : 0;
+			break;
 #endif /* LWIP_UDP*/
-        default:
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
-                                      s, optname));
-          err = ENOPROTOOPT;
-          break;
-      }  /* switch (optname) */
-      break;
-
-    /* Level: IPPROTO_IP */
-    case IPPROTO_IP:
-      switch (optname) {
-        case IP_TTL:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
-          *(int *)optval = sock->conn->pcb.ip->ttl;
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
-                                      s, *(int *)optval));
-          break;
-        case IP_TOS:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
-          *(int *)optval = sock->conn->pcb.ip->tos;
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
-                                      s, *(int *)optval));
-          break;
+		default:
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
+										s, optname));
+			err = ENOPROTOOPT;
+			break;
+		} /* switch (optname) */
+		break;
+
+	/* Level: IPPROTO_IP */
+	case IPPROTO_IP:
+		switch (optname)
+		{
+		case IP_TTL:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
+			*(int *)optval = sock->conn->pcb.ip->ttl;
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
+										s, *(int *)optval));
+			break;
+		case IP_TOS:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
+			*(int *)optval = sock->conn->pcb.ip->tos;
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
+										s, *(int *)optval));
+			break;
 #if LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS && LWIP_UDP
-        case IP_MULTICAST_TTL:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, u8_t);
-          if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_UDP) {
-            done_socket(sock);
-            return ENOPROTOOPT;
-          }
-          *(u8_t *)optval = udp_get_multicast_ttl(sock->conn->pcb.udp);
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_TTL) = %d\n",
-                                      s, *(int *)optval));
-          break;
-        case IP_MULTICAST_IF:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, struct in_addr);
-          if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_UDP) {
-            done_socket(sock);
-            return ENOPROTOOPT;
-          }
-          inet_addr_from_ip4addr((struct in_addr *)optval, udp_get_multicast_netif_addr(sock->conn->pcb.udp));
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%"X32_F"\n",
-                                      s, *(u32_t *)optval));
-          break;
-        case IP_MULTICAST_LOOP:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, u8_t);
-          if ((sock->conn->pcb.udp->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) {
-            *(u8_t *)optval = 1;
-          } else {
-            *(u8_t *)optval = 0;
-          }
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_LOOP) = %d\n",
-                                      s, *(int *)optval));
-          break;
+		case IP_MULTICAST_TTL:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, u8_t);
+			if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_UDP)
+			{
+				done_socket(sock);
+				return ENOPROTOOPT;
+			}
+			*(u8_t *)optval = udp_get_multicast_ttl(sock->conn->pcb.udp);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_TTL) = %d\n",
+										s, *(int *)optval));
+			break;
+		case IP_MULTICAST_IF:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, struct in_addr);
+			if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_UDP)
+			{
+				done_socket(sock);
+				return ENOPROTOOPT;
+			}
+			inet_addr_from_ip4addr((struct in_addr *)optval, udp_get_multicast_netif_addr(sock->conn->pcb.udp));
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%" X32_F "\n",
+										s, *(u32_t *)optval));
+			break;
+		case IP_MULTICAST_LOOP:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, u8_t);
+			if ((sock->conn->pcb.udp->flags & UDP_FLAGS_MULTICAST_LOOP) != 0)
+			{
+				*(u8_t *)optval = 1;
+			}
+			else
+			{
+				*(u8_t *)optval = 0;
+			}
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_LOOP) = %d\n",
+										s, *(int *)optval));
+			break;
 #endif /* LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS && LWIP_UDP */
-        default:
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
-                                      s, optname));
-          err = ENOPROTOOPT;
-          break;
-      }  /* switch (optname) */
-      break;
+		default:
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
+										s, optname));
+			err = ENOPROTOOPT;
+			break;
+		} /* switch (optname) */
+		break;
 
 #if LWIP_TCP
-    /* Level: IPPROTO_TCP */
-    case IPPROTO_TCP:
-      /* Special case: all IPPROTO_TCP option take an int */
-      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, *optlen, int, NETCONN_TCP);
-      if (sock->conn->pcb.tcp->state == LISTEN) {
-        done_socket(sock);
-        return EINVAL;
-      }
-      switch (optname) {
-        case TCP_NODELAY:
-          *(int *)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
-                                      s, (*(int *)optval) ? "on" : "off") );
-          break;
-        case TCP_KEEPALIVE:
-          *(int *)optval = (int)sock->conn->pcb.tcp->keep_idle;
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) = %d\n",
-                                      s, *(int *)optval));
-          break;
+	/* Level: IPPROTO_TCP */
+	case IPPROTO_TCP:
+		/* Special case: all IPPROTO_TCP option take an int */
+		LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, *optlen, int, NETCONN_TCP);
+		if (sock->conn->pcb.tcp->state == LISTEN)
+		{
+			done_socket(sock);
+			return EINVAL;
+		}
+		switch (optname)
+		{
+		case TCP_NODELAY:
+			*(int *)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
+										s, (*(int *)optval) ? "on" : "off"));
+			break;
+		case TCP_KEEPALIVE:
+			*(int *)optval = (int)sock->conn->pcb.tcp->keep_idle;
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) = %d\n",
+										s, *(int *)optval));
+			break;
 
 #if LWIP_TCP_KEEPALIVE
-        case TCP_KEEPIDLE:
-          *(int *)optval = (int)(sock->conn->pcb.tcp->keep_idle / 1000);
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) = %d\n",
-                                      s, *(int *)optval));
-          break;
-        case TCP_KEEPINTVL:
-          *(int *)optval = (int)(sock->conn->pcb.tcp->keep_intvl / 1000);
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) = %d\n",
-                                      s, *(int *)optval));
-          break;
-        case TCP_KEEPCNT:
-          *(int *)optval = (int)sock->conn->pcb.tcp->keep_cnt;
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) = %d\n",
-                                      s, *(int *)optval));
-          break;
+		case TCP_KEEPIDLE:
+			*(int *)optval = (int)(sock->conn->pcb.tcp->keep_idle / 1000);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) = %d\n",
+										s, *(int *)optval));
+			break;
+		case TCP_KEEPINTVL:
+			*(int *)optval = (int)(sock->conn->pcb.tcp->keep_intvl / 1000);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) = %d\n",
+										s, *(int *)optval));
+			break;
+		case TCP_KEEPCNT:
+			*(int *)optval = (int)sock->conn->pcb.tcp->keep_cnt;
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) = %d\n",
+										s, *(int *)optval));
+			break;
 #endif /* LWIP_TCP_KEEPALIVE */
-        default:
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
-                                      s, optname));
-          err = ENOPROTOOPT;
-          break;
-      }  /* switch (optname) */
-      break;
+		default:
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
+										s, optname));
+			err = ENOPROTOOPT;
+			break;
+		} /* switch (optname) */
+		break;
 #endif /* LWIP_TCP */
 
 #if LWIP_IPV6
-    /* Level: IPPROTO_IPV6 */
-    case IPPROTO_IPV6:
-      switch (optname) {
-        case IPV6_V6ONLY:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, int);
-          *(int *)optval = (netconn_get_ipv6only(sock->conn) ? 1 : 0);
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IPV6, IPV6_V6ONLY) = %d\n",
-                                      s, *(int *)optval));
-          break;
-        default:
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IPV6, UNIMPL: optname=0x%x, ..)\n",
-                                      s, optname));
-          err = ENOPROTOOPT;
-          break;
-      }  /* switch (optname) */
-      break;
+	/* Level: IPPROTO_IPV6 */
+	case IPPROTO_IPV6:
+		switch (optname)
+		{
+		case IPV6_V6ONLY:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, int);
+			*(int *)optval = (netconn_get_ipv6only(sock->conn) ? 1 : 0);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IPV6, IPV6_V6ONLY) = %d\n",
+										s, *(int *)optval));
+			break;
+		default:
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IPV6, UNIMPL: optname=0x%x, ..)\n",
+										s, optname));
+			err = ENOPROTOOPT;
+			break;
+		} /* switch (optname) */
+		break;
 #endif /* LWIP_IPV6 */
 
 #if LWIP_UDP && LWIP_UDPLITE
-    /* Level: IPPROTO_UDPLITE */
-    case IPPROTO_UDPLITE:
-      /* Special case: all IPPROTO_UDPLITE option take an int */
-      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
-      /* If this is no UDP lite socket, ignore any options. */
-      if (!NETCONNTYPE_ISUDPLITE(netconn_type(sock->conn))) {
-        done_socket(sock);
-        return ENOPROTOOPT;
-      }
-      switch (optname) {
-        case UDPLITE_SEND_CSCOV:
-          *(int *)optval = sock->conn->pcb.udp->chksum_len_tx;
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) = %d\n",
-                                      s, (*(int *)optval)) );
-          break;
-        case UDPLITE_RECV_CSCOV:
-          *(int *)optval = sock->conn->pcb.udp->chksum_len_rx;
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) = %d\n",
-                                      s, (*(int *)optval)) );
-          break;
-        default:
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",
-                                      s, optname));
-          err = ENOPROTOOPT;
-          break;
-      }  /* switch (optname) */
-      break;
+	/* Level: IPPROTO_UDPLITE */
+	case IPPROTO_UDPLITE:
+		/* Special case: all IPPROTO_UDPLITE option take an int */
+		LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
+		/* If this is no UDP lite socket, ignore any options. */
+		if (!NETCONNTYPE_ISUDPLITE(netconn_type(sock->conn)))
+		{
+			done_socket(sock);
+			return ENOPROTOOPT;
+		}
+		switch (optname)
+		{
+		case UDPLITE_SEND_CSCOV:
+			*(int *)optval = sock->conn->pcb.udp->chksum_len_tx;
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) = %d\n",
+										s, (*(int *)optval)));
+			break;
+		case UDPLITE_RECV_CSCOV:
+			*(int *)optval = sock->conn->pcb.udp->chksum_len_rx;
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) = %d\n",
+										s, (*(int *)optval)));
+			break;
+		default:
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",
+										s, optname));
+			err = ENOPROTOOPT;
+			break;
+		} /* switch (optname) */
+		break;
 #endif /* LWIP_UDP */
-    /* Level: IPPROTO_RAW */
-    case IPPROTO_RAW:
-      switch (optname) {
+	/* Level: IPPROTO_RAW */
+	case IPPROTO_RAW:
+		switch (optname)
+		{
 #if LWIP_IPV6 && LWIP_RAW
-        case IPV6_CHECKSUM:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, *optlen, int, NETCONN_RAW);
-          if (sock->conn->pcb.raw->chksum_reqd == 0) {
-            *(int *)optval = -1;
-          } else {
-            *(int *)optval = sock->conn->pcb.raw->chksum_offset;
-          }
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_RAW, IPV6_CHECKSUM) = %d\n",
-                                      s, (*(int *)optval)) );
-          break;
+		case IPV6_CHECKSUM:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, *optlen, int, NETCONN_RAW);
+			if (sock->conn->pcb.raw->chksum_reqd == 0)
+			{
+				*(int *)optval = -1;
+			}
+			else
+			{
+				*(int *)optval = sock->conn->pcb.raw->chksum_offset;
+			}
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_RAW, IPV6_CHECKSUM) = %d\n",
+										s, (*(int *)optval)));
+			break;
 #endif /* LWIP_IPV6 && LWIP_RAW */
-        default:
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_RAW, UNIMPL: optname=0x%x, ..)\n",
-                                      s, optname));
-          err = ENOPROTOOPT;
-          break;
-      }  /* switch (optname) */
-      break;
-    default:
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
-                                  s, level, optname));
-      err = ENOPROTOOPT;
-      break;
-  } /* switch (level) */
-
-  done_socket(sock);
-  return err;
+		default:
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_RAW, UNIMPL: optname=0x%x, ..)\n",
+										s, optname));
+			err = ENOPROTOOPT;
+			break;
+		} /* switch (optname) */
+		break;
+	default:
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
+									s, level, optname));
+		err = ENOPROTOOPT;
+		break;
+	} /* switch (level) */
+
+	done_socket(sock);
+	return err;
 }
 
-int
-lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
+int lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
 {
-  int err = 0;
-  struct lwip_sock *sock = get_socket(s);
+	int err = 0;
+	struct lwip_sock *sock = get_socket(s);
 #if !LWIP_TCPIP_CORE_LOCKING
-  err_t cberr;
-  LWIP_SETGETSOCKOPT_DATA_VAR_DECLARE(data);
+	err_t cberr;
+	LWIP_SETGETSOCKOPT_DATA_VAR_DECLARE(data);
 #endif /* !LWIP_TCPIP_CORE_LOCKING */
 
-  if (!sock) {
-    return -1;
-  }
+	if (!sock)
+	{
+		return -1;
+	}
 
-  if (NULL == optval) {
-    sock_set_errno(sock, EFAULT);
-    done_socket(sock);
-    return -1;
-  }
+	if (NULL == optval)
+	{
+		sock_set_errno(sock, EFAULT);
+		done_socket(sock);
+		return -1;
+	}
 
 #if LWIP_TCPIP_CORE_LOCKING
-  /* core-locking can just call the -impl function */
-  LOCK_TCPIP_CORE();
-  err = lwip_setsockopt_impl(s, level, optname, optval, optlen);
-  UNLOCK_TCPIP_CORE();
+	/* core-locking can just call the -impl function */
+	LOCK_TCPIP_CORE();
+	err = lwip_setsockopt_impl(s, level, optname, optval, optlen);
+	UNLOCK_TCPIP_CORE();
 
 #else /* LWIP_TCPIP_CORE_LOCKING */
 
 #if LWIP_MPU_COMPATIBLE
-  /* MPU_COMPATIBLE copies the optval data, so check for max size here */
-  if (optlen > LWIP_SETGETSOCKOPT_MAXOPTLEN) {
-    sock_set_errno(sock, ENOBUFS);
-    done_socket(sock);
-    return -1;
-  }
+	/* MPU_COMPATIBLE copies the optval data, so check for max size here */
+	if (optlen > LWIP_SETGETSOCKOPT_MAXOPTLEN)
+	{
+		sock_set_errno(sock, ENOBUFS);
+		done_socket(sock);
+		return -1;
+	}
 #endif /* LWIP_MPU_COMPATIBLE */
 
-  LWIP_SETGETSOCKOPT_DATA_VAR_ALLOC(data, sock);
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).s = s;
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).level = level;
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optname = optname;
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen = optlen;
+	LWIP_SETGETSOCKOPT_DATA_VAR_ALLOC(data, sock);
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).s = s;
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).level = level;
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optname = optname;
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optlen = optlen;
 #if LWIP_MPU_COMPATIBLE
-  MEMCPY(LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optval, optval, optlen);
-#else /* LWIP_MPU_COMPATIBLE */
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optval.pc = (const void *)optval;
+	MEMCPY(LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optval, optval, optlen);
+#else  /* LWIP_MPU_COMPATIBLE */
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).optval.pc = (const void *)optval;
 #endif /* LWIP_MPU_COMPATIBLE */
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err = 0;
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err = 0;
 #if LWIP_NETCONN_SEM_PER_THREAD
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem = LWIP_NETCONN_THREAD_SEM_GET();
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem = LWIP_NETCONN_THREAD_SEM_GET();
 #else
-  LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem = &sock->conn->op_completed;
+	LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem = &sock->conn->op_completed;
 #endif
-  cberr = tcpip_callback(lwip_setsockopt_callback, &LWIP_SETGETSOCKOPT_DATA_VAR_REF(data));
-  if (cberr != ERR_OK) {
-    LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
-    sock_set_errno(sock, err_to_errno(cberr));
-    done_socket(sock);
-    return -1;
-  }
-  sys_arch_sem_wait((sys_sem_t *)(LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem), 0);
-
-  /* maybe lwip_getsockopt_internal has changed err */
-  err = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err;
-  LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
-#endif  /* LWIP_TCPIP_CORE_LOCKING */
-
-  sock_set_errno(sock, err);
-  done_socket(sock);
-  return err ? -1 : 0;
+	cberr = tcpip_callback(lwip_setsockopt_callback, &LWIP_SETGETSOCKOPT_DATA_VAR_REF(data));
+	if (cberr != ERR_OK)
+	{
+		LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
+		sock_set_errno(sock, err_to_errno(cberr));
+		done_socket(sock);
+		return -1;
+	}
+	sys_arch_sem_wait((sys_sem_t *)(LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).completed_sem), 0);
+
+	/* maybe lwip_getsockopt_internal has changed err */
+	err = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err;
+	LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
+#endif /* LWIP_TCPIP_CORE_LOCKING */
+
+	sock_set_errno(sock, err);
+	done_socket(sock);
+	return err ? -1 : 0;
 }
 
 #if !LWIP_TCPIP_CORE_LOCKING
@@ -3284,21 +3663,21 @@ lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t opt
 static void
 lwip_setsockopt_callback(void *arg)
 {
-  struct lwip_setgetsockopt_data *data;
-  LWIP_ASSERT("arg != NULL", arg != NULL);
-  data = (struct lwip_setgetsockopt_data *)arg;
+	struct lwip_setgetsockopt_data *data;
+	LWIP_ASSERT("arg != NULL", arg != NULL);
+	data = (struct lwip_setgetsockopt_data *)arg;
 
-  data->err = lwip_setsockopt_impl(data->s, data->level, data->optname,
+	data->err = lwip_setsockopt_impl(data->s, data->level, data->optname,
 #if LWIP_MPU_COMPATIBLE
-                                   data->optval,
-#else /* LWIP_MPU_COMPATIBLE */
-                                   data->optval.pc,
+									 data->optval,
+#else  /* LWIP_MPU_COMPATIBLE */
+									 data->optval.pc,
 #endif /* LWIP_MPU_COMPATIBLE */
-                                   data->optlen);
+									 data->optlen);
 
-  sys_sem_signal((sys_sem_t *)(data->completed_sem));
+	sys_sem_signal((sys_sem_t *)(data->completed_sem));
 }
-#endif  /* LWIP_TCPIP_CORE_LOCKING */
+#endif /* LWIP_TCPIP_CORE_LOCKING */
 
 /** lwip_setsockopt_impl: the actual implementation of setsockopt:
  * same argument as lwip_setsockopt, either called directly or through callback
@@ -3306,529 +3685,625 @@ lwip_setsockopt_callback(void *arg)
 static int
 lwip_setsockopt_impl(int s, int level, int optname, const void *optval, socklen_t optlen)
 {
-  int err = 0;
-  struct lwip_sock *sock = tryget_socket(s);
-  if (!sock) {
-    return EBADF;
-  }
+	int err = 0;
+	struct lwip_sock *sock = tryget_socket(s);
+	if (!sock)
+	{
+		return EBADF;
+	}
 
 #ifdef LWIP_HOOK_SOCKETS_SETSOCKOPT
-  if (LWIP_HOOK_SOCKETS_SETSOCKOPT(s, sock, level, optname, optval, optlen, &err)) {
-    return err;
-  }
+	if (LWIP_HOOK_SOCKETS_SETSOCKOPT(s, sock, level, optname, optval, optlen, &err))
+	{
+		return err;
+	}
 #endif
 
-  switch (level) {
+	switch (level)
+	{
 
-    /* Level: SOL_SOCKET */
-    case SOL_SOCKET:
-      switch (optname) {
+	/* Level: SOL_SOCKET */
+	case SOL_SOCKET:
+		switch (optname)
+		{
 
-        /* SO_ACCEPTCONN is get-only */
+		/* SO_ACCEPTCONN is get-only */
 
-        /* The option flags */
-        case SO_BROADCAST:
-        case SO_KEEPALIVE:
+		/* The option flags */
+		case SO_BROADCAST:
+		case SO_KEEPALIVE:
 #if SO_REUSE
-        case SO_REUSEADDR:
+		case SO_REUSEADDR:
 #endif /* SO_REUSE */
-          if ((optname == SO_BROADCAST) &&
-              (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP)) {
-            done_socket(sock);
-            return ENOPROTOOPT;
-          }
-
-          optname = lwip_sockopt_to_ipopt(optname);
-
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
-          if (*(const int *)optval) {
-            ip_set_option(sock->conn->pcb.ip, optname);
-          } else {
-            ip_reset_option(sock->conn->pcb.ip, optname);
-          }
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
-                                      s, optname, (*(const int *)optval ? "on" : "off")));
-          break;
-
-          /* SO_TYPE is get-only */
-          /* SO_ERROR is get-only */
+			if ((optname == SO_BROADCAST) &&
+				(NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP))
+			{
+				done_socket(sock);
+				return ENOPROTOOPT;
+			}
+
+			optname = lwip_sockopt_to_ipopt(optname);
+
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
+			if (*(const int *)optval)
+			{
+				ip_set_option(sock->conn->pcb.ip, optname);
+			}
+			else
+			{
+				ip_reset_option(sock->conn->pcb.ip, optname);
+			}
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
+										s, optname, (*(const int *)optval ? "on" : "off")));
+			break;
+
+			/* SO_TYPE is get-only */
+			/* SO_ERROR is get-only */
 
 #if LWIP_SO_SNDTIMEO
-        case SO_SNDTIMEO: {
-          long ms_long;
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
-          ms_long = LWIP_SO_SNDRCVTIMEO_GET_MS(optval);
-          if (ms_long < 0) {
-            done_socket(sock);
-            return EINVAL;
-          }
-          netconn_set_sendtimeout(sock->conn, ms_long);
-          break;
-        }
+		case SO_SNDTIMEO:
+		{
+			long ms_long;
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
+			ms_long = LWIP_SO_SNDRCVTIMEO_GET_MS(optval);
+			if (ms_long < 0)
+			{
+				done_socket(sock);
+				return EINVAL;
+			}
+			netconn_set_sendtimeout(sock->conn, ms_long);
+			break;
+		}
 #endif /* LWIP_SO_SNDTIMEO */
 #if LWIP_SO_RCVTIMEO
-        case SO_RCVTIMEO: {
-          long ms_long;
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
-          ms_long = LWIP_SO_SNDRCVTIMEO_GET_MS(optval);
-          if (ms_long < 0) {
-            done_socket(sock);
-            return EINVAL;
-          }
-          netconn_set_recvtimeout(sock->conn, (u32_t)ms_long);
-          break;
-        }
+		case SO_RCVTIMEO:
+		{
+			long ms_long;
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
+			ms_long = LWIP_SO_SNDRCVTIMEO_GET_MS(optval);
+			if (ms_long < 0)
+			{
+				done_socket(sock);
+				return EINVAL;
+			}
+			netconn_set_recvtimeout(sock->conn, (u32_t)ms_long);
+			break;
+		}
 #endif /* LWIP_SO_RCVTIMEO */
 #if LWIP_SO_RCVBUF
-        case SO_RCVBUF:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, int);
-          netconn_set_recvbufsize(sock->conn, *(const int *)optval);
-          break;
+		case SO_RCVBUF:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, int);
+			netconn_set_recvbufsize(sock->conn, *(const int *)optval);
+			break;
 #endif /* LWIP_SO_RCVBUF */
 #if LWIP_SO_LINGER
-        case SO_LINGER: {
-          const struct linger *linger = (const struct linger *)optval;
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, struct linger);
-          if (linger->l_onoff) {
-            int lingersec = linger->l_linger;
-            if (lingersec < 0) {
-              done_socket(sock);
-              return EINVAL;
-            }
-            if (lingersec > 0xFFFF) {
-              lingersec = 0xFFFF;
-            }
-            sock->conn->linger = (s16_t)lingersec;
-          } else {
-            sock->conn->linger = -1;
-          }
-        }
-        break;
+		case SO_LINGER:
+		{
+			const struct linger *linger = (const struct linger *)optval;
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, struct linger);
+			if (linger->l_onoff)
+			{
+				int lingersec = linger->l_linger;
+				if (lingersec < 0)
+				{
+					done_socket(sock);
+					return EINVAL;
+				}
+				if (lingersec > 0xFFFF)
+				{
+					lingersec = 0xFFFF;
+				}
+				sock->conn->linger = (s16_t)lingersec;
+			}
+			else
+			{
+				sock->conn->linger = -1;
+			}
+		}
+		break;
 #endif /* LWIP_SO_LINGER */
 #if LWIP_UDP
-        case SO_NO_CHECK:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_UDP);
+		case SO_NO_CHECK:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_UDP);
 #if LWIP_UDPLITE
-          if (udp_is_flag_set(sock->conn->pcb.udp, UDP_FLAGS_UDPLITE)) {
-            /* this flag is only available for UDP, not for UDP lite */
-            done_socket(sock);
-            return EAFNOSUPPORT;
-          }
+			if (udp_is_flag_set(sock->conn->pcb.udp, UDP_FLAGS_UDPLITE))
+			{
+				/* this flag is only available for UDP, not for UDP lite */
+				done_socket(sock);
+				return EAFNOSUPPORT;
+			}
 #endif /* LWIP_UDPLITE */
-          if (*(const int *)optval) {
-            udp_set_flags(sock->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
-          } else {
-            udp_clear_flags(sock->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
-          }
-          break;
+			if (*(const int *)optval)
+			{
+				udp_set_flags(sock->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
+			}
+			else
+			{
+				udp_clear_flags(sock->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
+			}
+			break;
 #endif /* LWIP_UDP */
-        case SO_BINDTODEVICE: {
-          const struct ifreq *iface;
-          struct netif *n = NULL;
-
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, struct ifreq);
-
-          iface = (const struct ifreq *)optval;
-          if (iface->ifr_name[0] != 0) {
-            n = netif_find(iface->ifr_name);
-            if (n == NULL) {
-              done_socket(sock);
-              return ENODEV;
-            }
-          }
-
-          switch (NETCONNTYPE_GROUP(netconn_type(sock->conn))) {
+		case SO_BINDTODEVICE:
+		{
+			const struct ifreq *iface;
+			struct netif *n = NULL;
+
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, struct ifreq);
+
+			iface = (const struct ifreq *)optval;
+			if (iface->ifr_name[0] != 0)
+			{
+				n = netif_find(iface->ifr_name);
+				if (n == NULL)
+				{
+					done_socket(sock);
+					return ENODEV;
+				}
+			}
+
+			switch (NETCONNTYPE_GROUP(netconn_type(sock->conn)))
+			{
 #if LWIP_TCP
-            case NETCONN_TCP:
-              tcp_bind_netif(sock->conn->pcb.tcp, n);
-              break;
+			case NETCONN_TCP:
+				tcp_bind_netif(sock->conn->pcb.tcp, n);
+				break;
 #endif
 #if LWIP_UDP
-            case NETCONN_UDP:
-              udp_bind_netif(sock->conn->pcb.udp, n);
-              break;
+			case NETCONN_UDP:
+				udp_bind_netif(sock->conn->pcb.udp, n);
+				break;
 #endif
 #if LWIP_RAW
-            case NETCONN_RAW:
-              raw_bind_netif(sock->conn->pcb.raw, n);
-              break;
+			case NETCONN_RAW:
+				raw_bind_netif(sock->conn->pcb.raw, n);
+				break;
 #endif
-            default:
-              LWIP_ASSERT("Unhandled netconn type in SO_BINDTODEVICE", 0);
-              break;
-          }
-        }
-        break;
-        default:
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
-                                      s, optname));
-          err = ENOPROTOOPT;
-          break;
-      }  /* switch (optname) */
-      break;
-
-    /* Level: IPPROTO_IP */
-    case IPPROTO_IP:
-      switch (optname) {
-        case IP_TTL:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
-          sock->conn->pcb.ip->ttl = (u8_t)(*(const int *)optval);
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
-                                      s, sock->conn->pcb.ip->ttl));
-          break;
-        case IP_TOS:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
-          sock->conn->pcb.ip->tos = (u8_t)(*(const int *)optval);
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %d\n",
-                                      s, sock->conn->pcb.ip->tos));
-          break;
+			default:
+				LWIP_ASSERT("Unhandled netconn type in SO_BINDTODEVICE", 0);
+				break;
+			}
+		}
+		break;
+		default:
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
+										s, optname));
+			err = ENOPROTOOPT;
+			break;
+		} /* switch (optname) */
+		break;
+
+	/* Level: IPPROTO_IP */
+	case IPPROTO_IP:
+		switch (optname)
+		{
+		case IP_TTL:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
+			sock->conn->pcb.ip->ttl = (u8_t)(*(const int *)optval);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
+										s, sock->conn->pcb.ip->ttl));
+			break;
+		case IP_TOS:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
+			sock->conn->pcb.ip->tos = (u8_t)(*(const int *)optval);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %d\n",
+										s, sock->conn->pcb.ip->tos));
+			break;
+		case IP_HDRINCL:
+			if (*(const int *)optval)
+				sock->conn->pcb.raw->flags |= RAW_FLAGS_HDRINCL;
+			else
+				sock->conn->pcb.raw->flags &= ~RAW_FLAGS_HDRINCL;
+			break;
 #if LWIP_NETBUF_RECVINFO
-        case IP_PKTINFO:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_UDP);
-          if (*(const int *)optval) {
-            sock->conn->flags |= NETCONN_FLAG_PKTINFO;
-          } else {
-            sock->conn->flags &= ~NETCONN_FLAG_PKTINFO;
-          }
-          break;
+		case IP_PKTINFO:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_UDP);
+			if (*(const int *)optval)
+			{
+				sock->conn->flags |= NETCONN_FLAG_PKTINFO;
+			}
+			else
+			{
+				sock->conn->flags &= ~NETCONN_FLAG_PKTINFO;
+			}
+			break;
 #endif /* LWIP_NETBUF_RECVINFO */
 #if LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS && LWIP_UDP
-        case IP_MULTICAST_TTL:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, u8_t, NETCONN_UDP);
-          udp_set_multicast_ttl(sock->conn->pcb.udp, (u8_t)(*(const u8_t *)optval));
-          break;
-        case IP_MULTICAST_IF: {
-          ip4_addr_t if_addr;
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, struct in_addr, NETCONN_UDP);
-          inet_addr_to_ip4addr(&if_addr, (const struct in_addr *)optval);
-          udp_set_multicast_netif_addr(sock->conn->pcb.udp, &if_addr);
-        }
-        break;
-        case IP_MULTICAST_LOOP:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, u8_t, NETCONN_UDP);
-          if (*(const u8_t *)optval) {
-            udp_set_flags(sock->conn->pcb.udp, UDP_FLAGS_MULTICAST_LOOP);
-          } else {
-            udp_clear_flags(sock->conn->pcb.udp, UDP_FLAGS_MULTICAST_LOOP);
-          }
-          break;
+		case IP_MULTICAST_TTL:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, u8_t, NETCONN_UDP);
+			udp_set_multicast_ttl(sock->conn->pcb.udp, (u8_t)(*(const u8_t *)optval));
+			break;
+		case IP_MULTICAST_IF:
+		{
+			ip4_addr_t if_addr;
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, struct in_addr, NETCONN_UDP);
+			inet_addr_to_ip4addr(&if_addr, (const struct in_addr *)optval);
+			udp_set_multicast_netif_addr(sock->conn->pcb.udp, &if_addr);
+		}
+		break;
+		case IP_MULTICAST_LOOP:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, u8_t, NETCONN_UDP);
+			if (*(const u8_t *)optval)
+			{
+				udp_set_flags(sock->conn->pcb.udp, UDP_FLAGS_MULTICAST_LOOP);
+			}
+			else
+			{
+				udp_clear_flags(sock->conn->pcb.udp, UDP_FLAGS_MULTICAST_LOOP);
+			}
+			break;
 #endif /* LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS && LWIP_UDP */
 #if LWIP_IGMP
-        case IP_ADD_MEMBERSHIP:
-        case IP_DROP_MEMBERSHIP: {
-          /* If this is a TCP or a RAW socket, ignore these options. */
-          err_t igmp_err;
-          const struct ip_mreq *imr = (const struct ip_mreq *)optval;
-          ip4_addr_t if_addr;
-          ip4_addr_t multi_addr;
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, struct ip_mreq, NETCONN_UDP);
-          inet_addr_to_ip4addr(&if_addr, &imr->imr_interface);
-          inet_addr_to_ip4addr(&multi_addr, &imr->imr_multiaddr);
-          if (optname == IP_ADD_MEMBERSHIP) {
-            if (!lwip_socket_register_membership(s, &if_addr, &multi_addr)) {
-              /* cannot track membership (out of memory) */
-              err = ENOMEM;
-              igmp_err = ERR_OK;
-            } else {
-              igmp_err = igmp_joingroup(&if_addr, &multi_addr);
-            }
-          } else {
-            igmp_err = igmp_leavegroup(&if_addr, &multi_addr);
-            lwip_socket_unregister_membership(s, &if_addr, &multi_addr);
-          }
-          if (igmp_err != ERR_OK) {
-            err = EADDRNOTAVAIL;
-          }
-        }
-        break;
+		case IP_ADD_MEMBERSHIP:
+		case IP_DROP_MEMBERSHIP:
+		{
+			/* If this is a TCP or a RAW socket, ignore these options. */
+			err_t igmp_err;
+			const struct ip_mreq *imr = (const struct ip_mreq *)optval;
+			ip4_addr_t if_addr;
+			ip4_addr_t multi_addr;
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, struct ip_mreq, NETCONN_UDP);
+			inet_addr_to_ip4addr(&if_addr, &imr->imr_interface);
+			inet_addr_to_ip4addr(&multi_addr, &imr->imr_multiaddr);
+			if (optname == IP_ADD_MEMBERSHIP)
+			{
+				if (!lwip_socket_register_membership(s, &if_addr, &multi_addr))
+				{
+					/* cannot track membership (out of memory) */
+					err = ENOMEM;
+					igmp_err = ERR_OK;
+				}
+				else
+				{
+					igmp_err = igmp_joingroup(&if_addr, &multi_addr);
+				}
+			}
+			else
+			{
+				igmp_err = igmp_leavegroup(&if_addr, &multi_addr);
+				lwip_socket_unregister_membership(s, &if_addr, &multi_addr);
+			}
+			if (igmp_err != ERR_OK)
+			{
+				err = EADDRNOTAVAIL;
+			}
+		}
+		break;
 #endif /* LWIP_IGMP */
-        default:
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
-                                      s, optname));
-          err = ENOPROTOOPT;
-          break;
-      }  /* switch (optname) */
-      break;
+		default:
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
+										s, optname));
+			err = ENOPROTOOPT;
+			break;
+		} /* switch (optname) */
+		break;
 
 #if LWIP_TCP
-    /* Level: IPPROTO_TCP */
-    case IPPROTO_TCP:
-      /* Special case: all IPPROTO_TCP option take an int */
-      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_TCP);
-      if (sock->conn->pcb.tcp->state == LISTEN) {
-        done_socket(sock);
-        return EINVAL;
-      }
-      switch (optname) {
-        case TCP_NODELAY:
-          if (*(const int *)optval) {
-            tcp_nagle_disable(sock->conn->pcb.tcp);
-          } else {
-            tcp_nagle_enable(sock->conn->pcb.tcp);
-          }
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
-                                      s, (*(const int *)optval) ? "on" : "off") );
-          break;
-        case TCP_KEEPALIVE:
-          sock->conn->pcb.tcp->keep_idle = (u32_t)(*(const int *)optval);
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %"U32_F"\n",
-                                      s, sock->conn->pcb.tcp->keep_idle));
-          break;
+	/* Level: IPPROTO_TCP */
+	case IPPROTO_TCP:
+		/* Special case: all IPPROTO_TCP option take an int */
+		LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_TCP);
+		if (sock->conn->pcb.tcp->state == LISTEN)
+		{
+			done_socket(sock);
+			return EINVAL;
+		}
+		switch (optname)
+		{
+		case TCP_NODELAY:
+			if (*(const int *)optval)
+			{
+				tcp_nagle_disable(sock->conn->pcb.tcp);
+			}
+			else
+			{
+				tcp_nagle_enable(sock->conn->pcb.tcp);
+			}
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
+										s, (*(const int *)optval) ? "on" : "off"));
+			break;
+		case TCP_KEEPALIVE:
+			sock->conn->pcb.tcp->keep_idle = (u32_t)(*(const int *)optval);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %" U32_F "\n",
+										s, sock->conn->pcb.tcp->keep_idle));
+			break;
 
 #if LWIP_TCP_KEEPALIVE
-        case TCP_KEEPIDLE:
-          sock->conn->pcb.tcp->keep_idle = 1000 * (u32_t)(*(const int *)optval);
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) -> %"U32_F"\n",
-                                      s, sock->conn->pcb.tcp->keep_idle));
-          break;
-        case TCP_KEEPINTVL:
-          sock->conn->pcb.tcp->keep_intvl = 1000 * (u32_t)(*(const int *)optval);
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) -> %"U32_F"\n",
-                                      s, sock->conn->pcb.tcp->keep_intvl));
-          break;
-        case TCP_KEEPCNT:
-          sock->conn->pcb.tcp->keep_cnt = (u32_t)(*(const int *)optval);
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %"U32_F"\n",
-                                      s, sock->conn->pcb.tcp->keep_cnt));
-          break;
+		case TCP_KEEPIDLE:
+			sock->conn->pcb.tcp->keep_idle = 1000 * (u32_t)(*(const int *)optval);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) -> %" U32_F "\n",
+										s, sock->conn->pcb.tcp->keep_idle));
+			break;
+		case TCP_KEEPINTVL:
+			sock->conn->pcb.tcp->keep_intvl = 1000 * (u32_t)(*(const int *)optval);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) -> %" U32_F "\n",
+										s, sock->conn->pcb.tcp->keep_intvl));
+			break;
+		case TCP_KEEPCNT:
+			sock->conn->pcb.tcp->keep_cnt = (u32_t)(*(const int *)optval);
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %" U32_F "\n",
+										s, sock->conn->pcb.tcp->keep_cnt));
+			break;
 #endif /* LWIP_TCP_KEEPALIVE */
-        default:
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
-                                      s, optname));
-          err = ENOPROTOOPT;
-          break;
-      }  /* switch (optname) */
-      break;
+		default:
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
+										s, optname));
+			err = ENOPROTOOPT;
+			break;
+		} /* switch (optname) */
+		break;
 #endif /* LWIP_TCP*/
 
 #if LWIP_IPV6
-    /* Level: IPPROTO_IPV6 */
-    case IPPROTO_IPV6:
-      switch (optname) {
-        case IPV6_V6ONLY:
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
-          if (*(const int *)optval) {
-            netconn_set_ipv6only(sock->conn, 1);
-          } else {
-            netconn_set_ipv6only(sock->conn, 0);
-          }
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IPV6, IPV6_V6ONLY, ..) -> %d\n",
-                                      s, (netconn_get_ipv6only(sock->conn) ? 1 : 0)));
-          break;
+	/* Level: IPPROTO_IPV6 */
+	case IPPROTO_IPV6:
+		switch (optname)
+		{
+		case IPV6_V6ONLY:
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
+			if (*(const int *)optval)
+			{
+				netconn_set_ipv6only(sock->conn, 1);
+			}
+			else
+			{
+				netconn_set_ipv6only(sock->conn, 0);
+			}
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IPV6, IPV6_V6ONLY, ..) -> %d\n",
+										s, (netconn_get_ipv6only(sock->conn) ? 1 : 0)));
+			break;
 #if LWIP_IPV6_MLD
-        case IPV6_JOIN_GROUP:
-        case IPV6_LEAVE_GROUP: {
-          /* If this is a TCP or a RAW socket, ignore these options. */
-          err_t mld6_err;
-          struct netif *netif;
-          ip6_addr_t multi_addr;
-          const struct ipv6_mreq *imr = (const struct ipv6_mreq *)optval;
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, struct ipv6_mreq, NETCONN_UDP);
-          inet6_addr_to_ip6addr(&multi_addr, &imr->ipv6mr_multiaddr);
-          LWIP_ASSERT("Invalid netif index", imr->ipv6mr_interface <= 0xFFu);
-          netif = netif_get_by_index((u8_t)imr->ipv6mr_interface);
-          if (netif == NULL) {
-            err = EADDRNOTAVAIL;
-            break;
-          }
-
-          if (optname == IPV6_JOIN_GROUP) {
-            if (!lwip_socket_register_mld6_membership(s, imr->ipv6mr_interface, &multi_addr)) {
-              /* cannot track membership (out of memory) */
-              err = ENOMEM;
-              mld6_err = ERR_OK;
-            } else {
-              mld6_err = mld6_joingroup_netif(netif, &multi_addr);
-            }
-          } else {
-            mld6_err = mld6_leavegroup_netif(netif, &multi_addr);
-            lwip_socket_unregister_mld6_membership(s, imr->ipv6mr_interface, &multi_addr);
-          }
-          if (mld6_err != ERR_OK) {
-            err = EADDRNOTAVAIL;
-          }
-        }
-        break;
+		case IPV6_JOIN_GROUP:
+		case IPV6_LEAVE_GROUP:
+		{
+			/* If this is a TCP or a RAW socket, ignore these options. */
+			err_t mld6_err;
+			struct netif *netif;
+			ip6_addr_t multi_addr;
+			const struct ipv6_mreq *imr = (const struct ipv6_mreq *)optval;
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, struct ipv6_mreq, NETCONN_UDP);
+			inet6_addr_to_ip6addr(&multi_addr, &imr->ipv6mr_multiaddr);
+			LWIP_ASSERT("Invalid netif index", imr->ipv6mr_interface <= 0xFFu);
+			netif = netif_get_by_index((u8_t)imr->ipv6mr_interface);
+			if (netif == NULL)
+			{
+				err = EADDRNOTAVAIL;
+				break;
+			}
+
+			if (optname == IPV6_JOIN_GROUP)
+			{
+				if (!lwip_socket_register_mld6_membership(s, imr->ipv6mr_interface, &multi_addr))
+				{
+					/* cannot track membership (out of memory) */
+					err = ENOMEM;
+					mld6_err = ERR_OK;
+				}
+				else
+				{
+					mld6_err = mld6_joingroup_netif(netif, &multi_addr);
+				}
+			}
+			else
+			{
+				mld6_err = mld6_leavegroup_netif(netif, &multi_addr);
+				lwip_socket_unregister_mld6_membership(s, imr->ipv6mr_interface, &multi_addr);
+			}
+			if (mld6_err != ERR_OK)
+			{
+				err = EADDRNOTAVAIL;
+			}
+		}
+		break;
 #endif /* LWIP_IPV6_MLD */
-        default:
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IPV6, UNIMPL: optname=0x%x, ..)\n",
-                                      s, optname));
-          err = ENOPROTOOPT;
-          break;
-      }  /* switch (optname) */
-      break;
+		default:
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IPV6, UNIMPL: optname=0x%x, ..)\n",
+										s, optname));
+			err = ENOPROTOOPT;
+			break;
+		} /* switch (optname) */
+		break;
 #endif /* LWIP_IPV6 */
 
 #if LWIP_UDP && LWIP_UDPLITE
-    /* Level: IPPROTO_UDPLITE */
-    case IPPROTO_UDPLITE:
-      /* Special case: all IPPROTO_UDPLITE option take an int */
-      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
-      /* If this is no UDP lite socket, ignore any options. */
-      if (!NETCONNTYPE_ISUDPLITE(netconn_type(sock->conn))) {
-        done_socket(sock);
-        return ENOPROTOOPT;
-      }
-      switch (optname) {
-        case UDPLITE_SEND_CSCOV:
-          if ((*(const int *)optval != 0) && ((*(const int *)optval < 8) || (*(const int *)optval > 0xffff))) {
-            /* don't allow illegal values! */
-            sock->conn->pcb.udp->chksum_len_tx = 8;
-          } else {
-            sock->conn->pcb.udp->chksum_len_tx = (u16_t) * (const int *)optval;
-          }
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) -> %d\n",
-                                      s, (*(const int *)optval)) );
-          break;
-        case UDPLITE_RECV_CSCOV:
-          if ((*(const int *)optval != 0) && ((*(const int *)optval < 8) || (*(const int *)optval > 0xffff))) {
-            /* don't allow illegal values! */
-            sock->conn->pcb.udp->chksum_len_rx = 8;
-          } else {
-            sock->conn->pcb.udp->chksum_len_rx = (u16_t) * (const int *)optval;
-          }
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) -> %d\n",
-                                      s, (*(const int *)optval)) );
-          break;
-        default:
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",
-                                      s, optname));
-          err = ENOPROTOOPT;
-          break;
-      }  /* switch (optname) */
-      break;
+	/* Level: IPPROTO_UDPLITE */
+	case IPPROTO_UDPLITE:
+		/* Special case: all IPPROTO_UDPLITE option take an int */
+		LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
+		/* If this is no UDP lite socket, ignore any options. */
+		if (!NETCONNTYPE_ISUDPLITE(netconn_type(sock->conn)))
+		{
+			done_socket(sock);
+			return ENOPROTOOPT;
+		}
+		switch (optname)
+		{
+		case UDPLITE_SEND_CSCOV:
+			if ((*(const int *)optval != 0) && ((*(const int *)optval < 8) || (*(const int *)optval > 0xffff)))
+			{
+				/* don't allow illegal values! */
+				sock->conn->pcb.udp->chksum_len_tx = 8;
+			}
+			else
+			{
+				sock->conn->pcb.udp->chksum_len_tx = (u16_t) * (const int *)optval;
+			}
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) -> %d\n",
+										s, (*(const int *)optval)));
+			break;
+		case UDPLITE_RECV_CSCOV:
+			if ((*(const int *)optval != 0) && ((*(const int *)optval < 8) || (*(const int *)optval > 0xffff)))
+			{
+				/* don't allow illegal values! */
+				sock->conn->pcb.udp->chksum_len_rx = 8;
+			}
+			else
+			{
+				sock->conn->pcb.udp->chksum_len_rx = (u16_t) * (const int *)optval;
+			}
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) -> %d\n",
+										s, (*(const int *)optval)));
+			break;
+		default:
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",
+										s, optname));
+			err = ENOPROTOOPT;
+			break;
+		} /* switch (optname) */
+		break;
 #endif /* LWIP_UDP */
-    /* Level: IPPROTO_RAW */
-    case IPPROTO_RAW:
-      switch (optname) {
+	/* Level: IPPROTO_RAW */
+	case IPPROTO_RAW:
+		switch (optname)
+		{
 #if LWIP_IPV6 && LWIP_RAW
-        case IPV6_CHECKSUM:
-          /* It should not be possible to disable the checksum generation with ICMPv6
-           * as per RFC 3542 chapter 3.1 */
-          if (sock->conn->pcb.raw->protocol == IPPROTO_ICMPV6) {
-            done_socket(sock);
-            return EINVAL;
-          }
-
-          LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_RAW);
-          if (*(const int *)optval < 0) {
-            sock->conn->pcb.raw->chksum_reqd = 0;
-          } else if (*(const int *)optval & 1) {
-            /* Per RFC3542, odd offsets are not allowed */
-            done_socket(sock);
-            return EINVAL;
-          } else {
-            sock->conn->pcb.raw->chksum_reqd = 1;
-            sock->conn->pcb.raw->chksum_offset = (u16_t) * (const int *)optval;
-          }
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_RAW, IPV6_CHECKSUM, ..) -> %d\n",
-                                      s, sock->conn->pcb.raw->chksum_reqd));
-          break;
+		case IPV6_CHECKSUM:
+			/* It should not be possible to disable the checksum generation with ICMPv6
+			 * as per RFC 3542 chapter 3.1 */
+			if (sock->conn->pcb.raw->protocol == IPPROTO_ICMPV6)
+			{
+				done_socket(sock);
+				return EINVAL;
+			}
+
+			LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_RAW);
+			if (*(const int *)optval < 0)
+			{
+				sock->conn->pcb.raw->chksum_reqd = 0;
+			}
+			else if (*(const int *)optval & 1)
+			{
+				/* Per RFC3542, odd offsets are not allowed */
+				done_socket(sock);
+				return EINVAL;
+			}
+			else
+			{
+				sock->conn->pcb.raw->chksum_reqd = 1;
+				sock->conn->pcb.raw->chksum_offset = (u16_t) * (const int *)optval;
+			}
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_RAW, IPV6_CHECKSUM, ..) -> %d\n",
+										s, sock->conn->pcb.raw->chksum_reqd));
+			break;
 #endif /* LWIP_IPV6 && LWIP_RAW */
-        default:
-          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_RAW, UNIMPL: optname=0x%x, ..)\n",
-                                      s, optname));
-          err = ENOPROTOOPT;
-          break;
-      }  /* switch (optname) */
-      break;
-    default:
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
-                                  s, level, optname));
-      err = ENOPROTOOPT;
-      break;
-  }  /* switch (level) */
-
-  done_socket(sock);
-  return err;
+		default:
+			LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_RAW, UNIMPL: optname=0x%x, ..)\n",
+										s, optname));
+			err = ENOPROTOOPT;
+			break;
+		} /* switch (optname) */
+		break;
+	default:
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
+									s, level, optname));
+		err = ENOPROTOOPT;
+		break;
+	} /* switch (level) */
+
+	done_socket(sock);
+	return err;
 }
 
-int
-lwip_ioctl(int s, long cmd, void *argp)
+int lwip_ioctl(int s, long cmd, void *argp)
 {
-  struct lwip_sock *sock = get_socket(s);
-  u8_t val;
+	struct lwip_sock *sock = get_socket(s);
+	u8_t val;
 #if LWIP_SO_RCVBUF
-  int recv_avail;
+	int recv_avail;
 #endif /* LWIP_SO_RCVBUF */
 
-  if (!sock) {
-    return -1;
-  }
+	if (!sock)
+	{
+		return -1;
+	}
 
-  switch (cmd) {
+	switch (cmd)
+	{
 #if LWIP_SO_RCVBUF || LWIP_FIONREAD_LINUXMODE
-    case FIONREAD:
-      if (!argp) {
-        sock_set_errno(sock, EINVAL);
-        done_socket(sock);
-        return -1;
-      }
+	case FIONREAD:
+		if (!argp)
+		{
+			sock_set_errno(sock, EINVAL);
+			done_socket(sock);
+			return -1;
+		}
 #if LWIP_FIONREAD_LINUXMODE
-      if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
-        struct netbuf *nb;
-        if (sock->lastdata.netbuf) {
-          nb = sock->lastdata.netbuf;
-          *((int *)argp) = nb->p->tot_len;
-        } else {
-          struct netbuf *rxbuf;
-          err_t err = netconn_recv_udp_raw_netbuf_flags(sock->conn, &rxbuf, NETCONN_DONTBLOCK);
-          if (err != ERR_OK) {
-            *((int *)argp) = 0;
-          } else {
-            sock->lastdata.netbuf = rxbuf;
-            *((int *)argp) = rxbuf->p->tot_len;
-          }
-        }
-        done_socket(sock);
-        return 0;
-      }
+		if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP)
+		{
+			struct netbuf *nb;
+			if (sock->lastdata.netbuf)
+			{
+				nb = sock->lastdata.netbuf;
+				*((int *)argp) = nb->p->tot_len;
+			}
+			else
+			{
+				struct netbuf *rxbuf;
+				err_t err = netconn_recv_udp_raw_netbuf_flags(sock->conn, &rxbuf, NETCONN_DONTBLOCK);
+				if (err != ERR_OK)
+				{
+					*((int *)argp) = 0;
+				}
+				else
+				{
+					sock->lastdata.netbuf = rxbuf;
+					*((int *)argp) = rxbuf->p->tot_len;
+				}
+			}
+			done_socket(sock);
+			return 0;
+		}
 #endif /* LWIP_FIONREAD_LINUXMODE */
 
 #if LWIP_SO_RCVBUF
-      /* we come here if either LWIP_FIONREAD_LINUXMODE==0 or this is a TCP socket */
-      SYS_ARCH_GET(sock->conn->recv_avail, recv_avail);
-      if (recv_avail < 0) {
-        recv_avail = 0;
-      }
-
-      /* Check if there is data left from the last recv operation. /maq 041215 */
-      if (sock->lastdata.netbuf) {
-        if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
-          recv_avail += sock->lastdata.pbuf->tot_len;
-        } else {
-          recv_avail += sock->lastdata.netbuf->p->tot_len;
-        }
-      }
-      *((int *)argp) = recv_avail;
-
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %"U16_F"\n", s, argp, *((u16_t *)argp)));
-      sock_set_errno(sock, 0);
-      done_socket(sock);
-      return 0;
-#else /* LWIP_SO_RCVBUF */
-      break;
+		/* we come here if either LWIP_FIONREAD_LINUXMODE==0 or this is a TCP socket */
+		SYS_ARCH_GET(sock->conn->recv_avail, recv_avail);
+		if (recv_avail < 0)
+		{
+			recv_avail = 0;
+		}
+
+		/* Check if there is data left from the last recv operation. /maq 041215 */
+		if (sock->lastdata.netbuf)
+		{
+			if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP)
+			{
+				recv_avail += sock->lastdata.pbuf->tot_len;
+			}
+			else
+			{
+				recv_avail += sock->lastdata.netbuf->p->tot_len;
+			}
+		}
+		*((int *)argp) = recv_avail;
+
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %" U16_F "\n", s, argp, *((u16_t *)argp)));
+		sock_set_errno(sock, 0);
+		done_socket(sock);
+		return 0;
+#else  /* LWIP_SO_RCVBUF */
+		break;
 #endif /* LWIP_SO_RCVBUF */
 #endif /* LWIP_SO_RCVBUF || LWIP_FIONREAD_LINUXMODE */
 
-    case (long)FIONBIO:
-      val = 0;
-      if (argp && *(int *)argp) {
-        val = 1;
-      }
-      netconn_set_nonblocking(sock->conn, val);
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, val));
-      sock_set_errno(sock, 0);
-      done_socket(sock);
-      return 0;
-
-    default:
-      break;
-  } /* switch (cmd) */
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
-  sock_set_errno(sock, ENOSYS); /* not yet implemented */
-  done_socket(sock);
-  return -1;
+	case (long)FIONBIO:
+		val = 0;
+		if (argp && *(int *)argp)
+		{
+			val = 1;
+		}
+		netconn_set_nonblocking(sock->conn, val);
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, val));
+		sock_set_errno(sock, 0);
+		done_socket(sock);
+		return 0;
+
+	default:
+		break;
+	} /* switch (cmd) */
+	LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
+	sock_set_errno(sock, ENOSYS); /* not yet implemented */
+	done_socket(sock);
+	return -1;
 }
 
 /** A minimal implementation of fcntl.
@@ -3836,150 +4311,165 @@ lwip_ioctl(int s, long cmd, void *argp)
  * The flag O_NONBLOCK and access modes are supported for F_GETFL, only
  * the flag O_NONBLOCK is implemented for F_SETFL.
  */
-int
-lwip_fcntl(int s, int cmd, int val)
+int lwip_fcntl(int s, int cmd, int val)
 {
-  struct lwip_sock *sock = get_socket(s);
-  int ret = -1;
-  int op_mode = 0;
-
-  if (!sock) {
-    return -1;
-  }
-
-  switch (cmd) {
-    case F_GETFL:
-      ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
-      sock_set_errno(sock, 0);
-
-      if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
+	struct lwip_sock *sock = get_socket(s);
+	int ret = -1;
+	int op_mode = 0;
+
+	if (!sock)
+	{
+		return -1;
+	}
+
+	switch (cmd)
+	{
+	case F_GETFL:
+		ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
+		sock_set_errno(sock, 0);
+
+		if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP)
+		{
 #if LWIP_TCPIP_CORE_LOCKING
-        LOCK_TCPIP_CORE();
+			LOCK_TCPIP_CORE();
 #else
-        SYS_ARCH_DECL_PROTECT(lev);
-        /* the proper thing to do here would be to get into the tcpip_thread,
-           but locking should be OK as well since we only *read* some flags */
-        SYS_ARCH_PROTECT(lev);
+			SYS_ARCH_DECL_PROTECT(lev);
+			/* the proper thing to do here would be to get into the tcpip_thread,
+			   but locking should be OK as well since we only *read* some flags */
+			SYS_ARCH_PROTECT(lev);
 #endif
 #if LWIP_TCP
-        if (sock->conn->pcb.tcp) {
-          if (!(sock->conn->pcb.tcp->flags & TF_RXCLOSED)) {
-            op_mode |= O_RDONLY;
-          }
-          if (!(sock->conn->pcb.tcp->flags & TF_FIN)) {
-            op_mode |= O_WRONLY;
-          }
-        }
+			if (sock->conn->pcb.tcp)
+			{
+				if (!(sock->conn->pcb.tcp->flags & TF_RXCLOSED))
+				{
+					op_mode |= O_RDONLY;
+				}
+				if (!(sock->conn->pcb.tcp->flags & TF_FIN))
+				{
+					op_mode |= O_WRONLY;
+				}
+			}
 #endif
 #if LWIP_TCPIP_CORE_LOCKING
-        UNLOCK_TCPIP_CORE();
+			UNLOCK_TCPIP_CORE();
 #else
-        SYS_ARCH_UNPROTECT(lev);
+			SYS_ARCH_UNPROTECT(lev);
 #endif
-      } else {
-        op_mode |= O_RDWR;
-      }
-
-      /* ensure O_RDWR for (O_RDONLY|O_WRONLY) != O_RDWR cases */
-      ret |= (op_mode == (O_RDONLY | O_WRONLY)) ? O_RDWR : op_mode;
-
-      break;
-    case F_SETFL:
-      /* Bits corresponding to the file access mode and the file creation flags [..] that are set in arg shall be ignored */
-      val &= ~(O_RDONLY | O_WRONLY | O_RDWR);
-      if ((val & ~O_NONBLOCK) == 0) {
-        /* only O_NONBLOCK, all other bits are zero */
-        netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
-        ret = 0;
-        sock_set_errno(sock, 0);
-      } else {
-        sock_set_errno(sock, ENOSYS); /* not yet implemented */
-      }
-      break;
-    default:
-      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
-      sock_set_errno(sock, ENOSYS); /* not yet implemented */
-      break;
-  }
-  done_socket(sock);
-  return ret;
+		}
+		else
+		{
+			op_mode |= O_RDWR;
+		}
+
+		/* ensure O_RDWR for (O_RDONLY|O_WRONLY) != O_RDWR cases */
+		ret |= (op_mode == (O_RDONLY | O_WRONLY)) ? O_RDWR : op_mode;
+
+		break;
+	case F_SETFL:
+		/* Bits corresponding to the file access mode and the file creation flags [..] that are set in arg shall be ignored */
+		val &= ~(O_RDONLY | O_WRONLY | O_RDWR);
+		if ((val & ~O_NONBLOCK) == 0)
+		{
+			/* only O_NONBLOCK, all other bits are zero */
+			netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
+			ret = 0;
+			sock_set_errno(sock, 0);
+		}
+		else
+		{
+			sock_set_errno(sock, ENOSYS); /* not yet implemented */
+		}
+		break;
+	default:
+		LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
+		sock_set_errno(sock, ENOSYS); /* not yet implemented */
+		break;
+	}
+	done_socket(sock);
+	return ret;
 }
 
 #if LWIP_COMPAT_SOCKETS == 2 && LWIP_POSIX_SOCKETS_IO_NAMES
-int
-fcntl(int s, int cmd, ...)
+int fcntl(int s, int cmd, ...)
 {
-  va_list ap;
-  int val;
+	va_list ap;
+	int val;
 
-  va_start(ap, cmd);
-  val = va_arg(ap, int);
-  va_end(ap);
-  return lwip_fcntl(s, cmd, val);
+	va_start(ap, cmd);
+	val = va_arg(ap, int);
+	va_end(ap);
+	return lwip_fcntl(s, cmd, val);
 }
 #endif
 
 const char *
 lwip_inet_ntop(int af, const void *src, char *dst, socklen_t size)
 {
-  const char *ret = NULL;
-  int size_int = (int)size;
-  if (size_int < 0) {
-    set_errno(ENOSPC);
-    return NULL;
-  }
-  switch (af) {
+	const char *ret = NULL;
+	int size_int = (int)size;
+	if (size_int < 0)
+	{
+		set_errno(ENOSPC);
+		return NULL;
+	}
+	switch (af)
+	{
 #if LWIP_IPV4
-    case AF_INET:
-      ret = ip4addr_ntoa_r((const ip4_addr_t *)src, dst, size_int);
-      if (ret == NULL) {
-        set_errno(ENOSPC);
-      }
-      break;
+	case AF_INET:
+		ret = ip4addr_ntoa_r((const ip4_addr_t *)src, dst, size_int);
+		if (ret == NULL)
+		{
+			set_errno(ENOSPC);
+		}
+		break;
 #endif
 #if LWIP_IPV6
-    case AF_INET6:
-      ret = ip6addr_ntoa_r((const ip6_addr_t *)src, dst, size_int);
-      if (ret == NULL) {
-        set_errno(ENOSPC);
-      }
-      break;
+	case AF_INET6:
+		ret = ip6addr_ntoa_r((const ip6_addr_t *)src, dst, size_int);
+		if (ret == NULL)
+		{
+			set_errno(ENOSPC);
+		}
+		break;
 #endif
-    default:
-      set_errno(EAFNOSUPPORT);
-      break;
-  }
-  return ret;
+	default:
+		set_errno(EAFNOSUPPORT);
+		break;
+	}
+	return ret;
 }
 
-int
-lwip_inet_pton(int af, const char *src, void *dst)
+int lwip_inet_pton(int af, const char *src, void *dst)
 {
-  int err;
-  switch (af) {
+	int err;
+	switch (af)
+	{
 #if LWIP_IPV4
-    case AF_INET:
-      err = ip4addr_aton(src, (ip4_addr_t *)dst);
-      break;
+	case AF_INET:
+		err = ip4addr_aton(src, (ip4_addr_t *)dst);
+		break;
 #endif
 #if LWIP_IPV6
-    case AF_INET6: {
-      /* convert into temporary variable since ip6_addr_t might be larger
-         than in6_addr when scopes are enabled */
-      ip6_addr_t addr;
-      err = ip6addr_aton(src, &addr);
-      if (err) {
-        memcpy(dst, &addr.addr, sizeof(addr.addr));
-      }
-      break;
-    }
+	case AF_INET6:
+	{
+		/* convert into temporary variable since ip6_addr_t might be larger
+		   than in6_addr when scopes are enabled */
+		ip6_addr_t addr;
+		err = ip6addr_aton(src, &addr);
+		if (err)
+		{
+			memcpy(dst, &addr.addr, sizeof(addr.addr));
+		}
+		break;
+	}
 #endif
-    default:
-      err = -1;
-      set_errno(EAFNOSUPPORT);
-      break;
-  }
-  return err;
+	default:
+		err = -1;
+		set_errno(EAFNOSUPPORT);
+		break;
+	}
+	return err;
 }
 
 #if LWIP_IGMP
@@ -3992,24 +4482,27 @@ lwip_inet_pton(int af, const char *src, void *dst)
 static int
 lwip_socket_register_membership(int s, const ip4_addr_t *if_addr, const ip4_addr_t *multi_addr)
 {
-  struct lwip_sock *sock = get_socket(s);
-  int i;
-
-  if (!sock) {
-    return 0;
-  }
-
-  for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++) {
-    if (socket_ipv4_multicast_memberships[i].sock == NULL) {
-      socket_ipv4_multicast_memberships[i].sock = sock;
-      ip4_addr_copy(socket_ipv4_multicast_memberships[i].if_addr, *if_addr);
-      ip4_addr_copy(socket_ipv4_multicast_memberships[i].multi_addr, *multi_addr);
-      done_socket(sock);
-      return 1;
-    }
-  }
-  done_socket(sock);
-  return 0;
+	struct lwip_sock *sock = get_socket(s);
+	int i;
+
+	if (!sock)
+	{
+		return 0;
+	}
+
+	for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++)
+	{
+		if (socket_ipv4_multicast_memberships[i].sock == NULL)
+		{
+			socket_ipv4_multicast_memberships[i].sock = sock;
+			ip4_addr_copy(socket_ipv4_multicast_memberships[i].if_addr, *if_addr);
+			ip4_addr_copy(socket_ipv4_multicast_memberships[i].multi_addr, *multi_addr);
+			done_socket(sock);
+			return 1;
+		}
+	}
+	done_socket(sock);
+	return 0;
 }
 
 /** Unregister a previously registered membership. This prevents dropping the membership
@@ -4020,24 +4513,27 @@ lwip_socket_register_membership(int s, const ip4_addr_t *if_addr, const ip4_addr
 static void
 lwip_socket_unregister_membership(int s, const ip4_addr_t *if_addr, const ip4_addr_t *multi_addr)
 {
-  struct lwip_sock *sock = get_socket(s);
-  int i;
-
-  if (!sock) {
-    return;
-  }
-
-  for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++) {
-    if ((socket_ipv4_multicast_memberships[i].sock == sock) &&
-        ip4_addr_cmp(&socket_ipv4_multicast_memberships[i].if_addr, if_addr) &&
-        ip4_addr_cmp(&socket_ipv4_multicast_memberships[i].multi_addr, multi_addr)) {
-      socket_ipv4_multicast_memberships[i].sock = NULL;
-      ip4_addr_set_zero(&socket_ipv4_multicast_memberships[i].if_addr);
-      ip4_addr_set_zero(&socket_ipv4_multicast_memberships[i].multi_addr);
-      break;
-    }
-  }
-  done_socket(sock);
+	struct lwip_sock *sock = get_socket(s);
+	int i;
+
+	if (!sock)
+	{
+		return;
+	}
+
+	for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++)
+	{
+		if ((socket_ipv4_multicast_memberships[i].sock == sock) &&
+			ip4_addr_cmp(&socket_ipv4_multicast_memberships[i].if_addr, if_addr) &&
+			ip4_addr_cmp(&socket_ipv4_multicast_memberships[i].multi_addr, multi_addr))
+		{
+			socket_ipv4_multicast_memberships[i].sock = NULL;
+			ip4_addr_set_zero(&socket_ipv4_multicast_memberships[i].if_addr);
+			ip4_addr_set_zero(&socket_ipv4_multicast_memberships[i].multi_addr);
+			break;
+		}
+	}
+	done_socket(sock);
 }
 
 /** Drop all memberships of a socket that were not dropped explicitly via setsockopt.
@@ -4047,26 +4543,29 @@ lwip_socket_unregister_membership(int s, const ip4_addr_t *if_addr, const ip4_ad
 static void
 lwip_socket_drop_registered_memberships(int s)
 {
-  struct lwip_sock *sock = get_socket(s);
-  int i;
-
-  if (!sock) {
-    return;
-  }
-
-  for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++) {
-    if (socket_ipv4_multicast_memberships[i].sock == sock) {
-      ip_addr_t multi_addr, if_addr;
-      ip_addr_copy_from_ip4(multi_addr, socket_ipv4_multicast_memberships[i].multi_addr);
-      ip_addr_copy_from_ip4(if_addr, socket_ipv4_multicast_memberships[i].if_addr);
-      socket_ipv4_multicast_memberships[i].sock = NULL;
-      ip4_addr_set_zero(&socket_ipv4_multicast_memberships[i].if_addr);
-      ip4_addr_set_zero(&socket_ipv4_multicast_memberships[i].multi_addr);
-
-      netconn_join_leave_group(sock->conn, &multi_addr, &if_addr, NETCONN_LEAVE);
-    }
-  }
-  done_socket(sock);
+	struct lwip_sock *sock = get_socket(s);
+	int i;
+
+	if (!sock)
+	{
+		return;
+	}
+
+	for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++)
+	{
+		if (socket_ipv4_multicast_memberships[i].sock == sock)
+		{
+			ip_addr_t multi_addr, if_addr;
+			ip_addr_copy_from_ip4(multi_addr, socket_ipv4_multicast_memberships[i].multi_addr);
+			ip_addr_copy_from_ip4(if_addr, socket_ipv4_multicast_memberships[i].if_addr);
+			socket_ipv4_multicast_memberships[i].sock = NULL;
+			ip4_addr_set_zero(&socket_ipv4_multicast_memberships[i].if_addr);
+			ip4_addr_set_zero(&socket_ipv4_multicast_memberships[i].multi_addr);
+
+			netconn_join_leave_group(sock->conn, &multi_addr, &if_addr, NETCONN_LEAVE);
+		}
+	}
+	done_socket(sock);
 }
 #endif /* LWIP_IGMP */
 
@@ -4080,24 +4579,27 @@ lwip_socket_drop_registered_memberships(int s)
 static int
 lwip_socket_register_mld6_membership(int s, unsigned int if_idx, const ip6_addr_t *multi_addr)
 {
-  struct lwip_sock *sock = get_socket(s);
-  int i;
-
-  if (!sock) {
-    return 0;
-  }
-
-  for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++) {
-    if (socket_ipv6_multicast_memberships[i].sock == NULL) {
-      socket_ipv6_multicast_memberships[i].sock   = sock;
-      socket_ipv6_multicast_memberships[i].if_idx = (u8_t)if_idx;
-      ip6_addr_copy(socket_ipv6_multicast_memberships[i].multi_addr, *multi_addr);
-      done_socket(sock);
-      return 1;
-    }
-  }
-  done_socket(sock);
-  return 0;
+	struct lwip_sock *sock = get_socket(s);
+	int i;
+
+	if (!sock)
+	{
+		return 0;
+	}
+
+	for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++)
+	{
+		if (socket_ipv6_multicast_memberships[i].sock == NULL)
+		{
+			socket_ipv6_multicast_memberships[i].sock = sock;
+			socket_ipv6_multicast_memberships[i].if_idx = (u8_t)if_idx;
+			ip6_addr_copy(socket_ipv6_multicast_memberships[i].multi_addr, *multi_addr);
+			done_socket(sock);
+			return 1;
+		}
+	}
+	done_socket(sock);
+	return 0;
 }
 
 /** Unregister a previously registered MLD6 membership. This prevents dropping the membership
@@ -4108,24 +4610,27 @@ lwip_socket_register_mld6_membership(int s, unsigned int if_idx, const ip6_addr_
 static void
 lwip_socket_unregister_mld6_membership(int s, unsigned int if_idx, const ip6_addr_t *multi_addr)
 {
-  struct lwip_sock *sock = get_socket(s);
-  int i;
-
-  if (!sock) {
-    return;
-  }
-
-  for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++) {
-    if ((socket_ipv6_multicast_memberships[i].sock   == sock) &&
-        (socket_ipv6_multicast_memberships[i].if_idx == if_idx) &&
-        ip6_addr_cmp(&socket_ipv6_multicast_memberships[i].multi_addr, multi_addr)) {
-      socket_ipv6_multicast_memberships[i].sock   = NULL;
-      socket_ipv6_multicast_memberships[i].if_idx = NETIF_NO_INDEX;
-      ip6_addr_set_zero(&socket_ipv6_multicast_memberships[i].multi_addr);
-      break;
-    }
-  }
-  done_socket(sock);
+	struct lwip_sock *sock = get_socket(s);
+	int i;
+
+	if (!sock)
+	{
+		return;
+	}
+
+	for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++)
+	{
+		if ((socket_ipv6_multicast_memberships[i].sock == sock) &&
+			(socket_ipv6_multicast_memberships[i].if_idx == if_idx) &&
+			ip6_addr_cmp(&socket_ipv6_multicast_memberships[i].multi_addr, multi_addr))
+		{
+			socket_ipv6_multicast_memberships[i].sock = NULL;
+			socket_ipv6_multicast_memberships[i].if_idx = NETIF_NO_INDEX;
+			ip6_addr_set_zero(&socket_ipv6_multicast_memberships[i].multi_addr);
+			break;
+		}
+	}
+	done_socket(sock);
 }
 
 /** Drop all MLD6 memberships of a socket that were not dropped explicitly via setsockopt.
@@ -4135,29 +4640,32 @@ lwip_socket_unregister_mld6_membership(int s, unsigned int if_idx, const ip6_add
 static void
 lwip_socket_drop_registered_mld6_memberships(int s)
 {
-  struct lwip_sock *sock = get_socket(s);
-  int i;
-
-  if (!sock) {
-    return;
-  }
-
-  for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++) {
-    if (socket_ipv6_multicast_memberships[i].sock == sock) {
-      ip_addr_t multi_addr;
-      u8_t if_idx;
-
-      ip_addr_copy_from_ip6(multi_addr, socket_ipv6_multicast_memberships[i].multi_addr);
-      if_idx = socket_ipv6_multicast_memberships[i].if_idx;
-
-      socket_ipv6_multicast_memberships[i].sock   = NULL;
-      socket_ipv6_multicast_memberships[i].if_idx = NETIF_NO_INDEX;
-      ip6_addr_set_zero(&socket_ipv6_multicast_memberships[i].multi_addr);
-
-      netconn_join_leave_group_netif(sock->conn, &multi_addr, if_idx, NETCONN_LEAVE);
-    }
-  }
-  done_socket(sock);
+	struct lwip_sock *sock = get_socket(s);
+	int i;
+
+	if (!sock)
+	{
+		return;
+	}
+
+	for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++)
+	{
+		if (socket_ipv6_multicast_memberships[i].sock == sock)
+		{
+			ip_addr_t multi_addr;
+			u8_t if_idx;
+
+			ip_addr_copy_from_ip6(multi_addr, socket_ipv6_multicast_memberships[i].multi_addr);
+			if_idx = socket_ipv6_multicast_memberships[i].if_idx;
+
+			socket_ipv6_multicast_memberships[i].sock = NULL;
+			socket_ipv6_multicast_memberships[i].if_idx = NETIF_NO_INDEX;
+			ip6_addr_set_zero(&socket_ipv6_multicast_memberships[i].multi_addr);
+
+			netconn_join_leave_group_netif(sock->conn, &multi_addr, if_idx, NETCONN_LEAVE);
+		}
+	}
+	done_socket(sock);
 }
 #endif /* LWIP_IPV6_MLD */
 
diff --git a/src/core/ipv4/etharp.c b/src/core/ipv4/etharp.c
index c3a5a10..d6a91a8 100644
--- a/src/core/ipv4/etharp.c
+++ b/src/core/ipv4/etharp.c
@@ -765,7 +765,6 @@ etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, netif_addr_idx_t
       }
     }
   }
-
   return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr, ETHTYPE_IP);
 }
 
@@ -871,7 +870,6 @@ etharp_output(struct netif *netif, struct pbuf *q, const ip4_addr_t *ipaddr)
       }
     }
 #endif /* LWIP_NETIF_HWADDRHINT */
-
     /* find stable entry: do this here since this is a critical path for
        throughput and etharp_find_entry() is kind of slow */
     for (i = 0; i < ARP_TABLE_SIZE; i++) {
diff --git a/src/core/ipv4/ip4.c b/src/core/ipv4/ip4.c
index 26c26a9..e5ba852 100644
--- a/src/core/ipv4/ip4.c
+++ b/src/core/ipv4/ip4.c
@@ -67,16 +67,16 @@
  * generate the IP checksum (in contrast to calculating it on-the-fly). */
 #ifndef LWIP_INLINE_IP_CHKSUM
 #if LWIP_CHECKSUM_CTRL_PER_NETIF
-#define LWIP_INLINE_IP_CHKSUM   0
+#define LWIP_INLINE_IP_CHKSUM 0
 #else /* LWIP_CHECKSUM_CTRL_PER_NETIF */
-#define LWIP_INLINE_IP_CHKSUM   1
+#define LWIP_INLINE_IP_CHKSUM 1
 #endif /* LWIP_CHECKSUM_CTRL_PER_NETIF */
 #endif
 
 #if LWIP_INLINE_IP_CHKSUM && CHECKSUM_GEN_IP
-#define CHECKSUM_GEN_IP_INLINE  1
+#define CHECKSUM_GEN_IP_INLINE 1
 #else
-#define CHECKSUM_GEN_IP_INLINE  0
+#define CHECKSUM_GEN_IP_INLINE 0
 #endif
 
 #if LWIP_DHCP || defined(LWIP_IP_ACCEPT_UDP_PORT)
@@ -89,8 +89,7 @@
  */
 #if LWIP_DHCP && defined(LWIP_IP_ACCEPT_UDP_PORT)
 /* accept DHCP client port and custom port */
-#define IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(port) (((port) == PP_NTOHS(LWIP_IANA_PORT_DHCP_CLIENT)) \
-         || (LWIP_IP_ACCEPT_UDP_PORT(port)))
+#define IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(port) (((port) == PP_NTOHS(LWIP_IANA_PORT_DHCP_CLIENT)) || (LWIP_IP_ACCEPT_UDP_PORT(port)))
 #elif defined(LWIP_IP_ACCEPT_UDP_PORT) /* LWIP_DHCP && defined(LWIP_IP_ACCEPT_UDP_PORT) */
 /* accept custom port only */
 #define IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(port) (LWIP_IP_ACCEPT_UDP_PORT(port))
@@ -113,10 +112,9 @@ static struct netif *ip4_default_multicast_netif;
 /**
  * @ingroup ip4
  * Set a default netif for IPv4 multicast. */
-void
-ip4_set_default_multicast_netif(struct netif *default_multicast_netif)
+void ip4_set_default_multicast_netif(struct netif *default_multicast_netif)
 {
-  ip4_default_multicast_netif = default_multicast_netif;
+	ip4_default_multicast_netif = default_multicast_netif;
 }
 #endif /* LWIP_MULTICAST_TX_OPTIONS */
 
@@ -128,14 +126,16 @@ ip4_set_default_multicast_netif(struct netif *default_multicast_netif)
 struct netif *
 ip4_route_src(const ip4_addr_t *src, const ip4_addr_t *dest)
 {
-  if (src != NULL) {
-    /* when src==NULL, the hook is called from ip4_route(dest) */
-    struct netif *netif = LWIP_HOOK_IP4_ROUTE_SRC(src, dest);
-    if (netif != NULL) {
-      return netif;
-    }
-  }
-  return ip4_route(dest);
+	if (src != NULL)
+	{
+		/* when src==NULL, the hook is called from ip4_route(dest) */
+		struct netif *netif = LWIP_HOOK_IP4_ROUTE_SRC(src, dest);
+		if (netif != NULL)
+		{
+			return netif;
+		}
+	}
+	return ip4_route(dest);
 }
 #endif /* LWIP_HOOK_IP4_ROUTE_SRC */
 
@@ -152,79 +152,91 @@ struct netif *
 ip4_route(const ip4_addr_t *dest)
 {
 #if !LWIP_SINGLE_NETIF
-  struct netif *netif;
+	struct netif *netif;
 
-  LWIP_ASSERT_CORE_LOCKED();
+	LWIP_ASSERT_CORE_LOCKED();
 
 #if LWIP_MULTICAST_TX_OPTIONS
-  /* Use administratively selected interface for multicast by default */
-  if (ip4_addr_ismulticast(dest) && ip4_default_multicast_netif) {
-    return ip4_default_multicast_netif;
-  }
+	/* Use administratively selected interface for multicast by default */
+	if (ip4_addr_ismulticast(dest) && ip4_default_multicast_netif)
+	{
+		return ip4_default_multicast_netif;
+	}
 #endif /* LWIP_MULTICAST_TX_OPTIONS */
 
-  /* bug #54569: in case LWIP_SINGLE_NETIF=1 and LWIP_DEBUGF() disabled, the following loop is optimized away */
-  LWIP_UNUSED_ARG(dest);
-
-  /* iterate through netifs */
-  NETIF_FOREACH(netif) {
-    /* is the netif up, does it have a link and a valid address? */
-    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
-      /* network mask matches? */
-      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
-        /* return netif on which to forward IP packet */
-        return netif;
-      }
-      /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
-      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
-        /* return netif on which to forward IP packet */
-        return netif;
-      }
-    }
-  }
+	/* bug #54569: in case LWIP_SINGLE_NETIF=1 and LWIP_DEBUGF() disabled, the following loop is optimized away */
+	LWIP_UNUSED_ARG(dest);
+
+	/* iterate through netifs */
+	NETIF_FOREACH(netif)
+	{
+		/* is the netif up, does it have a link and a valid address? */
+		if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif)))
+		{
+			/* network mask matches? */
+			if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif)))
+			{
+				/* return netif on which to forward IP packet */
+				return netif;
+			}
+			/* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
+			if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif)))
+			{
+				/* return netif on which to forward IP packet */
+				return netif;
+			}
+		}
+	}
 
 #if LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF
-  /* loopif is disabled, looopback traffic is passed through any netif */
-  if (ip4_addr_isloopback(dest)) {
-    /* don't check for link on loopback traffic */
-    if (netif_default != NULL && netif_is_up(netif_default)) {
-      return netif_default;
-    }
-    /* default netif is not up, just use any netif for loopback traffic */
-    NETIF_FOREACH(netif) {
-      if (netif_is_up(netif)) {
-        return netif;
-      }
-    }
-    return NULL;
-  }
+	/* loopif is disabled, looopback traffic is passed through any netif */
+	if (ip4_addr_isloopback(dest))
+	{
+		/* don't check for link on loopback traffic */
+		if (netif_default != NULL && netif_is_up(netif_default))
+		{
+			return netif_default;
+		}
+		/* default netif is not up, just use any netif for loopback traffic */
+		NETIF_FOREACH(netif)
+		{
+			if (netif_is_up(netif))
+			{
+				return netif;
+			}
+		}
+		return NULL;
+	}
 #endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
 
 #ifdef LWIP_HOOK_IP4_ROUTE_SRC
-  netif = LWIP_HOOK_IP4_ROUTE_SRC(NULL, dest);
-  if (netif != NULL) {
-    return netif;
-  }
+	netif = LWIP_HOOK_IP4_ROUTE_SRC(NULL, dest);
+	if (netif != NULL)
+	{
+		return netif;
+	}
 #elif defined(LWIP_HOOK_IP4_ROUTE)
-  netif = LWIP_HOOK_IP4_ROUTE(dest);
-  if (netif != NULL) {
-    return netif;
-  }
+	netif = LWIP_HOOK_IP4_ROUTE(dest);
+	if (netif != NULL)
+	{
+		return netif;
+	}
 #endif
 #endif /* !LWIP_SINGLE_NETIF */
 
-  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
-      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
-    /* No matching netif found and default netif is not usable.
-       If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
-    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
-                ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
-    IP_STATS_INC(ip.rterr);
-    MIB2_STATS_INC(mib2.ipoutnoroutes);
-    return NULL;
-  }
-
-  return netif_default;
+	if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
+		 ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest))
+	{
+		/* No matching netif found and default netif is not usable.
+			If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
+		LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %" U16_F ".%" U16_F ".%" U16_F ".%" U16_F "\n",
+																		ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
+		IP_STATS_INC(ip.rterr);
+		MIB2_STATS_INC(mib2.ipoutnoroutes);
+		return NULL;
+	}
+
+	return netif_default;
 }
 
 #if IP_FORWARD
@@ -238,34 +250,40 @@ ip4_route(const ip4_addr_t *dest)
 static int
 ip4_canforward(struct pbuf *p)
 {
-  u32_t addr = lwip_htonl(ip4_addr_get_u32(ip4_current_dest_addr()));
+	u32_t addr = lwip_htonl(ip4_addr_get_u32(ip4_current_dest_addr()));
 
 #ifdef LWIP_HOOK_IP4_CANFORWARD
-  int ret = LWIP_HOOK_IP4_CANFORWARD(p, addr);
-  if (ret >= 0) {
-    return ret;
-  }
+	int ret = LWIP_HOOK_IP4_CANFORWARD(p, addr);
+	if (ret >= 0)
+	{
+		return ret;
+	}
 #endif /* LWIP_HOOK_IP4_CANFORWARD */
 
-  if (p->flags & PBUF_FLAG_LLBCAST) {
-    /* don't route link-layer broadcasts */
-    return 0;
-  }
-  if ((p->flags & PBUF_FLAG_LLMCAST) || IP_MULTICAST(addr)) {
-    /* don't route link-layer multicasts (use LWIP_HOOK_IP4_CANFORWARD instead) */
-    return 0;
-  }
-  if (IP_EXPERIMENTAL(addr)) {
-    return 0;
-  }
-  if (IP_CLASSA(addr)) {
-    u32_t net = addr & IP_CLASSA_NET;
-    if ((net == 0) || (net == ((u32_t)IP_LOOPBACKNET << IP_CLASSA_NSHIFT))) {
-      /* don't route loopback packets */
-      return 0;
-    }
-  }
-  return 1;
+	if (p->flags & PBUF_FLAG_LLBCAST)
+	{
+		/* don't route link-layer broadcasts */
+		return 0;
+	}
+	if ((p->flags & PBUF_FLAG_LLMCAST) || IP_MULTICAST(addr))
+	{
+		/* don't route link-layer multicasts (use LWIP_HOOK_IP4_CANFORWARD instead) */
+		return 0;
+	}
+	if (IP_EXPERIMENTAL(addr))
+	{
+		return 0;
+	}
+	if (IP_CLASSA(addr))
+	{
+		u32_t net = addr & IP_CLASSA_NET;
+		if ((net == 0) || (net == ((u32_t)IP_LOOPBACKNET << IP_CLASSA_NSHIFT)))
+		{
+			/* don't route loopback packets */
+			return 0;
+		}
+	}
+	return 1;
 }
 
 /**
@@ -280,92 +298,105 @@ ip4_canforward(struct pbuf *p)
 static void
 ip4_forward(struct pbuf *p, struct ip_hdr *iphdr, struct netif *inp)
 {
-  struct netif *netif;
-
-  PERF_START;
-  LWIP_UNUSED_ARG(inp);
-
-  if (!ip4_canforward(p)) {
-    goto return_noroute;
-  }
-
-  /* RFC3927 2.7: do not forward link-local addresses */
-  if (ip4_addr_islinklocal(ip4_current_dest_addr())) {
-    LWIP_DEBUGF(IP_DEBUG, ("ip4_forward: not forwarding LLA %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
-                           ip4_addr1_16(ip4_current_dest_addr()), ip4_addr2_16(ip4_current_dest_addr()),
-                           ip4_addr3_16(ip4_current_dest_addr()), ip4_addr4_16(ip4_current_dest_addr())));
-    goto return_noroute;
-  }
-
-  /* Find network interface where to forward this IP packet to. */
-  netif = ip4_route_src(ip4_current_src_addr(), ip4_current_dest_addr());
-  if (netif == NULL) {
-    LWIP_DEBUGF(IP_DEBUG, ("ip4_forward: no forwarding route for %"U16_F".%"U16_F".%"U16_F".%"U16_F" found\n",
-                           ip4_addr1_16(ip4_current_dest_addr()), ip4_addr2_16(ip4_current_dest_addr()),
-                           ip4_addr3_16(ip4_current_dest_addr()), ip4_addr4_16(ip4_current_dest_addr())));
-    /* @todo: send ICMP_DUR_NET? */
-    goto return_noroute;
-  }
+	struct netif *netif;
+
+	PERF_START;
+	LWIP_UNUSED_ARG(inp);
+
+	if (!ip4_canforward(p))
+	{
+		goto return_noroute;
+	}
+
+	/* RFC3927 2.7: do not forward link-local addresses */
+	if (ip4_addr_islinklocal(ip4_current_dest_addr()))
+	{
+		LWIP_DEBUGF(IP_DEBUG, ("ip4_forward: not forwarding LLA %" U16_F ".%" U16_F ".%" U16_F ".%" U16_F "\n",
+									  ip4_addr1_16(ip4_current_dest_addr()), ip4_addr2_16(ip4_current_dest_addr()),
+									  ip4_addr3_16(ip4_current_dest_addr()), ip4_addr4_16(ip4_current_dest_addr())));
+		goto return_noroute;
+	}
+
+	/* Find network interface where to forward this IP packet to. */
+	netif = ip4_route_src(ip4_current_src_addr(), ip4_current_dest_addr());
+	if (netif == NULL)
+	{
+		LWIP_DEBUGF(IP_DEBUG, ("ip4_forward: no forwarding route for %" U16_F ".%" U16_F ".%" U16_F ".%" U16_F " found\n",
+									  ip4_addr1_16(ip4_current_dest_addr()), ip4_addr2_16(ip4_current_dest_addr()),
+									  ip4_addr3_16(ip4_current_dest_addr()), ip4_addr4_16(ip4_current_dest_addr())));
+		/* @todo: send ICMP_DUR_NET? */
+		goto return_noroute;
+	}
 #if !IP_FORWARD_ALLOW_TX_ON_RX_NETIF
-  /* Do not forward packets onto the same network interface on which
-   * they arrived. */
-  if (netif == inp) {
-    LWIP_DEBUGF(IP_DEBUG, ("ip4_forward: not bouncing packets back on incoming interface.\n"));
-    goto return_noroute;
-  }
+	/* Do not forward packets onto the same network interface on which
+	 * they arrived. */
+	if (netif == inp)
+	{
+		LWIP_DEBUGF(IP_DEBUG, ("ip4_forward: not bouncing packets back on incoming interface.\n"));
+		goto return_noroute;
+	}
 #endif /* IP_FORWARD_ALLOW_TX_ON_RX_NETIF */
 
-  /* decrement TTL */
-  IPH_TTL_SET(iphdr, IPH_TTL(iphdr) - 1);
-  /* send ICMP if TTL == 0 */
-  if (IPH_TTL(iphdr) == 0) {
-    MIB2_STATS_INC(mib2.ipinhdrerrors);
+	/* decrement TTL */
+	IPH_TTL_SET(iphdr, IPH_TTL(iphdr) - 1);
+	/* send ICMP if TTL == 0 */
+	if (IPH_TTL(iphdr) == 0)
+	{
+		MIB2_STATS_INC(mib2.ipinhdrerrors);
 #if LWIP_ICMP
-    /* Don't send ICMP messages in response to ICMP messages */
-    if (IPH_PROTO(iphdr) != IP_PROTO_ICMP) {
-      icmp_time_exceeded(p, ICMP_TE_TTL);
-    }
+		/* Don't send ICMP messages in response to ICMP messages */
+		if (IPH_PROTO(iphdr) != IP_PROTO_ICMP)
+		{
+			icmp_time_exceeded(p, ICMP_TE_TTL);
+		}
 #endif /* LWIP_ICMP */
-    return;
-  }
-
-  /* Incrementally update the IP checksum. */
-  if (IPH_CHKSUM(iphdr) >= PP_HTONS(0xffffU - 0x100)) {
-    IPH_CHKSUM_SET(iphdr, (u16_t)(IPH_CHKSUM(iphdr) + PP_HTONS(0x100) + 1));
-  } else {
-    IPH_CHKSUM_SET(iphdr, (u16_t)(IPH_CHKSUM(iphdr) + PP_HTONS(0x100)));
-  }
-
-  LWIP_DEBUGF(IP_DEBUG, ("ip4_forward: forwarding packet to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
-                         ip4_addr1_16(ip4_current_dest_addr()), ip4_addr2_16(ip4_current_dest_addr()),
-                         ip4_addr3_16(ip4_current_dest_addr()), ip4_addr4_16(ip4_current_dest_addr())));
-
-  IP_STATS_INC(ip.fw);
-  MIB2_STATS_INC(mib2.ipforwdatagrams);
-  IP_STATS_INC(ip.xmit);
-
-  PERF_STOP("ip4_forward");
-  /* don't fragment if interface has mtu set to 0 [loopif] */
-  if (netif->mtu && (p->tot_len > netif->mtu)) {
-    if ((IPH_OFFSET(iphdr) & PP_NTOHS(IP_DF)) == 0) {
+		return;
+	}
+
+	/* Incrementally update the IP checksum. */
+	if (IPH_CHKSUM(iphdr) >= PP_HTONS(0xffffU - 0x100))
+	{
+		IPH_CHKSUM_SET(iphdr, (u16_t)(IPH_CHKSUM(iphdr) + PP_HTONS(0x100) + 1));
+	}
+	else
+	{
+		IPH_CHKSUM_SET(iphdr, (u16_t)(IPH_CHKSUM(iphdr) + PP_HTONS(0x100)));
+	}
+
+	LWIP_DEBUGF(IP_DEBUG, ("ip4_forward: forwarding packet to %" U16_F ".%" U16_F ".%" U16_F ".%" U16_F "\n",
+								  ip4_addr1_16(ip4_current_dest_addr()), ip4_addr2_16(ip4_current_dest_addr()),
+								  ip4_addr3_16(ip4_current_dest_addr()), ip4_addr4_16(ip4_current_dest_addr())));
+
+	IP_STATS_INC(ip.fw);
+	MIB2_STATS_INC(mib2.ipforwdatagrams);
+	IP_STATS_INC(ip.xmit);
+
+	PERF_STOP("ip4_forward");
+	/* don't fragment if interface has mtu set to 0 [loopif] */
+	if (netif->mtu && (p->tot_len > netif->mtu))
+	{
+		if ((IPH_OFFSET(iphdr) & PP_NTOHS(IP_DF)) == 0)
+		{
 #if IP_FRAG
-      ip4_frag(p, netif, ip4_current_dest_addr());
-#else /* IP_FRAG */
-      /* @todo: send ICMP Destination Unreachable code 13 "Communication administratively prohibited"? */
+			ip4_frag(p, netif, ip4_current_dest_addr());
+#else	 /* IP_FRAG */
+			/* @todo: send ICMP Destination Unreachable code 13 "Communication administratively prohibited"? */
 #endif /* IP_FRAG */
-    } else {
+		}
+		else
+		{
 #if LWIP_ICMP
-      /* send ICMP Destination Unreachable code 4: "Fragmentation Needed and DF Set" */
-      icmp_dest_unreach(p, ICMP_DUR_FRAG);
+			/* send ICMP Destination Unreachable code 4: "Fragmentation Needed and DF Set" */
+			icmp_dest_unreach(p, ICMP_DUR_FRAG);
 #endif /* LWIP_ICMP */
-    }
-    return;
-  }
-  /* transmit pbuf on chosen interface */
-  netif->output(netif, p, ip4_current_dest_addr());
-  return;
+		}
+		return;
+	}
+	/* transmit pbuf on chosen interface */
+	netif->output(netif, p, ip4_current_dest_addr());
+	return;
 return_noroute:
-  MIB2_STATS_INC(mib2.ipoutnoroutes);
+	MIB2_STATS_INC(mib2.ipoutnoroutes);
 }
 #endif /* IP_FORWARD */
 
@@ -373,39 +404,42 @@ return_noroute:
 static int
 ip4_input_accept(struct netif *netif)
 {
-  LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%"X32_F" netif->ip_addr 0x%"X32_F" (0x%"X32_F", 0x%"X32_F", 0x%"X32_F")\n",
-                         ip4_addr_get_u32(ip4_current_dest_addr()), ip4_addr_get_u32(netif_ip4_addr(netif)),
-                         ip4_addr_get_u32(ip4_current_dest_addr()) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
-                         ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
-                         ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));
-
-  /* interface is up and configured? */
-  if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
-    /* unicast to this interface address? */
-    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
-        /* or broadcast on this interface network address? */
-        ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
+	LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%" X32_F " netif->ip_addr 0x%" X32_F " (0x%" X32_F ", 0x%" X32_F ", 0x%" X32_F ")\n",
+								  ip4_addr_get_u32(ip4_current_dest_addr()), ip4_addr_get_u32(netif_ip4_addr(netif)),
+								  ip4_addr_get_u32(ip4_current_dest_addr()) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
+								  ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
+								  ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));
+
+	/* interface is up and configured? */
+	if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif))))
+	{
+		/* unicast to this interface address? */
+		if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
+			 /* or broadcast on this interface network address? */
+			 ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
 #if LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF
-        || (ip4_addr_get_u32(ip4_current_dest_addr()) == PP_HTONL(IPADDR_LOOPBACK))
+			 || (ip4_addr_get_u32(ip4_current_dest_addr()) == PP_HTONL(IPADDR_LOOPBACK))
 #endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
-       ) {
-      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: packet accepted on interface %c%c\n",
-                             netif->name[0], netif->name[1]));
-      /* accept on this netif */
-      return 1;
-    }
+		)
+		{
+			LWIP_DEBUGF(IP_DEBUG, ("ip4_input: packet accepted on interface %c%c\n",
+										  netif->name[0], netif->name[1]));
+			/* accept on this netif */
+			return 1;
+		}
 #if LWIP_AUTOIP
-    /* connections to link-local addresses must persist after changing
-        the netif's address (RFC3927 ch. 1.9) */
-    if (autoip_accept_packet(netif, ip4_current_dest_addr())) {
-      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: LLA packet accepted on interface %c%c\n",
-                             netif->name[0], netif->name[1]));
-      /* accept on this netif */
-      return 1;
-    }
+		/* connections to link-local addresses must persist after changing
+			 the netif's address (RFC3927 ch. 1.9) */
+		if (autoip_accept_packet(netif, ip4_current_dest_addr()))
+		{
+			LWIP_DEBUGF(IP_DEBUG, ("ip4_input: LLA packet accepted on interface %c%c\n",
+										  netif->name[0], netif->name[1]));
+			/* accept on this netif */
+			return 1;
+		}
 #endif /* LWIP_AUTOIP */
-  }
-  return 0;
+	}
+	return 0;
 }
 
 /**
@@ -422,340 +456,379 @@ ip4_input_accept(struct netif *netif)
  * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
  *         processed, but currently always returns ERR_OK)
  */
-err_t
-ip4_input(struct pbuf *p, struct netif *inp)
+err_t ip4_input(struct pbuf *p, struct netif *inp)
 {
-  const struct ip_hdr *iphdr;
-  struct netif *netif;
-  u16_t iphdr_hlen;
-  u16_t iphdr_len;
+	const struct ip_hdr *iphdr;
+	struct netif *netif;
+	u16_t iphdr_hlen;
+	u16_t iphdr_len;
 #if IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP
-  int check_ip_src = 1;
+	int check_ip_src = 1;
 #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP */
 #if LWIP_RAW
-  raw_input_state_t raw_status;
+	raw_input_state_t raw_status;
 #endif /* LWIP_RAW */
 
-  LWIP_ASSERT_CORE_LOCKED();
+	LWIP_ASSERT_CORE_LOCKED();
 
-  IP_STATS_INC(ip.recv);
-  MIB2_STATS_INC(mib2.ipinreceives);
+	IP_STATS_INC(ip.recv);
+	MIB2_STATS_INC(mib2.ipinreceives);
 
-  /* identify the IP header */
-  iphdr = (struct ip_hdr *)p->payload;
-  if (IPH_V(iphdr) != 4) {
-    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
-    ip4_debug_print(p);
-    pbuf_free(p);
-    IP_STATS_INC(ip.err);
-    IP_STATS_INC(ip.drop);
-    MIB2_STATS_INC(mib2.ipinhdrerrors);
-    return ERR_OK;
-  }
+	/* identify the IP header */
+	iphdr = (struct ip_hdr *)p->payload;
+	if (IPH_V(iphdr) != 4)
+	{
+		LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %" U16_F "\n", (u16_t)IPH_V(iphdr)));
+		ip4_debug_print(p);
+		pbuf_free(p);
+		IP_STATS_INC(ip.err);
+		IP_STATS_INC(ip.drop);
+		MIB2_STATS_INC(mib2.ipinhdrerrors);
+		return ERR_OK;
+	}
 
 #ifdef LWIP_HOOK_IP4_INPUT
-  if (LWIP_HOOK_IP4_INPUT(p, inp)) {
-    /* the packet has been eaten */
-    return ERR_OK;
-  }
+	if (LWIP_HOOK_IP4_INPUT(p, inp))
+	{
+		/* the packet has been eaten */
+		return ERR_OK;
+	}
 #endif
 
-  /* obtain IP header length in bytes */
-  iphdr_hlen = IPH_HL_BYTES(iphdr);
-  /* obtain ip length in bytes */
-  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
-
-  /* Trim pbuf. This is especially required for packets < 60 bytes. */
-  if (iphdr_len < p->tot_len) {
-    pbuf_realloc(p, iphdr_len);
-  }
-
-  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
-  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
-    if (iphdr_hlen < IP_HLEN) {
-      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
-                  ("ip4_input: short IP header (%"U16_F" bytes) received, IP packet dropped\n", iphdr_hlen));
-    }
-    if (iphdr_hlen > p->len) {
-      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
-                  ("IP header (len %"U16_F") does not fit in first pbuf (len %"U16_F"), IP packet dropped.\n",
-                   iphdr_hlen, p->len));
-    }
-    if (iphdr_len > p->tot_len) {
-      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
-                  ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
-                   iphdr_len, p->tot_len));
-    }
-    /* free (drop) packet pbufs */
-    pbuf_free(p);
-    IP_STATS_INC(ip.lenerr);
-    IP_STATS_INC(ip.drop);
-    MIB2_STATS_INC(mib2.ipindiscards);
-    return ERR_OK;
-  }
-
-  /* verify checksum */
+	/* obtain IP header length in bytes */
+	iphdr_hlen = IPH_HL_BYTES(iphdr);
+	/* obtain ip length in bytes */
+	iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
+
+	/* Trim pbuf. This is especially required for packets < 60 bytes. */
+	if (iphdr_len < p->tot_len)
+	{
+		pbuf_realloc(p, iphdr_len);
+	}
+
+	/* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
+	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN))
+	{
+		if (iphdr_hlen < IP_HLEN)
+		{
+			LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
+							("ip4_input: short IP header (%" U16_F " bytes) received, IP packet dropped\n", iphdr_hlen));
+		}
+		if (iphdr_hlen > p->len)
+		{
+			LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
+							("IP header (len %" U16_F ") does not fit in first pbuf (len %" U16_F "), IP packet dropped.\n",
+							 iphdr_hlen, p->len));
+		}
+		if (iphdr_len > p->tot_len)
+		{
+			LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
+							("IP (len %" U16_F ") is longer than pbuf (len %" U16_F "), IP packet dropped.\n",
+							 iphdr_len, p->tot_len));
+		}
+		/* free (drop) packet pbufs */
+		pbuf_free(p);
+		IP_STATS_INC(ip.lenerr);
+		IP_STATS_INC(ip.drop);
+		MIB2_STATS_INC(mib2.ipindiscards);
+		return ERR_OK;
+	}
+
+	/* verify checksum */
 #if CHECKSUM_CHECK_IP
-  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_IP) {
-    if (inet_chksum(iphdr, iphdr_hlen) != 0) {
-
-      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
-                  ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
-      ip4_debug_print(p);
-      pbuf_free(p);
-      IP_STATS_INC(ip.chkerr);
-      IP_STATS_INC(ip.drop);
-      MIB2_STATS_INC(mib2.ipinhdrerrors);
-      return ERR_OK;
-    }
-  }
+	IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_IP)
+	{
+		if (inet_chksum(iphdr, iphdr_hlen) != 0)
+		{
+
+			LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
+							("Checksum (0x%" X16_F ") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
+			ip4_debug_print(p);
+			pbuf_free(p);
+			IP_STATS_INC(ip.chkerr);
+			IP_STATS_INC(ip.drop);
+			MIB2_STATS_INC(mib2.ipinhdrerrors);
+			return ERR_OK;
+		}
+	}
 #endif
 
-  /* copy IP addresses to aligned ip_addr_t */
-  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
-  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
+	/* copy IP addresses to aligned ip_addr_t */
+	ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
+	ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 
-  /* match packet against an interface, i.e. is this packet for us? */
-  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
+	/* match packet against an interface, i.e. is this packet for us? */
+	if (ip4_addr_ismulticast(ip4_current_dest_addr()))
+	{
 #if LWIP_IGMP
-    if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, ip4_current_dest_addr()))) {
-      /* IGMP snooping switches need 0.0.0.0 to be allowed as source address (RFC 4541) */
-      ip4_addr_t allsystems;
-      IP4_ADDR(&allsystems, 224, 0, 0, 1);
-      if (ip4_addr_cmp(ip4_current_dest_addr(), &allsystems) &&
-          ip4_addr_isany(ip4_current_src_addr())) {
-        check_ip_src = 0;
-      }
-      netif = inp;
-    } else {
-      netif = NULL;
-    }
-#else /* LWIP_IGMP */
-    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
-      netif = inp;
-    } else {
-      netif = NULL;
-    }
+		if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, ip4_current_dest_addr())))
+		{
+			/* IGMP snooping switches need 0.0.0.0 to be allowed as source address (RFC 4541) */
+			ip4_addr_t allsystems;
+			IP4_ADDR(&allsystems, 224, 0, 0, 1);
+			if (ip4_addr_cmp(ip4_current_dest_addr(), &allsystems) &&
+				 ip4_addr_isany(ip4_current_src_addr()))
+			{
+				check_ip_src = 0;
+			}
+			netif = inp;
+		}
+		else
+		{
+			netif = NULL;
+		}
+#else	 /* LWIP_IGMP */
+		if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp))))
+		{
+			netif = inp;
+		}
+		else
+		{
+			netif = NULL;
+		}
 #endif /* LWIP_IGMP */
-  } else {
-    /* start trying with inp. if that's not acceptable, start walking the
-       list of configured netifs. */
-    if (ip4_input_accept(inp)) {
-      netif = inp;
-    } else {
-      netif = NULL;
+	}
+	else
+	{
+		/* start trying with inp. if that's not acceptable, start walking the
+			list of configured netifs. */
+		if (ip4_input_accept(inp))
+		{
+			netif = inp;
+		}
+		else
+		{
+			netif = NULL;
 #if !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF
-      /* Packets sent to the loopback address must not be accepted on an
-       * interface that does not have the loopback address assigned to it,
-       * unless a non-loopback interface is used for loopback traffic. */
-      if (!ip4_addr_isloopback(ip4_current_dest_addr()))
+			/* Packets sent to the loopback address must not be accepted on an
+			 * interface that does not have the loopback address assigned to it,
+			 * unless a non-loopback interface is used for loopback traffic. */
+			if (!ip4_addr_isloopback(ip4_current_dest_addr()))
 #endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
-      {
+			{
 #if !LWIP_SINGLE_NETIF
-        NETIF_FOREACH(netif) {
-          if (netif == inp) {
-            /* we checked that before already */
-            continue;
-          }
-          if (ip4_input_accept(netif)) {
-            break;
-          }
-        }
+				NETIF_FOREACH(netif)
+				{
+					if (netif == inp)
+					{
+						/* we checked that before already */
+						continue;
+					}
+					if (ip4_input_accept(netif))
+					{
+						break;
+					}
+				}
 #endif /* !LWIP_SINGLE_NETIF */
-      }
-    }
-  }
+			}
+		}
+	}
 
 #if IP_ACCEPT_LINK_LAYER_ADDRESSING
-  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
-   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
-   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
-   *
-   * If you want to accept private broadcast communication while a netif is down,
-   * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
-   *
-   * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
-   */
-  if (netif == NULL) {
-    /* remote port is DHCP server? */
-    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
-      const struct udp_hdr *udphdr = (const struct udp_hdr *)((const u8_t *)iphdr + iphdr_hlen);
-      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: UDP packet to DHCP client port %"U16_F"\n",
-                                              lwip_ntohs(udphdr->dest)));
-      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
-        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: DHCP packet accepted.\n"));
-        netif = inp;
-        check_ip_src = 0;
-      }
-    }
-  }
+	/* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
+	 * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
+	 * According to RFC 1542 section 3.1.1, referred by RFC 2131).
+	 *
+	 * If you want to accept private broadcast communication while a netif is down,
+	 * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
+	 *
+	 * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
+	 */
+	if (netif == NULL)
+	{
+		/* remote port is DHCP server? */
+		if (IPH_PROTO(iphdr) == IP_PROTO_UDP)
+		{
+			const struct udp_hdr *udphdr = (const struct udp_hdr *)((const u8_t *)iphdr + iphdr_hlen);
+			LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: UDP packet to DHCP client port %" U16_F "\n",
+																 lwip_ntohs(udphdr->dest)));
+			if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest))
+			{
+				LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: DHCP packet accepted.\n"));
+				netif = inp;
+				check_ip_src = 0;
+			}
+		}
+	}
 #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
 
-  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
+	/* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
 #if LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING
-  if (check_ip_src
+	if (check_ip_src
 #if IP_ACCEPT_LINK_LAYER_ADDRESSING
-      /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
-      && !ip4_addr_isany_val(*ip4_current_src_addr())
+		 /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
+		 && !ip4_addr_isany_val(*ip4_current_src_addr())
 #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
-     )
+	)
 #endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
-  {
-    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
-        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
-      /* packet source is not valid */
-      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip4_input: packet source is not valid.\n"));
-      /* free (drop) packet pbufs */
-      pbuf_free(p);
-      IP_STATS_INC(ip.drop);
-      MIB2_STATS_INC(mib2.ipinaddrerrors);
-      MIB2_STATS_INC(mib2.ipindiscards);
-      return ERR_OK;
-    }
-  }
-
-  /* packet not for us? */
-  if (netif == NULL) {
-    /* packet not for us, route or discard */
-    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: packet not for us.\n"));
+	{
+		if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
+			 (ip4_addr_ismulticast(ip4_current_src_addr())))
+		{
+			/* packet source is not valid */
+			LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip4_input: packet source is not valid.\n"));
+			/* free (drop) packet pbufs */
+			pbuf_free(p);
+			IP_STATS_INC(ip.drop);
+			MIB2_STATS_INC(mib2.ipinaddrerrors);
+			MIB2_STATS_INC(mib2.ipindiscards);
+			return ERR_OK;
+		}
+	}
+
+	/* packet not for us? */
+	if (netif == NULL)
+	{
+		/* packet not for us, route or discard */
+		LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: packet not for us.\n"));
 #if IP_FORWARD
-    /* non-broadcast packet? */
-    if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), inp)) {
-      /* try to forward IP packet on (other) interfaces */
-      ip4_forward(p, (struct ip_hdr *)p->payload, inp);
-    } else
+		/* non-broadcast packet? */
+		if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), inp))
+		{
+			/* try to forward IP packet on (other) interfaces */
+			ip4_forward(p, (struct ip_hdr *)p->payload, inp);
+		}
+		else
 #endif /* IP_FORWARD */
-    {
-      IP_STATS_INC(ip.drop);
-      MIB2_STATS_INC(mib2.ipinaddrerrors);
-      MIB2_STATS_INC(mib2.ipindiscards);
-    }
-    pbuf_free(p);
-    return ERR_OK;
-  }
-  /* packet consists of multiple fragments? */
-  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
+		{
+			IP_STATS_INC(ip.drop);
+			MIB2_STATS_INC(mib2.ipinaddrerrors);
+			MIB2_STATS_INC(mib2.ipindiscards);
+		}
+		pbuf_free(p);
+		return ERR_OK;
+	}
+	/* packet consists of multiple fragments? */
+	if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0)
+	{
 #if IP_REASSEMBLY /* packet fragment reassembly code present? */
-    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip4_reass()\n",
-                           lwip_ntohs(IPH_ID(iphdr)), p->tot_len, lwip_ntohs(IPH_LEN(iphdr)), (u16_t)!!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (u16_t)((lwip_ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK) * 8)));
-    /* reassemble the packet*/
-    p = ip4_reass(p);
-    /* packet not fully reassembled yet? */
-    if (p == NULL) {
-      return ERR_OK;
-    }
-    iphdr = (const struct ip_hdr *)p->payload;
-#else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
-    pbuf_free(p);
-    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since it was fragmented (0x%"X16_F") (while IP_REASSEMBLY == 0).\n",
-                lwip_ntohs(IPH_OFFSET(iphdr))));
-    IP_STATS_INC(ip.opterr);
-    IP_STATS_INC(ip.drop);
-    /* unsupported protocol feature */
-    MIB2_STATS_INC(mib2.ipinunknownprotos);
-    return ERR_OK;
+		LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04" X16_F " tot_len=%" U16_F " len=%" U16_F " MF=%" U16_F " offset=%" U16_F "), calling ip4_reass()\n",
+									  lwip_ntohs(IPH_ID(iphdr)), p->tot_len, lwip_ntohs(IPH_LEN(iphdr)), (u16_t) !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (u16_t)((lwip_ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK) * 8)));
+		/* reassemble the packet*/
+		p = ip4_reass(p);
+		/* packet not fully reassembled yet? */
+		if (p == NULL)
+		{
+			return ERR_OK;
+		}
+		iphdr = (const struct ip_hdr *)p->payload;
+#else	 /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
+		pbuf_free(p);
+		LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since it was fragmented (0x%" X16_F ") (while IP_REASSEMBLY == 0).\n",
+																		lwip_ntohs(IPH_OFFSET(iphdr))));
+		IP_STATS_INC(ip.opterr);
+		IP_STATS_INC(ip.drop);
+		/* unsupported protocol feature */
+		MIB2_STATS_INC(mib2.ipinunknownprotos);
+		return ERR_OK;
 #endif /* IP_REASSEMBLY */
-  }
+	}
 
 #if IP_OPTIONS_ALLOWED == 0 /* no support for IP options in the IP header? */
 
 #if LWIP_IGMP
-  /* there is an extra "router alert" option in IGMP messages which we allow for but do not police */
-  if ((iphdr_hlen > IP_HLEN) &&  (IPH_PROTO(iphdr) != IP_PROTO_IGMP)) {
+	/* there is an extra "router alert" option in IGMP messages which we allow for but do not police */
+	if ((iphdr_hlen > IP_HLEN) && (IPH_PROTO(iphdr) != IP_PROTO_IGMP))
+	{
 #else
-  if (iphdr_hlen > IP_HLEN) {
+	if (iphdr_hlen > IP_HLEN)
+	{
 #endif /* LWIP_IGMP */
-    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since there were IP options (while IP_OPTIONS_ALLOWED == 0).\n"));
-    pbuf_free(p);
-    IP_STATS_INC(ip.opterr);
-    IP_STATS_INC(ip.drop);
-    /* unsupported protocol feature */
-    MIB2_STATS_INC(mib2.ipinunknownprotos);
-    return ERR_OK;
-  }
+		LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since there were IP options (while IP_OPTIONS_ALLOWED == 0).\n"));
+		pbuf_free(p);
+		IP_STATS_INC(ip.opterr);
+		IP_STATS_INC(ip.drop);
+		/* unsupported protocol feature */
+		MIB2_STATS_INC(mib2.ipinunknownprotos);
+		return ERR_OK;
+	}
 #endif /* IP_OPTIONS_ALLOWED == 0 */
 
-  /* send to upper layers */
-  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: \n"));
-  ip4_debug_print(p);
-  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));
+	/* send to upper layers */
+	LWIP_DEBUGF(IP_DEBUG, ("ip4_input: \n"));
+	ip4_debug_print(p);
+	LWIP_DEBUGF(IP_DEBUG, ("ip4_input: p->len %" U16_F " p->tot_len %" U16_F "\n", p->len, p->tot_len));
 
-  ip_data.current_netif = netif;
-  ip_data.current_input_netif = inp;
-  ip_data.current_ip4_header = iphdr;
-  ip_data.current_ip_header_tot_len = IPH_HL_BYTES(iphdr);
+	ip_data.current_netif = netif;
+	ip_data.current_input_netif = inp;
+	ip_data.current_ip4_header = iphdr;
+	ip_data.current_ip_header_tot_len = IPH_HL_BYTES(iphdr);
 
 #if LWIP_RAW
-  /* raw input did not eat the packet? */
-  raw_status = raw_input(p, inp);
-  if (raw_status != RAW_INPUT_EATEN)
+	/* raw input did not eat the packet? */
+	raw_status = raw_input(p, inp);
+	if (raw_status != RAW_INPUT_EATEN)
 #endif /* LWIP_RAW */
-  {
-    pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
+	{
+		pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
 
-    switch (IPH_PROTO(iphdr)) {
+		switch (IPH_PROTO(iphdr))
+		{
 #if LWIP_UDP
-      case IP_PROTO_UDP:
+		case IP_PROTO_UDP:
 #if LWIP_UDPLITE
-      case IP_PROTO_UDPLITE:
+		case IP_PROTO_UDPLITE:
 #endif /* LWIP_UDPLITE */
-        MIB2_STATS_INC(mib2.ipindelivers);
-        udp_input(p, inp);
-        break;
+			MIB2_STATS_INC(mib2.ipindelivers);
+			udp_input(p, inp);
+			break;
 #endif /* LWIP_UDP */
 #if LWIP_TCP
-      case IP_PROTO_TCP:
-        MIB2_STATS_INC(mib2.ipindelivers);
-        tcp_input(p, inp);
-        break;
+		case IP_PROTO_TCP:
+			MIB2_STATS_INC(mib2.ipindelivers);
+			tcp_input(p, inp);
+			break;
 #endif /* LWIP_TCP */
 #if LWIP_ICMP
-      case IP_PROTO_ICMP:
-        MIB2_STATS_INC(mib2.ipindelivers);
-        icmp_input(p, inp);
-        break;
+		case IP_PROTO_ICMP:
+			MIB2_STATS_INC(mib2.ipindelivers);
+			icmp_input(p, inp);
+			break;
 #endif /* LWIP_ICMP */
 #if LWIP_IGMP
-      case IP_PROTO_IGMP:
-        igmp_input(p, inp, ip4_current_dest_addr());
-        break;
+		case IP_PROTO_IGMP:
+			igmp_input(p, inp, ip4_current_dest_addr());
+			break;
 #endif /* LWIP_IGMP */
-      default:
+		default:
 #if LWIP_RAW
-        if (raw_status == RAW_INPUT_DELIVERED) {
-          MIB2_STATS_INC(mib2.ipindelivers);
-        } else
+			if (raw_status == RAW_INPUT_DELIVERED)
+			{
+				MIB2_STATS_INC(mib2.ipindelivers);
+			}
+			else
 #endif /* LWIP_RAW */
-        {
+			{
 #if LWIP_ICMP
-          /* send ICMP destination protocol unreachable unless is was a broadcast */
-          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
-              !ip4_addr_ismulticast(ip4_current_dest_addr())) {
-            pbuf_header_force(p, (s16_t)iphdr_hlen); /* Move to ip header, no check necessary. */
-            icmp_dest_unreach(p, ICMP_DUR_PROTO);
-          }
+				/* send ICMP destination protocol unreachable unless is was a broadcast */
+				if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
+					 !ip4_addr_ismulticast(ip4_current_dest_addr()))
+				{
+					pbuf_header_force(p, (s16_t)iphdr_hlen); /* Move to ip header, no check necessary. */
+					icmp_dest_unreach(p, ICMP_DUR_PROTO);
+				}
 #endif /* LWIP_ICMP */
 
-          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", (u16_t)IPH_PROTO(iphdr)));
-
-          IP_STATS_INC(ip.proterr);
-          IP_STATS_INC(ip.drop);
-          MIB2_STATS_INC(mib2.ipinunknownprotos);
-        }
-        pbuf_free(p);
-        break;
-    }
-  }
-
-  /* @todo: this is not really necessary... */
-  ip_data.current_netif = NULL;
-  ip_data.current_input_netif = NULL;
-  ip_data.current_ip4_header = NULL;
-  ip_data.current_ip_header_tot_len = 0;
-  ip4_addr_set_any(ip4_current_src_addr());
-  ip4_addr_set_any(ip4_current_dest_addr());
-
-  return ERR_OK;
+				LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %" U16_F "\n", (u16_t)IPH_PROTO(iphdr)));
+
+				IP_STATS_INC(ip.proterr);
+				IP_STATS_INC(ip.drop);
+				MIB2_STATS_INC(mib2.ipinunknownprotos);
+			}
+			pbuf_free(p);
+			break;
+		}
+	}
+
+	/* @todo: this is not really necessary... */
+	ip_data.current_netif = NULL;
+	ip_data.current_input_netif = NULL;
+	ip_data.current_ip4_header = NULL;
+	ip_data.current_ip_header_tot_len = 0;
+	ip4_addr_set_any(ip4_current_src_addr());
+	ip4_addr_set_any(ip4_current_dest_addr());
+
+	return ERR_OK;
 }
 
 /**
@@ -767,8 +840,8 @@ ip4_input(struct pbuf *p, struct netif *inp)
  * include an IP header and p->payload points to it instead of the data.
  *
  * @param p the packet to send (p->payload points to the data, e.g. next
-            protocol header; if dest == LWIP_IP_HDRINCL, p already includes an
-            IP header and p->payload points to that IP header)
+				protocol header; if dest == LWIP_IP_HDRINCL, p already includes an
+				IP header and p->payload points to that IP header)
  * @param src the source IP address to send from (if src == IP4_ADDR_ANY, the
  *         IP  address of the netif used to send is used as source address)
  * @param dest the destination IP address to send the packet to
@@ -783,13 +856,12 @@ ip4_input(struct pbuf *p, struct netif *inp)
  * @note ip_id: RFC791 "some host may be able to simply use
  *  unique identifiers independent of destination"
  */
-err_t
-ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
-              u8_t ttl, u8_t tos,
-              u8_t proto, struct netif *netif)
+err_t ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+						  u8_t ttl, u8_t tos,
+						  u8_t proto, struct netif *netif)
 {
 #if IP_OPTIONS_SEND
-  return ip4_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
+	return ip4_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
 }
 
 /**
@@ -798,24 +870,25 @@ ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
  * @ param ip_options pointer to the IP options, copied into the IP header
  * @ param optlen length of ip_options
  */
-err_t
-ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
-                  u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
-                  u16_t optlen)
+err_t ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+								u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
+								u16_t optlen)
 {
 #endif /* IP_OPTIONS_SEND */
-  const ip4_addr_t *src_used = src;
-  if (dest != LWIP_IP_HDRINCL) {
-    if (ip4_addr_isany(src)) {
-      src_used = netif_ip4_addr(netif);
-    }
-  }
+	const ip4_addr_t *src_used = src;
+	if (dest != LWIP_IP_HDRINCL)
+	{
+		if (ip4_addr_isany(src))
+		{
+			src_used = netif_ip4_addr(netif);
+		}
+	}
 
 #if IP_OPTIONS_SEND
-  return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
-                               ip_options, optlen);
-#else /* IP_OPTIONS_SEND */
-  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
+	return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
+										  ip_options, optlen);
+#else	 /* IP_OPTIONS_SEND */
+	return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 #endif /* IP_OPTIONS_SEND */
 }
 
@@ -823,188 +896,205 @@ ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
  * Same as ip_output_if() but 'src' address is not replaced by netif address
  * when it is 'any'.
  */
-err_t
-ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
-                  u8_t ttl, u8_t tos,
-                  u8_t proto, struct netif *netif)
+err_t ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+								u8_t ttl, u8_t tos,
+								u8_t proto, struct netif *netif)
 {
 #if IP_OPTIONS_SEND
-  return ip4_output_if_opt_src(p, src, dest, ttl, tos, proto, netif, NULL, 0);
+	return ip4_output_if_opt_src(p, src, dest, ttl, tos, proto, netif, NULL, 0);
 }
 
 /**
  * Same as ip_output_if_opt() but 'src' address is not replaced by netif address
  * when it is 'any'.
  */
-err_t
-ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
-                      u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
-                      u16_t optlen)
+err_t ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+									 u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
+									 u16_t optlen)
 {
 #endif /* IP_OPTIONS_SEND */
-  struct ip_hdr *iphdr;
-  ip4_addr_t dest_addr;
+	struct ip_hdr *iphdr;
+	ip4_addr_t dest_addr;
 #if CHECKSUM_GEN_IP_INLINE
-  u32_t chk_sum = 0;
+	u32_t chk_sum = 0;
 #endif /* CHECKSUM_GEN_IP_INLINE */
 
-  LWIP_ASSERT_CORE_LOCKED();
-  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
+	LWIP_ASSERT_CORE_LOCKED();
+	LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 
-  MIB2_STATS_INC(mib2.ipoutrequests);
+	MIB2_STATS_INC(mib2.ipoutrequests);
 
-  /* Should the IP header be generated or is it already included in p? */
-  if (dest != LWIP_IP_HDRINCL) {
-    u16_t ip_hlen = IP_HLEN;
+	/* Should the IP header be generated or is it already included in p? */
+	if (dest != LWIP_IP_HDRINCL)
+	{
+		u16_t ip_hlen = IP_HLEN;
 #if IP_OPTIONS_SEND
-    u16_t optlen_aligned = 0;
-    if (optlen != 0) {
+		u16_t optlen_aligned = 0;
+		if (optlen != 0)
+		{
 #if CHECKSUM_GEN_IP_INLINE
-      int i;
+			int i;
 #endif /* CHECKSUM_GEN_IP_INLINE */
-      if (optlen > (IP_HLEN_MAX - IP_HLEN)) {
-        /* optlen too long */
-        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output_if_opt: optlen too long\n"));
-        IP_STATS_INC(ip.err);
-        MIB2_STATS_INC(mib2.ipoutdiscards);
-        return ERR_VAL;
-      }
-      /* round up to a multiple of 4 */
-      optlen_aligned = (u16_t)((optlen + 3) & ~3);
-      ip_hlen = (u16_t)(ip_hlen + optlen_aligned);
-      /* First write in the IP options */
-      if (pbuf_add_header(p, optlen_aligned)) {
-        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output_if_opt: not enough room for IP options in pbuf\n"));
-        IP_STATS_INC(ip.err);
-        MIB2_STATS_INC(mib2.ipoutdiscards);
-        return ERR_BUF;
-      }
-      MEMCPY(p->payload, ip_options, optlen);
-      if (optlen < optlen_aligned) {
-        /* zero the remaining bytes */
-        memset(((char *)p->payload) + optlen, 0, (size_t)(optlen_aligned - optlen));
-      }
+			if (optlen > (IP_HLEN_MAX - IP_HLEN))
+			{
+				/* optlen too long */
+				LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output_if_opt: optlen too long\n"));
+				IP_STATS_INC(ip.err);
+				MIB2_STATS_INC(mib2.ipoutdiscards);
+				return ERR_VAL;
+			}
+			/* round up to a multiple of 4 */
+			optlen_aligned = (u16_t)((optlen + 3) & ~3);
+			ip_hlen = (u16_t)(ip_hlen + optlen_aligned);
+			/* First write in the IP options */
+			if (pbuf_add_header(p, optlen_aligned))
+			{
+				LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output_if_opt: not enough room for IP options in pbuf\n"));
+				IP_STATS_INC(ip.err);
+				MIB2_STATS_INC(mib2.ipoutdiscards);
+				return ERR_BUF;
+			}
+			MEMCPY(p->payload, ip_options, optlen);
+			if (optlen < optlen_aligned)
+			{
+				/* zero the remaining bytes */
+				memset(((char *)p->payload) + optlen, 0, (size_t)(optlen_aligned - optlen));
+			}
 #if CHECKSUM_GEN_IP_INLINE
-      for (i = 0; i < optlen_aligned / 2; i++) {
-        chk_sum += ((u16_t *)p->payload)[i];
-      }
+			for (i = 0; i < optlen_aligned / 2; i++)
+			{
+				chk_sum += ((u16_t *)p->payload)[i];
+			}
 #endif /* CHECKSUM_GEN_IP_INLINE */
-    }
+		}
 #endif /* IP_OPTIONS_SEND */
-    /* generate IP header */
-    if (pbuf_add_header(p, IP_HLEN)) {
-      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));
-
-      IP_STATS_INC(ip.err);
-      MIB2_STATS_INC(mib2.ipoutdiscards);
-      return ERR_BUF;
-    }
-
-    iphdr = (struct ip_hdr *)p->payload;
-    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
-                (p->len >= sizeof(struct ip_hdr)));
-
-    IPH_TTL_SET(iphdr, ttl);
-    IPH_PROTO_SET(iphdr, proto);
+		/* generate IP header */
+		if (pbuf_add_header(p, IP_HLEN))
+		{
+			LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));
+
+			IP_STATS_INC(ip.err);
+			MIB2_STATS_INC(mib2.ipoutdiscards);
+			return ERR_BUF;
+		}
+
+		iphdr = (struct ip_hdr *)p->payload;
+		LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
+						(p->len >= sizeof(struct ip_hdr)));
+
+		IPH_TTL_SET(iphdr, ttl);
+		IPH_PROTO_SET(iphdr, proto);
 #if CHECKSUM_GEN_IP_INLINE
-    chk_sum += PP_NTOHS(proto | (ttl << 8));
+		chk_sum += PP_NTOHS(proto | (ttl << 8));
 #endif /* CHECKSUM_GEN_IP_INLINE */
 
-    /* dest cannot be NULL here */
-    ip4_addr_copy(iphdr->dest, *dest);
+		/* dest cannot be NULL here */
+		ip4_addr_copy(iphdr->dest, *dest);
 #if CHECKSUM_GEN_IP_INLINE
-    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
-    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
+		chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
+		chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
 #endif /* CHECKSUM_GEN_IP_INLINE */
 
-    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
-    IPH_TOS_SET(iphdr, tos);
+		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
+		IPH_TOS_SET(iphdr, tos);
 #if CHECKSUM_GEN_IP_INLINE
-    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
+		chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
 #endif /* CHECKSUM_GEN_IP_INLINE */
-    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
+		IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 #if CHECKSUM_GEN_IP_INLINE
-    chk_sum += iphdr->_len;
+		chk_sum += iphdr->_len;
 #endif /* CHECKSUM_GEN_IP_INLINE */
-    IPH_OFFSET_SET(iphdr, 0);
-    IPH_ID_SET(iphdr, lwip_htons(ip_id));
+		IPH_OFFSET_SET(iphdr, 0);
+		IPH_ID_SET(iphdr, lwip_htons(ip_id));
 #if CHECKSUM_GEN_IP_INLINE
-    chk_sum += iphdr->_id;
+		chk_sum += iphdr->_id;
 #endif /* CHECKSUM_GEN_IP_INLINE */
-    ++ip_id;
-
-    if (src == NULL) {
-      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
-    } else {
-      /* src cannot be NULL here */
-      ip4_addr_copy(iphdr->src, *src);
-    }
+		++ip_id;
+
+		if (src == NULL)
+		{
+			ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
+		}
+		else
+		{
+			/* src cannot be NULL here */
+			ip4_addr_copy(iphdr->src, *src);
+		}
 
 #if CHECKSUM_GEN_IP_INLINE
-    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
-    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
-    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
-    chk_sum = (chk_sum >> 16) + chk_sum;
-    chk_sum = ~chk_sum;
-    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
-      iphdr->_chksum = (u16_t)chk_sum; /* network order */
-    }
+		chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
+		chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
+		chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
+		chk_sum = (chk_sum >> 16) + chk_sum;
+		chk_sum = ~chk_sum;
+		IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP)
+		{
+			iphdr->_chksum = (u16_t)chk_sum; /* network order */
+		}
 #if LWIP_CHECKSUM_CTRL_PER_NETIF
-    else {
-      IPH_CHKSUM_SET(iphdr, 0);
-    }
+		else
+		{
+			IPH_CHKSUM_SET(iphdr, 0);
+		}
 #endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
-#else /* CHECKSUM_GEN_IP_INLINE */
-    IPH_CHKSUM_SET(iphdr, 0);
+#else	 /* CHECKSUM_GEN_IP_INLINE */
+		IPH_CHKSUM_SET(iphdr, 0);
 #if CHECKSUM_GEN_IP
-    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
-      IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
-    }
+		IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP)
+		{
+			IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
+		}
 #endif /* CHECKSUM_GEN_IP */
 #endif /* CHECKSUM_GEN_IP_INLINE */
-  } else {
-    /* IP header already included in p */
-    if (p->len < IP_HLEN) {
-      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: LWIP_IP_HDRINCL but pbuf is too short\n"));
-      IP_STATS_INC(ip.err);
-      MIB2_STATS_INC(mib2.ipoutdiscards);
-      return ERR_BUF;
-    }
-    iphdr = (struct ip_hdr *)p->payload;
-    ip4_addr_copy(dest_addr, iphdr->dest);
-    dest = &dest_addr;
-  }
-
-  IP_STATS_INC(ip.xmit);
-
-  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], (u16_t)netif->num));
-  ip4_debug_print(p);
+	}
+	else
+	{
+		/* IP header already included in p */
+		if (p->len < IP_HLEN)
+		{
+			LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: LWIP_IP_HDRINCL but pbuf is too short\n"));
+			IP_STATS_INC(ip.err);
+			MIB2_STATS_INC(mib2.ipoutdiscards);
+			return ERR_BUF;
+		}
+		iphdr = (struct ip_hdr *)p->payload;
+		ip4_addr_copy(dest_addr, iphdr->dest);
+		dest = &dest_addr;
+	}
+
+	IP_STATS_INC(ip.xmit);
+
+	LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: %c%c%" U16_F "\n", netif->name[0], netif->name[1], (u16_t)netif->num));
+	ip4_debug_print(p);
 
 #if ENABLE_LOOPBACK
-  if (ip4_addr_cmp(dest, netif_ip4_addr(netif))
+	if (ip4_addr_cmp(dest, netif_ip4_addr(netif))
 #if !LWIP_HAVE_LOOPIF
-      || ip4_addr_isloopback(dest)
+		 || ip4_addr_isloopback(dest)
 #endif /* !LWIP_HAVE_LOOPIF */
-     ) {
-    /* Packet to self, enqueue it for loopback */
-    LWIP_DEBUGF(IP_DEBUG, ("netif_loop_output()"));
-    return netif_loop_output(netif, p);
-  }
+	)
+	{
+		/* Packet to self, enqueue it for loopback */
+		LWIP_DEBUGF(IP_DEBUG, ("netif_loop_output()"));
+		return netif_loop_output(netif, p);
+	}
 #if LWIP_MULTICAST_TX_OPTIONS
-  if ((p->flags & PBUF_FLAG_MCASTLOOP) != 0) {
-    netif_loop_output(netif, p);
-  }
+	if ((p->flags & PBUF_FLAG_MCASTLOOP) != 0)
+	{
+		netif_loop_output(netif, p);
+	}
 #endif /* LWIP_MULTICAST_TX_OPTIONS */
 #endif /* ENABLE_LOOPBACK */
 #if IP_FRAG
-  /* don't fragment if interface has mtu set to 0 [loopif] */
-  if (netif->mtu && (p->tot_len > netif->mtu)) {
-    return ip4_frag(p, netif, dest);
-  }
+	/* don't fragment if interface has mtu set to 0 [loopif] */
+	if (netif->mtu && (p->tot_len > netif->mtu))
+	{
+		return ip4_frag(p, netif, dest);
+	}
 #endif /* IP_FRAG */
 
-  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
-  return netif->output(netif, p, dest);
+	LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
+	return netif->output(netif, p, dest);
 }
 
 /**
@@ -1012,8 +1102,8 @@ ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *d
  * interface and calls upon ip_output_if to do the actual work.
  *
  * @param p the packet to send (p->payload points to the data, e.g. next
-            protocol header; if dest == LWIP_IP_HDRINCL, p already includes an
-            IP header and p->payload points to that IP header)
+				protocol header; if dest == LWIP_IP_HDRINCL, p already includes an
+				IP header and p->payload points to that IP header)
  * @param src the source IP address to send from (if src == IP4_ADDR_ANY, the
  *         IP  address of the netif used to send is used as source address)
  * @param dest the destination IP address to send the packet to
@@ -1024,22 +1114,22 @@ ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *d
  * @return ERR_RTE if no route is found
  *         see ip_output_if() for more return values
  */
-err_t
-ip4_output(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
-           u8_t ttl, u8_t tos, u8_t proto)
+err_t ip4_output(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+					  u8_t ttl, u8_t tos, u8_t proto)
 {
-  struct netif *netif;
+	struct netif *netif;
 
-  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
+	LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 
-  if ((netif = ip4_route_src(src, dest)) == NULL) {
-    LWIP_DEBUGF(IP_DEBUG, ("ip4_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
-                           ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
-    IP_STATS_INC(ip.rterr);
-    return ERR_RTE;
-  }
+	if ((netif = ip4_route_src(src, dest)) == NULL)
+	{
+		LWIP_DEBUGF(IP_DEBUG, ("ip4_output: No route to %" U16_F ".%" U16_F ".%" U16_F ".%" U16_F "\n",
+									  ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
+		IP_STATS_INC(ip.rterr);
+		return ERR_RTE;
+	}
 
-  return ip4_output_if(p, src, dest, ttl, tos, proto, netif);
+	return ip4_output_if(p, src, dest, ttl, tos, proto, netif);
 }
 
 #if LWIP_NETIF_USE_HINTS
@@ -1047,8 +1137,8 @@ ip4_output(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
  *  before calling ip_output_if.
  *
  * @param p the packet to send (p->payload points to the data, e.g. next
-            protocol header; if dest == LWIP_IP_HDRINCL, p already includes an
-            IP header and p->payload points to that IP header)
+				protocol header; if dest == LWIP_IP_HDRINCL, p already includes an
+				IP header and p->payload points to that IP header)
  * @param src the source IP address to send from (if src == IP4_ADDR_ANY, the
  *         IP  address of the netif used to send is used as source address)
  * @param dest the destination IP address to send the packet to
@@ -1061,27 +1151,27 @@ ip4_output(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
  * @return ERR_RTE if no route is found
  *         see ip_output_if() for more return values
  */
-err_t
-ip4_output_hinted(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
-                  u8_t ttl, u8_t tos, u8_t proto, struct netif_hint *netif_hint)
+err_t ip4_output_hinted(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+								u8_t ttl, u8_t tos, u8_t proto, struct netif_hint *netif_hint)
 {
-  struct netif *netif;
-  err_t err;
+	struct netif *netif;
+	err_t err;
 
-  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
+	LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 
-  if ((netif = ip4_route_src(src, dest)) == NULL) {
-    LWIP_DEBUGF(IP_DEBUG, ("ip4_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
-                           ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
-    IP_STATS_INC(ip.rterr);
-    return ERR_RTE;
-  }
+	if ((netif = ip4_route_src(src, dest)) == NULL)
+	{
+		LWIP_DEBUGF(IP_DEBUG, ("ip4_output: No route to %" U16_F ".%" U16_F ".%" U16_F ".%" U16_F "\n",
+									  ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
+		IP_STATS_INC(ip.rterr);
+		return ERR_RTE;
+	}
 
-  NETIF_SET_HINTS(netif, netif_hint);
-  err = ip4_output_if(p, src, dest, ttl, tos, proto, netif);
-  NETIF_RESET_HINTS(netif);
+	NETIF_SET_HINTS(netif, netif_hint);
+	err = ip4_output_if(p, src, dest, ttl, tos, proto, netif);
+	NETIF_RESET_HINTS(netif);
 
-  return err;
+	return err;
 }
 #endif /* LWIP_NETIF_USE_HINTS*/
 
@@ -1089,43 +1179,42 @@ ip4_output_hinted(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
 /* Print an IP header by using LWIP_DEBUGF
  * @param p an IP packet, p->payload pointing to the IP header
  */
-void
-ip4_debug_print(struct pbuf *p)
+void ip4_debug_print(struct pbuf *p)
 {
-  struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
-
-  LWIP_DEBUGF(IP_DEBUG, ("IP header:\n"));
-  LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
-  LWIP_DEBUGF(IP_DEBUG, ("|%2"S16_F" |%2"S16_F" |  0x%02"X16_F" |     %5"U16_F"     | (v, hl, tos, len)\n",
-                         (u16_t)IPH_V(iphdr),
-                         (u16_t)IPH_HL(iphdr),
-                         (u16_t)IPH_TOS(iphdr),
-                         lwip_ntohs(IPH_LEN(iphdr))));
-  LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
-  LWIP_DEBUGF(IP_DEBUG, ("|    %5"U16_F"      |%"U16_F"%"U16_F"%"U16_F"|    %4"U16_F"   | (id, flags, offset)\n",
-                         lwip_ntohs(IPH_ID(iphdr)),
-                         (u16_t)(lwip_ntohs(IPH_OFFSET(iphdr)) >> 15 & 1),
-                         (u16_t)(lwip_ntohs(IPH_OFFSET(iphdr)) >> 14 & 1),
-                         (u16_t)(lwip_ntohs(IPH_OFFSET(iphdr)) >> 13 & 1),
-                         (u16_t)(lwip_ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)));
-  LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
-  LWIP_DEBUGF(IP_DEBUG, ("|  %3"U16_F"  |  %3"U16_F"  |    0x%04"X16_F"     | (ttl, proto, chksum)\n",
-                         (u16_t)IPH_TTL(iphdr),
-                         (u16_t)IPH_PROTO(iphdr),
-                         lwip_ntohs(IPH_CHKSUM(iphdr))));
-  LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
-  LWIP_DEBUGF(IP_DEBUG, ("|  %3"U16_F"  |  %3"U16_F"  |  %3"U16_F"  |  %3"U16_F"  | (src)\n",
-                         ip4_addr1_16_val(iphdr->src),
-                         ip4_addr2_16_val(iphdr->src),
-                         ip4_addr3_16_val(iphdr->src),
-                         ip4_addr4_16_val(iphdr->src)));
-  LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
-  LWIP_DEBUGF(IP_DEBUG, ("|  %3"U16_F"  |  %3"U16_F"  |  %3"U16_F"  |  %3"U16_F"  | (dest)\n",
-                         ip4_addr1_16_val(iphdr->dest),
-                         ip4_addr2_16_val(iphdr->dest),
-                         ip4_addr3_16_val(iphdr->dest),
-                         ip4_addr4_16_val(iphdr->dest)));
-  LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
+	struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
+
+	LWIP_DEBUGF(IP_DEBUG, ("IP header:\n"));
+	LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
+	LWIP_DEBUGF(IP_DEBUG, ("|%2" S16_F " |%2" S16_F " |  0x%02" X16_F " |     %5" U16_F "     | (v, hl, tos, len)\n",
+								  (u16_t)IPH_V(iphdr),
+								  (u16_t)IPH_HL(iphdr),
+								  (u16_t)IPH_TOS(iphdr),
+								  lwip_ntohs(IPH_LEN(iphdr))));
+	LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
+	LWIP_DEBUGF(IP_DEBUG, ("|    %5" U16_F "      |%" U16_F "%" U16_F "%" U16_F "|    %4" U16_F "   | (id, flags, offset)\n",
+								  lwip_ntohs(IPH_ID(iphdr)),
+								  (u16_t)(lwip_ntohs(IPH_OFFSET(iphdr)) >> 15 & 1),
+								  (u16_t)(lwip_ntohs(IPH_OFFSET(iphdr)) >> 14 & 1),
+								  (u16_t)(lwip_ntohs(IPH_OFFSET(iphdr)) >> 13 & 1),
+								  (u16_t)(lwip_ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)));
+	LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
+	LWIP_DEBUGF(IP_DEBUG, ("|  %3" U16_F "  |  %3" U16_F "  |    0x%04" X16_F "     | (ttl, proto, chksum)\n",
+								  (u16_t)IPH_TTL(iphdr),
+								  (u16_t)IPH_PROTO(iphdr),
+								  lwip_ntohs(IPH_CHKSUM(iphdr))));
+	LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
+	LWIP_DEBUGF(IP_DEBUG, ("|  %3" U16_F "  |  %3" U16_F "  |  %3" U16_F "  |  %3" U16_F "  | (src)\n",
+								  ip4_addr1_16_val(iphdr->src),
+								  ip4_addr2_16_val(iphdr->src),
+								  ip4_addr3_16_val(iphdr->src),
+								  ip4_addr4_16_val(iphdr->src)));
+	LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
+	LWIP_DEBUGF(IP_DEBUG, ("|  %3" U16_F "  |  %3" U16_F "  |  %3" U16_F "  |  %3" U16_F "  | (dest)\n",
+								  ip4_addr1_16_val(iphdr->dest),
+								  ip4_addr2_16_val(iphdr->dest),
+								  ip4_addr3_16_val(iphdr->dest),
+								  ip4_addr4_16_val(iphdr->dest)));
+	LWIP_DEBUGF(IP_DEBUG, ("+-------------------------------+\n"));
 }
 #endif /* IP_DEBUG */
 
diff --git a/src/core/pbuf.c b/src/core/pbuf.c
index 7638dfd..517802c 100644
--- a/src/core/pbuf.c
+++ b/src/core/pbuf.c
@@ -475,7 +475,6 @@ pbuf_add_header_impl(struct pbuf *p, size_t header_size_increment, u8_t force)
   u16_t type_internal;
   void *payload;
   u16_t increment_magnitude;
-
   LWIP_ASSERT("p != NULL", p != NULL);
   if ((p == NULL) || (header_size_increment > 0xFFFF)) {
     return 1;
@@ -507,7 +506,7 @@ pbuf_add_header_impl(struct pbuf *p, size_t header_size_increment, u8_t force)
     /* pbuf types referring to external payloads? */
   } else {
     /* hide a header in the payload? */
-    if (force) {
+    if (1) {
       payload = (u8_t *)p->payload - header_size_increment;
     } else {
       /* cannot expand payload to front (yet!)
diff --git a/src/include/lwip/opt.h b/src/include/lwip/opt.h
index d8c82d1..f813201 100644
--- a/src/include/lwip/opt.h
+++ b/src/include/lwip/opt.h
@@ -386,7 +386,7 @@
  * - mem_free_callback(m);
  */
 #if !defined LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT || defined __DOXYGEN__
-#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
+#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 1
 #endif
 /**
  * @}
@@ -733,7 +733,7 @@
  * interface, define this to 0.
  */
 #if !defined IP_FORWARD || defined __DOXYGEN__
-#define IP_FORWARD                      0
+#define IP_FORWARD                      1
 #endif
 
 /**
@@ -861,7 +861,7 @@
  * LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only)
  */
 #if !defined LWIP_BROADCAST_PING || defined __DOXYGEN__
-#define LWIP_BROADCAST_PING             0
+#define LWIP_BROADCAST_PING             1
 #endif
 
 /**
@@ -888,7 +888,7 @@
  * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
  */
 #if !defined LWIP_RAW || defined __DOXYGEN__
-#define LWIP_RAW                        0
+#define LWIP_RAW                        1
 #endif
 
 /**
@@ -2014,7 +2014,7 @@
  * LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing.
  */
 #if !defined LWIP_SO_RCVBUF || defined __DOXYGEN__
-#define LWIP_SO_RCVBUF                  0
+#define LWIP_SO_RCVBUF                  1
 #endif
 
 /**
diff --git a/src/netif/ethernet.c b/src/netif/ethernet.c
index dd171e2..6422300 100644
--- a/src/netif/ethernet.c
+++ b/src/netif/ethernet.c
@@ -272,7 +272,6 @@ ethernet_output(struct netif * netif, struct pbuf * p,
                 u16_t eth_type) {
   struct eth_hdr *ethhdr;
   u16_t eth_type_be = lwip_htons(eth_type);
-
 #if ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET)
   s32_t vlan_prio_vid = LWIP_HOOK_VLAN_SET(netif, p, src, dst, eth_type);
   if (vlan_prio_vid >= 0) {
@@ -295,7 +294,6 @@ ethernet_output(struct netif * netif, struct pbuf * p,
       goto pbuf_header_failed;
     }
   }
-
   LWIP_ASSERT_CORE_LOCKED();
 
   ethhdr = (struct eth_hdr *)p->payload;
-- 
2.34.1

